基本事項（Basic concepts）
================================================================================

宣言と定義（Declarations and definitions）
--------------------------------------------------------------------------------



C++には、名前という概念が存在する。変数や関数、クラス等には、名前をつけられる。名前を使うには、必ず、あらかじめ、その名前が宣言されていなければならない。



宣言（Declaration）と定義（Definition）の違い
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



宣言とは、ある名前が、その翻訳単位で、何を意味するのかということを、明示するためにある。



定義とは、名前の指し示すものを、具体的に記述することである。宣言と定義は、多くの場合、同時に行われることが多いので、あまり意識しづらい。




.. code-block:: c++
  
  // これは関数の宣言
  void f( ) ;
  
  // これは関数の宣言と定義
  void f( ) { }


以下の例は、関数を宣言だけして、具体的な定義をせずに、使っている。



.. code-block:: c++
  
  // 関数の宣言
  int f( int ) ;
  
  int main()
  {
      int x = f( 0 ) ;
  }


これは、問題がない。なぜならば、関数を使うには、引数や戻り値の型などが決まってさえいればよいからだ。この場合、その関数を指し示す名前として、fが使われている。この関数 int f( int )の、具体的な実装、つまり、「定義」は、同じ翻訳単位になくても構わない。つまり、int f( int )は、別のソースコードで定義されているかもしれない。




定義ではない宣言
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



<p class="editorial-note">
TODO: FDIS後に変更される。



すべての定義は、宣言である。宣言は、定義ではない場合もある。定義ではない宣言は、以下の通りである。



 関数宣言で、関数の本体がない場合。 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  // 宣言
  void f( int ) ;
  
  // 宣言と定義
  void f ( int )  { } 




 extern指定子を使っていて、初期化子も、関数の本体も記述されていない宣言。 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  // 宣言
  extern int x ;
  
  // 宣言と定義
  int x ;




 リンケージ指定されていて、初期化子も、関数の本体も記述されていない宣言。ただし、{}の中の宣言には、影響しない。 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  // 宣言
  extern "C" void f() ;
  
  
  extern "C"
  {
  // これは、宣言と定義
      void f() { }
      int x ;
  
  // 宣言
      void g() ;
      extern int y ;
  }




 クラス名の宣言。 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  // クラス名の宣言
  class C ;
  
  // クラスの宣言と定義
  class C { } ;




 クラス定義の中の、staticなデータメンバーの宣言。 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  class C
  {
  // 宣言
      static int x ;
  } ;
  
  // 定義
  int C::x ;




 enum名の宣言 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  // 宣言
  enum E ;
  
  // 宣言と定義
  enum E { up, down } ;




 typedef宣言 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  // 宣言
  typedef int type ;




 using宣言と、usingディレクティブ 
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



.. code-block:: c++
  
  namespace NS { void f(){} } 
  
  // 宣言
  using NS::f ;
  using namespace NS ;




また、static_assert宣言、アトリビュート宣言、空宣言は、定義ではない。



.. code-block:: c++
  
  static_assert( true, "" ) ; // 宣言
  [[ ]] ; // 宣言
   ; // 宣言




ODR（One definition rule）
--------------------------------------------------------------------------------



ODR（One definition rule）とは、定義は原則として、ひとつしか書けないというルールである。


多くの場合、同じ宣言は、いくつでも書ける。ただし、変数、関数、クラス型、enum型、テンプレートの、同じ定義は、ひとつしか書くことができない。



.. code-block:: c++
  
  // 同じ宣言はいくつでも書ける。
  void f() ; void f() ; void f() ; void f() ;
  
  // 定義はひとつしか書けない。
  void f() { }
  
  // エラー、定義が重複している
  void f() { }


定義は、プログラムのすべての翻訳単位で、一つでなければならない。なぜ定義はひとつしか書けないのか。定義が複数あると、問題があるからだ。



.. code-block:: c++
  
  // 定義が二つある。
  int x ;
  int x ;
  // どっちのx？
  x = 0 ;
  
  // 定義が二つある
  void f() { }
  void f() { }
  
  // どっちのf()？
  f() ;


このような問題を防ぐために、定義は、原則として一つでなければならないとされている。



原則としてというのは、例外があるのだ。もし、本当に、定義を一箇所でしか書けないと、困ることがある。たとえば、クラスだ。



.. code-block:: c++
  
  // 翻訳単位1 A.cpp
  // 定義
  struct C
  {
      int x ;
  } ;
  
  C c ; // OK


.. code-block:: c++
  
  // 翻訳単位2 B.cpp
  // 宣言
  struct C ;
  
  C c ; // エラー


翻訳単位2で、クラスCの変数を定義するためには、クラスCは、定義されていなければならない。しかし、すでに、別の翻訳単位で、定義は書かれている。B.cppにも定義を書いてしまうと、ODRに違反する。これは一体、どうすればいいのか。



このため、C++では、クラス型、enum型、外部リンケージを持つインライン関数、クラステンプレート、外部リンケージを持つ関数テンプレート、クラステンプレートのstaticデータメンバー、クラステンプレートのメンバー関数、具体的な型を完全に指定していないテンプレートの特殊化に限り、ある条件を満たせば、別の翻訳単位での、定義の重複を認めている。ある条件とは何か。これには、大きく分けて、二つある。



 同じ定義のソースコードは、全く同じトークン列であること。 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. code-block:: c++
  
  // 翻訳単位1 A.cpp
  struct C
  {
      int x ;
  } ;


.. code-block:: c++
  
  // 翻訳単位2 B.cpp
  struct C
  {
  public :// エラー。
      int x ;
  } ;


ここで、翻訳単位2に、public :があろうとなかろうと、意味は変わらない。しかし、全く同じトークン列ではないので、このプログラムはエラーである。



全く同じ複数の定義を管理するのは、極めて困難である。そのため、このように翻訳単位ごとに定義しなければならないクラスやテンプレートは、通常、ヘッダーファイルに記述して、必要な翻訳単位ごとに、#includeされる。



.. code-block:: c++
  
  // ヘッダーファイル C.h
  struct C
  {
      int x ;
  } ;


.. code-block:: c++
  
  // 翻訳単位1 A.cpp
  #include "C.h"
  
  C c ;


.. code-block:: c++
  
  // 翻訳単位2 B.cpp
  #include "C.h"
  
  C c ;




 定義の意味が、プログラム中のすべての翻訳単位で、同じであること。 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



定義のソースコードが、全く同じトークン列であるからといって、意味も同じであるとは限らない。



.. code-block:: c++
  
  // ヘッダーファイル C.h
  class C
  {
      void member()
      {
          f() ;// fという名前の、何らかの関数を呼び出す。
      }
  } ;


このクラス、Cは、member()というメンバー関数で、f()という関数を呼び出している。では、このクラスを使うコードが、以下のようであれば、どうなるか。



.. code-block:: c++
  
  // 翻訳単位1 A.cpp
  
  namespace A
  { void f() {} }
  
  // f()はA::f()を呼び出す
  using A::f ;
  
  #include "C.h"


.. code-block:: c++
  
  // 翻訳単位2 B.cpp
  
  namespace B
  { void f() {} }
  
  // f()はB::f()を呼び出す
  using B::f ;
  
  #include "C.h"


ヘッダーファイルによって、クラスCのソースコードのトークン列は、全く同じなのに、この例では、呼び出す関数が翻訳単位ごとに変わってしまう。このようなコードはエラーである。プログラム中の同じ定義は、必ず同じ意味でなければならない。




スコープ（Scope）
--------------------------------------------------------------------------------



宣言領域とスコープ（Declarative regions and scopes）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



宣言された名前には、その名前が有効に使える範囲が存在する。これを、宣言範囲（declarative region）、スコープ（scope）という。



.. code-block:: c++
  
  int x ;
  
  void f()
  {
      int y ;
  
      {
          int z ;
      }
  // ここではもう、zは使えない。
  }
  // ここではもう、yは使えない。
  
  // xは、ここでも使える。


ある名前は、スコープの中ならば、必ず同じ意味であるとは限らない。名前は上書きされる場合がある。



.. code-block:: c++
  
  void f()
  {// ブロック1
      int x ; // #1
      {// ブロック2
          int x ; //#2
          x = 0 ; // #2が使われる。
      }
      x = 0 ; // #1が使われる。
  }


この例では、ブロック1で宣言されたxは、ブロック2では、別の変数を指し示すxに、隠されている。



このように、スコープがネストする場合、外側のスコープの名前が、内側のスコープの名前に隠されてしまうことがある。




宣言場所（Point of declaration）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



スコープには、いくつもの種類がある。これを詳しく説明する前に、まず、宣言された名前は、どこから有効なのかということを、明らかにしておかなければならない。この、名前が有効になる始まりの場所を、宣言場所（Point of declaration）という。名前は、宣言のすぐ直後から有効になる。



.. code-block:: c++
  
  int x ;// 宣言場所
  // ここから、xが使える。


宣言場所は、初期化子よりも、前である。


.. code-block:: c++
  
  int x /*ここから名前xは有効*/ = x  ;


この例では、xという変数を宣言して、その変数の値で初期化している。このコードに実用的な意味はない。初期化子の中から、宣言された名前は使えるということを示すためだけの例である。



.. code-block:: c++
  
  // エラー
  int x[x/*ここでは、まだxは未定義*/] ;


この例は、エラーである。なぜなら、配列の要素数を指定する場所では、xは、まだ定義されていないからだ。これらの例は、通常は気にすることはない、些細な詳細である。一般に、宣言文のすぐ後から使えると考えておけばいい。




ブロックスコープ（Block scope）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



<a href="#stmt.block">ブロック</a>のスコープは、そのブロックの中である。これを、ブロックスコープと呼ぶ。よく、ローカル変数と呼んでいるものは、ブロックスコープの中で宣言された変数のことである。



.. code-block:: c++
  
  void f()
  {// ブロック1
  int x ;
      {// ブロック2
      int y ;
          {// ブロック3
          int z ;
          // x, y, zが使える
          }
      // x, yが使える。
      }
  // xが使える。
  }
  
  // ここで使える変数名はない。


ブロックはネストできるので、ネストされたブロックの中で、外側のスコープと同じ名前の変数を使いたい場合は、注意が必要である。



.. code-block:: c++
  
  void f()
  {
      int x ;
      {
          int x ;　// 外側のスコープのxは隠される。
      }
  }


関数の仮引数名は、関数本体の一番上のブロックスコープの終わりまで、有効である。



.. code-block:: c++
  
  void f( int x )
  {
  
  //xはここまで有効
  }
  // これ以降、xは使えない。




関数プロトタイプのスコープ（Function prototype scope）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



関数のプロトタイプ宣言にも、スコープがある。関数のプロトタイプ宣言のスコープは、その宣言の終わりまでである。



.. code-block:: c++
  
  auto f( int x ) -> decltype(x) ;


この例では、仮引数の名前が、decltypeに使われている。




関数のスコープ（Function scope）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



ブロックスコープではなく、関数自体にも、関数のスコープが存在する。これは、ある関数全体のスコープである。ただし、この関数のスコープが適用されるのは、ラベル名だけである。



.. code-block:: c++
  
  void f()
  {
      {
          label : ;
      }
  
      goto label ;// labelは、ここでも有効
  }


このように、ラベル名には、関数のスコープが適用される。




名前空間のスコープ（Namespace scope）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



名前空間のスコープというのは、少しややこしい。まず、名前空間の本体は、もちろんスコープである。



.. code-block:: c++
  
  namespace NS
  {
      int x ;
  // xが使える。
  }
  // ここでは、xは使えない。


この、名前空間の中の名前（上の例では、x）を、名前空間のメンバー名という。メンバー名のスコープは、名前空間の終わりまでである。



ところが、名前空間の本体の定義は、複数書くことができる。



.. code-block:: c++
  
  namespace NS
  {
      int x ;
  // xが使える。
  }
  // ここでは、xは使えない。
  
  
  namespace NS
  {
      // ここでも、xが使える。
      int y = x ;
  }


メンバー名は、その宣言された場所から、後続するすべての同名の名前空間の中で使うことができる。この例の場合、二つめの名前空間NSの定義の中でも、一つめの名前空間NSの定義で宣言されたメンバー名である、xを使うことができる。



名前空間のメンバーは、スコープ解決演算子、::を使って、参照することもできる。



.. code-block:: c++
  
  namespace NS
  {
      using type = int ;
  }
  
  // 名前空間NSの、typeという名前を参照している。
  NS::type x ;


グローバル名前空間（Global namespace）
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



翻訳単位の、一番上の、namespaceで囲まれていない場所も、一種の名前空間として扱われる。これは、グローバル名前空間と呼ばれている。グローバル名前空間で定義された名前は、グローバル名前空間のスコープに入る。これは、グローバルスコープとも呼ばれている。グローバル名前空間のスコープは、翻訳単位の終わりまでである。



.. code-block:: c++
  
  // グローバル名前空間
  int x ;
  
  namespace NS
  {// 名前空間、NS
  
  }
  
  // ここは、グローバル名前空間
  
  namespace 
  {// 無名名前空間
  
  }
  
  // ここも、グローバル名前空間
  
  // xの範囲は、翻訳単位の終わりまで続く。






クラスのスコープ（Class scope）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



<p class="editorial-note">
TODO: rewrite.


クラスのスコープは、少し変わっている。ブロックスコープなどは、名前の有効な範囲は、名前を宣言した場所から、スコープの終わりまでである。



.. code-block:: c++
  
  void f()
  {
  // ここでは、xは使えない。
  
  int x ;// xを宣言
  
  // ここでは、xを使える。
  }


クラスでは、これが変わっている。



先に、名前が宣言されていなくても、クラス内の関数からは、その名前を使うことができる。



.. code-block:: c++
  
  class C
  {
      void f()
      {// 関数の中で、名前を使うことができる。
          type x ;
          value = 0 ;
      }
  
      type y ;    // エラー。typeは宣言されていない。
  
      using type = int ;  // typeの宣言場所
  
      type z ; // OK
  
      int value ;         // valueの宣言場所
  } ;


また、クラスのメンバー関数を、クラスの外部で定義する場合でも、その関数の中から、クラス内で宣言された名前を使うことができる。



.. code-block:: c++
  
  class C
  {
      void f() ;
      int x ;
  } ;
  
  void C::f()
  {// クラス外部で定義されたメンバー関数の中で、クラス内で宣言された名前を使える。
      x = 0 ;
  }


その他にも、クラス内の名前を、クラス外で使うことができる場合が存在する。



.. code-block:: c++
  
  class C
  {
  public :
      int x ;
      using type = int ;
  } ;
  
  int main()
  {
      C c ;
      C * p = &c ;
      // クラスのメンバーアクセス演算子の後に続けて、名前を使える。
      c.x = 0 ;
      p->x = 0 ;
  
      // スコープ解決演算子の後に続けて、名前を使える。
      C::type value ;
  }


このように、クラススコープの名前は、宣言した場所から、ある区間まで有効というルールではない。このため、クラスのスコープには特別なルールがある。



* クラスのメンバーの宣言が全てわかったあとに、クラス宣言を再評価して、プログラムの意味が変わるとエラー
* クラス内のメンバーの宣言の順番を変えた際に、プログラムの意味が変わると、エラー


これは、例をあげて説明したほうが分かりやすい。今仮に、このルールがないものとする。とすると、以下のようなコードが書けてしまう。



.. code-block:: c++
  
  // コード1
  using type = int ;// #1
  
  class C
  {
      type x ;// このtypeは、#1の::type
      using type = float ;// #2
  } ;


クラスCの宣言の順番を変えると、以下のコードになる。



.. code-block:: c++
  
  // コード2
  using type = int ;// #1
  
  class C
  {
      using type = float ;// #2
      type x ;// このtypeは、#2の、C::type
  } ;


このように、メンバーの宣言の順番を変えることによって、プログラムの意味が変わってしまうと、意図せぬバグを生む原因となる。そのため、このようなコードは、エラーである。






enumのスコープ（Enumeration scope）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



scoped enumは、enumスコープ（enumeration scope）を持つ。このスコープの範囲は、enumの宣言内だけである。



.. code-block:: c++
  
  enum class E { x, y, z } ;
  //ここで、x, y, zは使えない。
  x ; // エラー
  E::x ;// OK 


この理由は、scoped enumは、強い型付けを持つenumだからだ。詳しくは、<a href="#dcl.enum">enum</a>を参照のこと。




テンプレート仮引数のスコープ（Template Parameter Scope）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



テンプレート仮引数にも、スコープがある。テンプレート仮引数のスコープは、それほど意識する必要はない。



.. code-block:: c++
  
  template <
  typename T, // これ以降、Tを使える。
  typename U = T >
  class C { } ;// テンプレート仮引数のスコープ、ここまで


ただし、テンプレート仮引数名は、基本的に、隠すことができない。



.. code-block:: c++
  
  template < typename T >
  class C
  {
      using T = int ; // エラー
  
      // エラー
      template < typename T >
      void f() ;
  
  } ;


「基本的に」というのは、隠すことができる場合も存在するからだ。



.. code-block:: c++
  
  struct Base{ using T = type ; } ;
  
  template < typename T >
  struct Derived : Base
  {
      T x ;// Base::Tが使われる。テンプレート仮引数ではない。
  } ;


といっても、これはよほど特殊な例であり、通常は、テンプレート仮引数名は、隠せないと考えても、問題はない。




名前隠し（Name hiding）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



ネストされたスコープの内側で、同じ名前が宣言されると、外側の名前は、隠される。



.. code-block:: c++
  
  void f()
  {// 外側のスコープ
      int x ;
      {// 内側のスコープ
          int x ;// 外側のスコープのxを隠す。
          x = 0 ; // 内側のx
      }
      x = 0 ; // 外側のx
  }


派生クラスでは、基本クラスの名前は隠される。



.. code-block:: c++
  
  struct Base { using type = char ; } ;
  
  struct Derived
  {
      using type = int ;
  
      type x ; // int
  } ;


クラスやenumの名前は、変数やデータメンバーの名前によって、隠される。



.. code-block:: c++
  
  class ClassName {} ;
  
  void f()
  {
      ClassName ClassName ; // OK、ClassName型の変数、ClassName
  
      ClassName x ; // エラー、ClassNameは、ここでは変数名を指す。
  
      class ClassName x ; // OK、明示的にクラス名であると指定している。
  }


このように、クラス名と変数名を同じにするのは、非常に分かりにくい問題を引き起こすので、あまりおすすめできない。




名前探索（Name lookup）
--------------------------------------------------------------------------------



あるスコープにおいて、ある名前が使われているとき、その名前が何を意味するのかということを決定するのを、名前探索（Name lookup）と呼ぶ。これは一見簡単そうに思える。しかし、この名前を決定するというルールは、非常に難しい。



Name lookupには、大きく分けて、三種類ある。Qualified name lookup、Unqualified name lookup、Argument-dependent name lookupだ。



Qualified 名前探索（Qualified name lookup）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Qualified nameとは、qualified（修飾）という名前通り、スコープ解決演算子（::）を使った名前のことである。



.. code-block:: c++
  
  int g ;
  
  namespace NS { int x ; }
  
  struct C { static int x ;} ;
  int C::x ;
  
  enum struct E { e } ;
  
  int main()
  {
      // これらはQualified name lookup
      NS::x ; // NSという名前空間のx
      C::x ;  // Cというクラスのx
      E::e ; // Eというenumのメンバー、e
      ::g ;   // グローバル名前空間のg
      
  }


このような名前に対する名前探索を、Qualified name lookupという。



スコープ解決演算子（::）の左側には、クラス名か、名前空間名か、enum名を書くことができる。左側に何も書かない場合、グローバル名前空間が使われる。Qualified name lookupでは、名前は、スコープ解決演算子で指定された、クラスや名前空間、enum内の名前から、探索される。




スコープ解決演算子は、ネストできる。



.. code-block:: c++
  
  namespace N1 { namespace N2 {
      int x ;
  } }
  
  N1::N2::x ;




Unqualified 名前探索（Unqualified name lookup）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Unqualified（非修飾） name lookupは、Qualified name lookup以外を指す。これはつまり、スコープ解決演算子を使わない名前に対する、名前探索である。



.. code-block:: c++
  
  int g ;
  
  namespace NS { int x ; }
  
  int main()
  {
      g ;// グローバル変数のg
  
      int g ;
      g ;// ローカル変数のg
  
      {
          using namespace NS ;
          x ; // NS::xと同じ
      }
  
      {
          using NS::x ;
          x ; // NS::xと同じ
      }
  }


Unqualified nameに対する名前探索を、Unqualified name lookupという。Unqualified name lookupでは、その名前が使われている場所で、明示的に修飾しなくても、見つかる名前が探される。これは、例えばグローバル名前空間内の名前であったり、クラス内であれば、クラスのメンバーであったりする。また、using directiveや、using declarationの影響をうける。




ADL（Argument-dependent name lookup）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



Unqualified nameに対して、関数呼び出しをする場合、特別なルールがある。このルールを、ADL(Argument-dependent name lookup)という。



.. code-block:: c++
  
  namespace NS
  {
      class C {} ;
      void f( C ) {}
  }
  
  int main()
  {
      NS::C c ;
      f(c) ;// NS::fを呼ぶ
  }


このコードでは、通常は見つからないはずの、NSという名前空間内の関数であるfが、Unqualified nameなのにもかかわらず、見つかる。これを、実引数に依存する名前探索（Argument-dependent name lookup）と呼ぶ。しばしば、ADLと略される。また、Andrew Koenigさんが、名前空間の導入によって、特に演算子のオーバーロードで、ADLのような必要性を意見したため、koenig lookupとも呼ばれることがある。Andrew Koenigさんが、ADLの具体的な仕組みを考案したわけではない。誰がADLの原案を考えだしたのかは、歴史に埋もれて忘れ去られているが、そのような歴史的な経緯と誤解により、Koenig lookupと呼ばれている。



このADLというルールは、一見すると、非常に奇妙なルールである。このような仕組みは、非常に厄介な問題を引き起こすのではないか。事実、ADLは時として、問題になることがある。それでもADLが存在するのは、利点があるからだ。



整数を表現するクラス、Integerを考える。名前の衝突を防ぐため、このクラスは、libという名前空間の中に入れたい。また、整数として分かりやすく使うために、演算子をオーバーロードしたい。Integerクラスは、以下のように使えるものとする。



.. code-block:: c++
  
  int main()
  {
      lib::Integer x ;
      // 演算子のオーバーロードによる、分かりやすい加算のコード。
      x + x ;
  }


さっそく、このIntegerを実装してみよう。



.. code-block:: c++
  
  namespace lib
  {
      // クラス
      class Integer {/*実装*/} ;
      // 演算子のオーバーロード
      Integer operator + ( Integer const &, Integer const &)
      {
          // 実装
          return Integer() ;
      }
  }


もしここで、ADLがない場合、operator +()の呼び出しが、困ったことになる。なぜなら、Unqualified lookupでは、lib名前空間の中の名前を探してはくれない。つまり、operator +は、見つからないのである。



.. code-block:: c++
  
  lib::Integer x ;
  // エラー、operator + が見つからない。
  x + x ;


ではどうするか。これは、Qualified lookupを使うしかない。



.. code-block:: c++
  
  lib::operator +( x, x ) ;


このコードは動く。確かに動くが、これでは、せっかく演算子をオーバーロードした意味がない。そもそも、演算子をオーバーロードする理由とは、x + x という、分かりやすい使い慣れたコードを書くためだからだ。



このため、Unqualified nameに対する、関数呼び出しには、Unqualified name lookupに加えて、ADLという仕組みで、名前が探索されるようになっている。



関連クラスと関連名前空間
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



ADLは、その名前が示すとおり、「実引数に依存する名前解決」である。どの名前空間から、名前を探すかということは、実引数の型から決定される。また、ADLは、必ず行われるわけではない。ADLが適用される条件というものが存在する。



ADLはどのように行われるか。まず、関数に対する、関連クラス（Associated class）と、関連名前空間（Associated namespace）というものが決定される。ADLは、この関連名前空間の中から、名前を探索する。



関連クラスとは、関数に実引数として渡される型である。関連名前空間とは、関連クラスがメンバーとなっている名前空間である。



.. code-block:: c++
  
  namespace NS
  {
      class A {} ; class B {} ; class C {} ; class D {} ;
      void f( A, B, C, D ) {}
  }
  
  int main()
  {
      NS::A a ; NS::B b ; NS::C c ; NS::D d ;
      f( a, b, c, d ) ;
  }


この場合、fの関数呼び出しに対する関連クラスは、A、B、C、Dで、関連名前空間は、NSとなる。



.. code-block:: c++
  
  namespace A { class C {} ; }
  namespace B
  {
      class C {} ;
      void f( A::C, B::C ) {}
  }
  
  int main()
  {
      A::C ac ; B::C bc ;
      f( ac, bc ) ;
  }


この場合、fの関数呼び出しに対する関連クラスは、A::C、B::Cで、関連名前空間は、A、Bとなる。



実引数の型のクラスの、基本クラスも、関連クラスになる。



.. code-block:: c++
  
  namespace NS
  {
      class A {} ;
      class B : A {} ;
      class C : B {} ;
  
      void f( C ) {}
  }
  
  int main()
  {
      NS::C c ;
      f( c ) ;
  }


この場合、関数NS::fに対する関連クラスは、A、B、Cで、関連名前空間は、NSとなる。



実引数がクラステンプレートであった場合、そのクラスのテンプレート実引数も、関連クラスになる。



.. code-block:: c++
  
  namespace NS
  {
      template < typename T > class C {} ;
  }
  
  namespace lib
  {
      class type {} ;
  
      template < typename T >
      void f( NS::C<T> ) {}
  }
  
  int main()
  {
      NS::C< lib::type > c ;
  
      // 関連クラスは、NS::C< lib::type >と、lib::type。
      // 関連名前空間は、NSと、lib。
      f(c) ; // lib::fを呼び出す。
  }


テンプレート実引数も関連クラスになるというルールは、この例のような、非常に分かりにくいコードのコンパイルを通してしまう。



実引数がクラス以外の場合も、ADLは適用される。



実引数がenumの場合、そのenumが定義されている名前空間が、関連名前空間になる。



.. code-block:: c++
  
  namespace NS
  {
      enum struct E { value } ;
      void f( E ) {}
  }
  
  int main()
  {
      f( NS::E::value ) ; // NS::fを呼び出す。
  }


この場合、関数、NS::fの関連名前空間は、NSとなる。




ADLが適用される条件
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



ADLが適用されるには、条件を満たさなければならない。まず、ADLは、Unqualified nameへの関数呼び出しにしか、適用されない。変数としての使用には、ADLは使われない。



.. code-block:: c++
  
  namespace NS
  {
      class C {} ;
  
      void f( C ) {}
      void g( C ) {}
  }
  
  void g( NS::C ) {}
  
  int main()
  {
      NS::C c ;
      
  
      f(c) ;      // ADLで、NS::fを呼ぶ
      NS::f(c) ;  // Qualified name lookupが行われる
  
      ::g(c) ;    // Qualified name lookupが行われる
      NS::g(c) ;  // Qualified name lookupが行われる
      
      
      g(c) ;      // エラー。::g、NS::gのどちらの名前か、曖昧。
  }


最後の例は、Unqualified name lookupで、::gが発見され、ADLで、NS::gが発見されるので、どちらの名前を使うのか、曖昧で、エラーになる。



もし、Unqualified name lookupで、関数名以外の名前が見つかった場合、ADLは行われない。



.. code-block:: c++
  
  namespace NS
  {
      class C {} ;
      void f( C ) {}
  }
  
  int f ;
  
  struct Caller
  {
      void f( NS::C ) {}
  
      void g()
      {
          NS::C c ;
          f(c) ;// Caller::fが呼ばれる。ADLは行われない。
      }
  } ;
  
  int main()
  {
      NS::C c ;
  
      f(c) ; // エラー。fはint型の変数
  }


ブロックスコープ関数宣言の名前が見つかった場合、ADLは行われない。ただし、using宣言や、usingディレクティブは、影響しない。



.. code-block:: c++
  
  namespace NS
  {
  class C {} ;
  
  void f( C ) {}
  }
  
  namespace lib { void f( NS::C ) {} }
  
  int main()
  {
      NS::C c ;
  
      {
          void f( NS::C ) ;// ブロックスコープの関数宣言
          f(c) ;// ::fを呼び出す。ブロックスコープの宣言が見つかったので、ADLは行われない。
      }
  
      {
          using namespace lib ;
          f(c) ; // エラー、ADLも行われるので、曖昧になる。
      }
  
      {
          using lib::f ;
          f(c) ; // エラー、ADLも行われるので、曖昧になる。
      }
  }
  
  // ブロックスコープの関数宣言で参照される、グローバル名前空間のf
  void f( NS::C ) {}


ブロックスコープ内で関数宣言をするということは、言語上は認められているが、現実的には、あまり用いられていない。



using宣言や、usingディレクティブが、ADLの適用を妨げないということは、注意を要する。これにより、不思議なコンパイルエラーになることがある。例えば、上の例の場合、NS名前空間のコードは、他人が書いたものであり、ユーザーはよく知らないとしよう。lib名前空間のコードは、ユーザーが書いたものである。ユーザーは、lib::fを使いたい。main関数内で多用するので、using宣言を使って、簡単に呼び出せるようにした。ところが、NS名前空間の中にも、同名の関数があるので、曖昧エラーになってしまう。



ADLが意図せず適用された際のエラーは、非常に分かりにくい。そのため、ADLを防ぐための方法が用意されている。名前を括弧で囲めば、ADLの適用が阻害される。



.. code-block:: c++
  
  namespace NS
  {
  class C {} ;
  void f( C ) {}
  }
  
  void f( NS::C ) {}
  
  int main()
  {
      NS::C c ;
  
      f(c) ; // エラー。曖昧
  
      (f)(c) ; // OK、ADLは適用されない。::fを呼び出す。
  }


unqualified nameへの関数呼び出しは、通常のunqualified name lookupと、ADLとで見つかった名前の、両方が用いられる。






プログラムとリンケージ（Program and linkage）
--------------------------------------------------------------------------------



TODO: これはそれほど詳しく説明する必要はないかも。


プログラムの開始と終了（Start and termination）
--------------------------------------------------------------------------------



main関数（Main function）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





非ローカル変数の初期化（Initialization of non-local objects）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





終了（Termination）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





