
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>式（Expressions） &mdash; C++11: Syntax and Feature</title>
    
    <link rel="stylesheet" href="_static/cpp-book.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="C++11: Syntax and Feature" href="index.html" />
    <link rel="next" title="文（Statements）" href="stmt.stmt.html" />
    <link rel="prev" title="標準型変換（Standard conversions）" href="conv.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="stmt.stmt.html" title="文（Statements）"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="conv.html" title="標準型変換（Standard conversions）"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="expressions">
<h1>式（Expressions）<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>優先順位と評価順序<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>TODO: 式の優先順位の評価順序の表は必要か。詳しく分かったところで何か実用上の意味はあるのか。</p>
<p>式には、優先順位と評価順序がある。</p>
<p>優先順位とは、ある式の中で、異なる式が複数使われた場合、どちらが先に評価されるのかという順位である。この優先順位は、人間にとって自然になるように設計されているので、通常、式の優先順位を気にする必要はない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 1 + (2 * 3)</span>
<span class="c1">// operator *が優先される</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">;</span>

<span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="c1">// operator +が優先される</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
</pre></div>
</div>
<p>評価順序とは、ある式の中で、優先順位の同じ式が複数使われた場合、どちらを先に評価するかという順序である。これは、式ごとに、「左から右（Left-To-Right）」、あるいは「右から左（Right-To-Left）」のどちらかになる。</p>
<p>たとえば、operator +は、「左から右」である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// (1 + 1) + 1 と同じ</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
</pre></div>
</div>
<p>一方、operator = は、「右から左」である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
<span class="c1">// x = (y = 0) と同じ</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
</pre></div>
</div>
<p>これも、人間にとって自然になるように設計されている。通常、気にする必要はない。</p>
</div>
<div class="section" id="unevaluated-operand">
<h2>未評価オペランド（unevaluated_operand）<a class="headerlink" href="#unevaluated-operand" title="Permalink to this headline">¶</a></h2>
<p>&lt;a href=&#8221;#expr.typeid&#8221;&gt;typeid演算子&lt;/a&gt;、&lt;a href=&#8221;#expr.sizeof&#8221;&gt;sizeof演算子&lt;/a&gt;、&lt;a href=&#8221;#expr.unary.noexcept&#8221;&gt;noexcept演算子&lt;/a&gt;、&lt;a href=&#8221;#dcl.type.simple&#8221;&gt;decltype型指定子&lt;/a&gt;では、あるいは未評価オペランド（unevaluated_operand）というものが使われる。このオペランドは文字通り、評価されない式である。</p>
<p>オペランドの式は評価されないが、式を評価した結果の型は、通常の評価される式と何ら変わりない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// int x ; と同等</span>
    <span class="c1">// 関数fは呼ばれない</span>
    <span class="n">decltype</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、オペランドの式の結果の型を、変数xとして宣言、定義している。関数呼び出しの結果の型は、関数の戻り値の型になるので、型はintである。ただし、式自体は評価されないので、実行時に関数が呼ばれることはない。つまり、標準出力にhelloと出力されることはない。</p>
<p>この未評価式は、評価されないということを除けば、通常の式と全く同じように扱われる。例えば、オーバーロード解決やテンプレートのインスタンス化なども、通常の式と同じように働く。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 関数の宣言だけでいい。定義は必要ない</span>
<span class="kt">double</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// double x ; と同等</span>
    <span class="n">decltype</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="n">x</span> <span class="p">;</span>
    <span class="c1">// int y ; と同等</span>
    <span class="n">decltype</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">)</span> <span class="n">y</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、関数fは、宣言だけされていて、定義がない。しかし、これは全く問題がない。なぜならば、未評価式は評価されないので、関数fが呼ばれることはない。呼ばれることがなければ、定義も必要はない。</p>
</div>
<div class="section" id="primary-expressions">
<h2>一次式（Primary expressions）<a class="headerlink" href="#primary-expressions" title="Permalink to this headline">¶</a></h2>
<p>一次式には、多くの細かな種類がある。例えば、リテラルや名前も一次式である。ここでは、一次式の中でも、特に重要なものを説明する。</p>
<div class="section" id="id2">
<h3>:: 演算子<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>:: 演算子は、ある名前のスコープを指定する演算子である。このため、非公式に「スコープ解決演算子」とも呼ばれている。しかし、公式の名前は、:: 演算子(operator ::)である。::に続く名前のスコープは、::の前に指定されたスコープになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// スコープはグローバル</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// スコープはNS名前空間</span>
<span class="k">namespace</span> <span class="n">NS</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// スコープはCクラス</span>
<span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">C</span><span class="o">::</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span><span class="c1">// スコープはmain()関数のブロック</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="n">x</span> <span class="p">;</span> <span class="c1">// ブロック</span>

    <span class="o">::</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// グローバル</span>
    <span class="n">NS</span><span class="o">::</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// NS名前空間</span>
    <span class="n">C</span><span class="o">::</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// クラス</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、::に続く名前のスコープを指定することができる。スコープが省略された場合は、グローバルスコープになる。</p>
<p>式の結果は、::に続く名前が、関数か変数の場合はlvalueに、それ以外はprvalueになる。</p>
</div>
<div class="section" id="parenthesized-expression">
<h3>括弧式（parenthesized expression）<a class="headerlink" href="#parenthesized-expression" title="Permalink to this headline">¶</a></h3>
<p>括弧式とは、括弧である。これは、式を囲むことができる。括弧式の結果は、括弧の中の式とまったく同じになる。これは主に、ひとつの式の中で、評価する順序を指定するような場合に用いられる。あるいは、単にコードを分かりやすく、強調するために使っても構わない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 括弧式</span>

<span class="c1">// 1 + (2 * 3) = 1 + 6 = 7</span>
<span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">;</span>
<span class="c1">// 3 * 3 = 9</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>
</pre></div>
</div>
<p>ほとんどの場合、括弧式の有無は、括弧の中の式の結果に影響を与えない。ただし、括弧式の有無によって意味が変わる場合もある。例えば、decltype指定子だ。</p>
</div>
</div>
<div class="section" id="lambda-expressions">
<h2>ラムダ式（Lambda expressions）<a class="headerlink" href="#lambda-expressions" title="Permalink to this headline">¶</a></h2>
<p>ラムダ式（lambda expression）は、関数オブジェクトを簡単に記述するための式である。以下のような文法になる</p>
<div class="highlight-c++"><pre>[ ラムダキャプチ</pre>
</div>
<div class="section" id="id3">
<h3>ラムダ式の基本的な使い方<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>ラムダ式を、通常の関数のように使う方法を説明する。まず、ラムダ式の構造は、以下のようになっている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">[</span><span class="cm">/*ラムダキャプチャー*/</span><span class="p">]</span> <span class="c1">// ラムダ導入子</span>
<span class="p">(</span><span class="cm">/*仮引数リスト*/</span><span class="p">)</span> <span class="c1">// 省略可能</span>
<span class="o">-&gt;</span> <span class="kt">void</span> <span class="c1">// 戻り値の型、省略可能</span>
<span class="p">{}</span> <span class="c1">// 複合文</span>
</pre></div>
</div>
<p>これを、通常の関数定義と比較してみる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">auto</span> <span class="c1">// 関数宣言</span>
<span class="n">func</span> <span class="c1">// 関数名</span>
<span class="p">()</span> <span class="c1">// 引数リスト</span>
<span class="o">-&gt;</span> <span class="kt">void</span> <span class="c1">// 戻り値の型</span>
<span class="p">{}</span> <span class="c1">// 関数の定義</span>
</pre></div>
</div>
<p>ラムダ式は、関数オブジェクトである。通常の関数のように、引数もあれば、戻り値もある。もちろん、通常の関数のように、何も引数に取らないこともできるし、戻り値を返さないこともできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 通常の関数</span>
<span class="k">auto</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{}</span>
<span class="c1">// ラムダ式</span>
<span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダ式を評価した結果は、prvalueの一時オブジェクトになる。この一時オブジェクトを、クロージャーオブジェクト（closure object）と呼ぶ。クロージャーオブジェクトの型は、クロージャー型（closure type）である。クロージャー型はユニークで、名前がない。これは実装依存の型であり、ユーザーは具体的な型を知ることができない。このクロージャーオブジェクトは、関数オブジェクトと同じように振舞う。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span><span class="kt">void</span> <span class="p">{}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダ式は関数オブジェクトなので、通常の関数と同じように、operator ()を適用することで呼び出すことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 通常の関数</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 関数の呼び出し</span>

    <span class="c1">// ラムダ式</span>
    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{}</span> <span class="p">;</span>
    <span class="n">g</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// ラムダ式の呼び出し</span>

    <span class="c1">// ラムダ式を直接呼び出す</span>
    <span class="p">[]()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">{}()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>仮引数リストと、戻り値の型は、省略できる。従って、最小のラムダ式は、以下の通りになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">[]{}</span>
</pre></div>
</div>
<p>仮引数リストを省略した場合は、引数を取らないということを意味する。戻り値の型を省略した場合は、ラムダ式の複合文の内容によって、戻り値の型が推測される。複合文が以下の形になっている場合、</p>
<div class="highlight-c++"><pre>{ return 式 ; }</pre>
</div>
<p>戻り値の型は、式に lvalueからrvalueへの型変換、 配列からポインターへの型変換、関数からポインターへの型変換を適用した結果の型になる。</p>
<p>それ以外の場合は、void型になる。</p>
<p>注意しなければならないことは、戻り値の型を推測させるためには、複合文は必ず、{ return 式 ; }の形でなければならない。つまり、return文ひとつでなければならないということだ。return文以外に、複数の文がある場合、戻り値の型はvoidである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー、戻り値の型はvoidだが、値を返している</span>
<span class="p">[]</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}()</span> <span class="p">;</span>


<span class="c1">// OK、戻り値の型を、明示的に指定している。</span>
<span class="p">[]</span> <span class="o">-&gt;</span> <span class="kt">int</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}()</span> <span class="p">;</span>
</pre></div>
</div>
<p>いくつか例を挙げる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 戻り値の型はint</span>
<span class="k">auto</span> <span class="n">type1</span> <span class="o">=</span> <span class="p">[]{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}()</span> <span class="p">;</span>

<span class="c1">// 戻り値の型はdouble</span>
<span class="k">auto</span> <span class="n">type2</span> <span class="o">=</span> <span class="p">[]{</span> <span class="k">return</span> <span class="mf">0.0</span> <span class="p">;</span> <span class="p">}()</span> <span class="p">;</span>

<span class="c1">// 戻り値の型はvoid</span>
<span class="p">[]{</span> <span class="p">}()</span> <span class="p">;</span>
<span class="p">[]</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
<span class="p">}()</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダ式の引数は、通常の関数と同じように記述できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="p">;</span> <span class="p">}</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">123</span><span class="p">,</span> <span class="mf">3.14f</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>複合文は、通常の関数の本体と同じように扱われる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 通常の関数と同じように文を書ける</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span>
        <span class="p">[]</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
            <span class="o">++</span><span class="n">x</span> <span class="p">;</span>
        <span class="p">}</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span>

    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="p">{</span><span class="c1">// もちろん、複数の文を書ける</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
        <span class="o">++</span><span class="n">x</span> <span class="p">;</span> <span class="o">++</span><span class="n">x</span> <span class="p">;</span> <span class="o">++</span><span class="n">x</span> <span class="p">;</span>
    <span class="p">}</span> <span class="p">;</span>

    <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>クロージャーオブジェクトは、変数として保持できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;functional&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// auto指定子を使う方法</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]{}</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span>

    <span class="c1">// std::functionを使う方法</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">void</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[]{}</span> <span class="p">;</span>
    <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ラムダ式は、テンプレート引数にも渡せる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Func</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Func</span> <span class="n">func</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">func</span><span class="p">()</span> <span class="p">;</span><span class="c1">// 関数オブジェクトを呼び出す</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">[]{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;hello&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ラムダ式の使い方の例を示す。例えば、std::vectorの全要素を、標準出力に出力したいとする。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="k">struct</span> <span class="n">Print</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">Print</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、本質的にはたった一行のコードを書くのに、わざわざ関数オブジェクトを、どこか別の場所に定義しなければならない。ラムダ式を使えば、その場に書くことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;algorithm&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[](</span><span class="kt">int</span> <span class="n">value</span><span class="p">){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id4">
<h4>変数のキャプチャー<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>関数内に関数を書くことができるのは、確かに手軽で便利だ。しかし、ラムダ式は、単にその場に関数を書くだけでは終わらない。ラムダ式は、関数のローカル変数をキャプチャーできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Func</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">call</span> <span class="p">(</span> <span class="n">Func</span> <span class="n">func</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">func</span><span class="p">()</span> <span class="p">;</span><span class="c1">// helloと表示する</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span> <span class="p">;</span>
    <span class="c1">// main関数のローカル変数strを、ラムダ式の中で使う</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
    <span class="c1">// もちろん、他の関数に渡せる。</span>
    <span class="n">call</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、ラムダ式が定義されている関数のブロックスコープの中のローカル変数を、使うことができる。この機能を、変数のキャプチャーという。</p>
<p>この、ラムダ式で、定義されている場所のローカル変数を使えるというのは、一見、奇妙に思えるかもしれない。しかし実のところ、これは単なるシンタックスシュガーにすぎない。同じことは、従来の関数オブジェクトでも行える。詳しくは後述する。</p>
<p>もちろん、クロージャーオブジェクトがどのように実装されるかは、実装により異なる。しかし基本的に、ラムダ式は、このような関数オブジェクトへの、シンタックスシュガーに過ぎない。</p>
<p>[]の中身を、ラムダキャプチャーという。ラムダキャプチャーの中には、キャプチャーリストを記述できる。変数のキャプチャーをするには、キャプチャーリストに、どのようにキャプチャーをするかを指定しなければならない。変数のキャプチャーには、二種類ある。コピーでキャプチャーするか、リファレンスでキャプチャーするかの違いである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// コピーキャプチャー</span>
    <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="p">{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span>
    <span class="c1">// リファレンスキャプチャー</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>キャプチャーリストに=を記述すると、コピーキャプチャーになる。&amp;amp;を記述すると、リファレンスキャプチャーになる。</p>
<p>コピーキャプチャーの場合、変数はクロージャーオブジェクトのデータメンバーとして、コピーされる。リファレンスキャプチャーの場合は、クロージャーオブジェクトに、変数への参照が保持される。</p>
<p>コピーキャプチャーの場合は、ラムダ式から、その変数を書き換えることができない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="p">[</span><span class="o">=</span><span class="p">]</span>
    <span class="p">{</span><span class="c1">// コピーキャプチャー</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// OK、読むことはできる</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// エラー、書き換えることはできない</span>
    <span class="p">}</span> <span class="p">;</span>

    <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span>
    <span class="p">{</span><span class="c1">// リファレンスキャプチャー</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// OK</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは、クロージャーオブジェクトのoperator()が、const指定されているためである。ラムダ式にmutableが指定されていた場合、operator()は、const指定されないので、書き換えることができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="p">[</span><span class="o">=</span><span class="p">]()</span> <span class="k">mutable</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// OK</span>
        <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>リファレンスキャプチャーの場合は、変数の寿命に気をつけなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;functional&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">void</span> <span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">void</span> <span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="n">g</span> <span class="p">;</span>


    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// リファレンスキャプチャー</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// コピーキャプチャー</span>
    <span class="p">}</span>

    <span class="n">f</span><span class="p">()</span> <span class="p">;</span><span class="c1">// エラー、xの寿命は、すでに尽きている。</span>

    <span class="n">g</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ローカル変数の寿命は、そのブロックスコープ内である。この例で、fを呼び出すときには、すでに、xの寿命は尽きているので、エラーになる。</p>
<p>ラムダ式がキャプチャーできるのは、ラムダ式が記述されている関数の、最も外側のブロックスコープ内である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span><span class="c1">// 関数の最も外側のブロックスコープ</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>

        <span class="c1">// xもyもキャプチャーできる。</span>
        <span class="p">[</span><span class="o">=</span><span class="p">]{</span> <span class="n">x</span> <span class="p">;</span> <span class="n">y</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数の最も外側のブロックスコープ以外のスコープ、例えばグローバル変数などは、キャプチャーせずにアクセス出来る。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// グローバルスコープの変数</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// キャプチャーする必要はない</span>
    <span class="p">[]{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>変数ごとに、キャプチャー方法を指定できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="p">[</span> <span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span> <span class="p">]{}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>変数のキャプチャー方法を、それぞれ指定する場合、キャプチャーリストの中に、変数名を記述する。その時、単に変数名だけを記述した場合、コピーキャプチャーになり、変数名の前に&amp;amp;をつけた場合、リファレンスキャプチャーになる。</p>
<p>キャプチャーしたい変数がたくさんある場合、いちいち名前をすべて記述するのは面倒であるので、デフォルトのキャプチャー方法を指定できる。これをデフォルトキャプチャー（default capture）という。この時、デフォルトキャプチャーに続けて、個々の変数名のキャプチャー方法を指定できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// デフォルトはコピーキャプチャー</span>
    <span class="p">[</span><span class="o">=</span><span class="p">]{</span> <span class="n">a</span> <span class="p">;</span> <span class="n">b</span> <span class="p">;</span> <span class="n">c</span> <span class="p">;</span> <span class="n">d</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="c1">// デフォルトはリファレンスキャプチャー</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span> <span class="n">a</span> <span class="p">;</span> <span class="n">b</span> <span class="p">;</span> <span class="n">c</span> <span class="p">;</span> <span class="n">d</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

    <span class="c1">// aのみリファレンスキャプチャー</span>
    <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">]{}</span> <span class="p">;</span>

    <span class="c1">// aのみコピーキャプチャー</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">a</span><span class="p">]{}</span> <span class="p">;</span>

    <span class="c1">// a, bのみリファレンスキャプチャー</span>
    <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">]{}</span> <span class="p">;</span>

    <span class="c1">// デフォルトキャプチャーを使わない</span>
    <span class="p">[</span><span class="n">a</span><span class="p">]{}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このとき、デフォルトキャプチャーと同じキャプチャー方法を、個々のキャプチャーで指定することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// エラー、デフォルトキャプチャーと同じ</span>
    <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="n">a</span><span class="p">]{}</span> <span class="p">;</span>
    <span class="c1">// OK</span>
    <span class="p">[</span><span class="o">=</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">]{}</span> <span class="p">;</span>

    <span class="c1">// エラー、デフォルトキャプチャーと同じ</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">]{}</span> <span class="p">;</span>
    <span class="c1">// OK</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">a</span><span class="p">]{}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>キャプチャーリスト内で、同じ名前を複数書くことはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="c1">// エラー</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]{}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>たとえ、キャプチャー方法が同じであったとしても、エラーになる。</p>
<p>デフォルトキャプチャーが指定されているラムダ式の関数の本体で、キャプチャーできる変数を使った場合、その変数は、暗黙的にキャプチャーされる。</p>
<p>変数のキャプチャーの具体的な使用例を示す。今、vectorの各要素の合計を求めるプログラムを書くとする。関数オブジェクトで実装をすると、以下のようになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Sum</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="p">;</span>
    <span class="n">Sum</span><span class="p">()</span> <span class="o">:</span> <span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">()(</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">)</span>
    <span class="p">{</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span> <span class="p">;</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span> <span class="p">;</span>
    <span class="n">Sum</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">Sum</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">.</span><span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは、明らかに分かりにくい。sum += valueという短いコードのために、関数オブジェクトを定義しなければならないし、その取扱も面倒である。このため、多くのプログラマは、STLのアルゴリズムを使うより、自前のループを書きたがる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span> <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">;</span> <span class="n">iter</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">;</span> <span class="o">++</span><span class="n">iter</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="o">*</span><span class="n">iter</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>しかし、ループを手書きするのは分かりにくいし、間違いの元である。ラムダ式のキャプチャーは、この問題を解決してくれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">){</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">value</span> <span class="p">;</span> <span class="p">}</span>
    <span class="p">)</span> <span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これで、コードは分かりやすくなる。また、ループを手書きしないので、間違いも減る。</p>
</div>
</div>
<div class="section" id="id5">
<h3>ラムダ式の詳細<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<div class="section" id="closure-object">
<h4>クロージャーオブジェクト（closure object）<a class="headerlink" href="#closure-object" title="Permalink to this headline">¶</a></h4>
<p>ラムダ式が評価された結果は、クロージャーオブジェクト（closure object）になる。これは、一種の関数オブジェクトで、その型は、ユニークで無名な実装依存のクラスであるとされている。この型は、非常に限定的にしか使えない。例えば、ラムダ式は、未評価式の中で使うことが出来ない。これは、decltypeやsizeofの中で使うことが出来ないということを意味する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">decltype</span><span class="p">([]{})</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="k">sizeof</span><span class="p">([]{})</span> <span class="p">;</span> <span class="c1">// エラー</span>

<span class="c1">// OK</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]{}</span> <span class="p">;</span>
</pre></div>
</div>
<p>クロージャーオブジェクトがどのように実装されるかは、実装依存である。しかし、今、説明のために、実装の一例を示す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">](){</span> <span class="n">a</span> <span class="p">;</span> <span class="n">b</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例えば、このようなコードがあったとすると、例えば、以下のように実装できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Closure</span> <span class="c1">// 本来、ユーザー側から使える名前は存在しない</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="c1">// aはコピーキャプチャー、bはリファレンスキャプチャー</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="p">;</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="p">;</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="n">Closure</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">b</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// コピーコンストラクターが暗黙的に定義される</span>
    <span class="n">Closure</span><span class="p">(</span> <span class="n">Closure</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span> <span class="p">;</span>
    <span class="c1">// ムーブコンストラクターが暗黙的に定義される可能性がある</span>
    <span class="n">Closure</span><span class="p">(</span> <span class="n">Closure</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span> <span class="p">;</span>

    <span class="c1">// デフォルトコンストラクターはdelete定義される</span>
    <span class="n">Closure</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>
    <span class="c1">// コピー代入演算子はdelete定義される</span>
    <span class="n">Closure</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">Closure</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>



    <span class="kr">inline</span> <span class="kt">void</span> <span class="k">operator</span> <span class="p">()</span> <span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span> <span class="n">a</span> <span class="p">;</span> <span class="n">b</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Closure</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>クロージャーオブジェクトは、メンバー関数として、operator ()を持つ。これにより、関数呼び出しの演算子で、関数のように呼び出すことができる。キャプチャーした変数は、データメンバーとして持つ。このoperator ()は、inlineである。また、mutable指定されていない場合、const指定されている。これにより、コピーキャプチャーした変数は、書き換えることができない。mutableが指定されている場合、constではなくなるので、書き換えることができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="c1">// エラー</span>
    <span class="p">[</span><span class="n">x</span><span class="p">]()</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="c1">// OK</span>
    <span class="p">[</span><span class="n">x</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ラムダ式の仮引数リストには、デフォルト引数を指定できない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー</span>
<span class="p">[](</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">){}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダ式は、例外指定できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">[]()</span> <span class="n">noexcept</span> <span class="p">{}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダ式に例外指定をすると、クロージャーオブジェクトのoperator ()に、同じ例外指定がなされたものと解釈される。</p>
<p>クロージャーオブジェクトには、コピーコンストラクターが暗黙的に定義される。ムーブコンストラクターは、可能な場合、暗黙的に定義される。デフォルトコンストラクターと、コピー代入演算子は、delete定義される。これはつまり、初期化はできるが、コピー代入はできないということを意味する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 初期化はできる。</span>
<span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[]{}</span> <span class="p">;</span>

<span class="c1">// OK fはラムダ式ではないので可能</span>
<span class="k">using</span> <span class="n">closure_type</span> <span class="nf">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">;</span>
<span class="c1">// OK 初期化はできる</span>
<span class="n">closure_type</span> <span class="n">g</span> <span class="o">=</span> <span class="n">f</span> <span class="p">;</span>

<span class="c1">// エラー、デフォルトコンストラクターは存在しない</span>
<span class="n">closure_type</span> <span class="n">h</span> <span class="p">;</span>
<span class="c1">// エラー、コピー代入演算子は存在しない。</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">f</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h4>関数ポインターへの変換<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h4>
<p>ラムダキャプチャーを使わないラムダ式のクロージャーオブジェクトは、同一の引数と戻り値の関数ポインターへの変換関数を持つ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr1</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="p">[]{}</span> <span class="p">;</span>
<span class="k">auto</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr2</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span> <span class="p">;</span> <span class="p">}</span>

<span class="c1">// 呼び出す。</span>
<span class="n">ptr1</span><span class="p">()</span> <span class="p">;</span> <span class="n">ptr2</span><span class="p">()</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダキャプチャーを使っているクロージャーオブジェクトは、関数ポインターに変換できない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="c1">// エラー、変換できない</span>
    <span class="k">auto</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr1</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="o">=</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="k">auto</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr2</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>変数をキャプチャーしないラムダ式というのは、関数オブジェクトではなく、単なる関数に置き換えることができるので、このような機能が提供されている。この機能は、まだテンプレートを使っていない既存のコードやライブラリとの相互利用のために用意されている。</p>
</div>
<div class="section" id="id7">
<h4>ラムダ式のネスト<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>ラムダ式はネストできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">[]{</span><span class="c1">// 外側のラムダ式</span>
    <span class="p">[]{}</span> <span class="p">;</span><span class="c1">// 内側のラムダ式</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この時、問題になるのは、変数のキャプチャーだ。内側のラムダ式は、外側のラムダ式のブロックスコープから見える変数しか、キャプチャーすることはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="p">[</span><span class="n">b</span><span class="p">]{</span><span class="c1">// 外側のラムダ式</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
        <span class="p">[</span><span class="o">=</span><span class="p">]{</span><span class="c1">// 内側のラムダ式</span>
            <span class="n">a</span> <span class="p">;</span> <span class="c1">// エラー、aはキャプチャーできない。</span>
            <span class="n">b</span> <span class="p">;</span> <span class="c1">// OK</span>
            <span class="n">c</span> <span class="p">;</span> <span class="c1">// OK</span>
        <span class="p">}</span> <span class="p">;</span>
    <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>外側のラムダ式が、デフォルトキャプチャーによって、暗黙的に変数をキャプチャーしている場合は、内側のラムダも、その変数をキャプチャーできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="p">[</span><span class="o">=</span><span class="p">]{</span><span class="c1">// 外側のラムダ式</span>
        <span class="p">[</span><span class="o">=</span><span class="p">]{</span><span class="c1">// 内側のラムダ式</span>
            <span class="n">a</span> <span class="p">;</span> <span class="c1">// OK</span>
        <span class="p">}</span> <span class="p">;</span>
    <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="this">
<h3>thisのキャプチャー<a class="headerlink" href="#this" title="Permalink to this headline">¶</a></h3>
<p>基本的にラムダ式は、そのラムダ式が使われているブロックスコープのローカル変数しかキャプチャーできない。しかし、実は、データメンバーを使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="o">=</span><span class="p">]{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span><span class="c1">// OK、ただし、これはキャプチャーではないことに注意</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>このように、非staticなメンバー関数のラムダ式では、データメンバーを使うことができる。しかし、これは、データメンバーをキャプチャーしているわけではない。その証拠に、データメンバーを直接キャプチャーしようとすると、エラーになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="n">x</span><span class="p">]{}</span> <span class="p">;</span> <span class="c1">// エラー、データメンバーはキャプチャーできない</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>では、どうしてデータメンバーが使えるのか。一体何をキャプチャーしているのか。実は、これはthisをキャプチャーしているのである。ラムダ式は、thisをキャプチャーできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="k">this</span><span class="p">]{</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダ式の関数の本体では、thisは、クロージャーオブジェクトへのポインターではなく、ラムダ式が使われている非staticなメンバー関数のthisをキャプチャーしたものと解釈される。thisは、必ずコピーキャプチャーされる。というのも、そもそもthisはポインターなので、リファレンスキャプチャーしても、あまり意味はない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="k">this</span><span class="p">]{}</span> <span class="p">;</span> <span class="c1">// OK</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="k">this</span><span class="p">]{}</span> <span class="p">;</span> <span class="c1">// エラー、thisはリファレンスキャプチャーできない</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ラムダ式にデフォルトキャプチャーが指定されていて、データメンバーが使われている場合、thisは暗黙的にキャプチャーされる。デフォルトキャプチャーがコピーでもリファレンスでも、thisは必ずコピーキャプチャーされる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="p">[</span><span class="o">=</span><span class="p">]{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// thisをコピーキャプチャーする</span>
        <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// thisをコピーキャプチャーする</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>thisのキャプチャーは、注意を要する。すでに述べたように、データメンバーは、キャプチャーできない。ラムダ式でデータメンバーを使うということは、thisをキャプチャーするということである。データメンバーは、thisを通して使われる。これは、データメンバーは参照で使われるということを意味する。ということは、もし、クロージャーオブジェクトのoperator ()が呼ばれた際に、thisを指し示すオブジェクトが無効になっていた場合、エラーとなってしまう。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="p">[</span><span class="k">this</span><span class="p">]{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span> <span class="p">;</span>
    <span class="p">{</span>
        <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span>
    <span class="p">}</span><span class="c1">// cの寿命はすでに終わっている</span>

    <span class="n">f</span><span class="p">()</span> <span class="p">;</span><span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>データメンバーをコピーキャプチャーする方法はない。そもそも、何度も述べているように、データメンバーはキャプチャーできない。では、上の例で、どうしてもデータメンバーの値を使いたい場合はどうすればいいのか。この場合、一度ローカル変数にコピーするという方法がある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span> <span class="p">;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]{</span> <span class="k">return</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span><span class="c1">// xはローカル変数のコピー</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>もちろん、同じ名前にするのが紛らわしければ、名前を変えてもいい。</p>
<p>ラムダ式でデータメンバーを使う際には、キャプチャーしているのは、実はthisなのだということに注意しなければならない。</p>
</div>
<div class="section" id="id8">
<h3>パラメーターパックのキャプチャー<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>可変引数テンプレートの関数パラメーターパックも、キャプチャーリストに書くことができる。その場合、通常と同じように、パック展開になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">args</span> <span class="p">)</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 明示的なキャプチャー</span>
    <span class="p">[</span><span class="n">args</span><span class="p">...]{</span> <span class="n">g</span><span class="p">(</span> <span class="n">args</span><span class="p">...</span> <span class="p">)</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="n">args</span><span class="p">...]{</span> <span class="n">g</span><span class="p">(</span> <span class="n">args</span><span class="p">...</span> <span class="p">)</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

    <span class="c1">// 暗黙的なキャプチャー</span>
    <span class="p">[</span><span class="o">=</span><span class="p">]{</span> <span class="n">g</span><span class="p">(</span> <span class="n">args</span><span class="p">...</span> <span class="p">)</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
    <span class="p">[</span><span class="o">&amp;</span><span class="p">]{</span> <span class="n">g</span><span class="p">(</span> <span class="n">args</span><span class="p">...</span> <span class="p">)</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="postfix-expressions">
<h2>後置式（Postfix expressions）<a class="headerlink" href="#postfix-expressions" title="Permalink to this headline">¶</a></h2>
<p>後置式は、主にオペランドの後ろに演算子を書くことから、そう呼ばれている。後置式の評価順序はすべて、「左から右」である。</p>
<div class="section" id="subscripting">
<h3>添字（Subscripting）<a class="headerlink" href="#subscripting" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>式 [ 式 ]
式 [ 初期化リスト ]</pre>
</div>
<p>operator []は、添字と呼ばれる式である。これは、配列の要素にアクセスするために用いられる。どちらか片方の式は、Tへのポインター型でなければならず、もう片方は、unscoped enumか、整数型でなければならない。式の結果は、lvalueのTとなる。式、E1[E2] は、<a href="#id9"><span class="problematic" id="id10">*</span></a>((E1)+(E2)) と書くのに等しい</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">;</span>
<span class="c1">// *(x + 1)と同じ</span>
<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>この場合、xには、&lt;a href=&#8221;#conv.array&#8221;&gt;配列からポインターへの型変換&lt;/a&gt;が適用されている。</p>
<p>「どちらか片方の式」というのは、文字通り、どちらか片方である。たとえば、x[1]とすべきところを、1[x]としても、同じ意味になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">;</span>
<span class="c1">// どちらも同じ意味。</span>
<span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>
<span class="mi">1</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>もっとも、通常は、一つめの式をポインター型にして、二つ目の式を整数型にする。ユーザー定義のoperator []では、このようなことはできない。</p>
<p>ユーザー定義のoperator []の場合、[]の中の式に、初期化リストを渡すことができる。これは、どのように使ってもいいいが、例えば以下のように使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">list</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">list</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">3</span> <span class="p">){</span><span class="cm">/* エラー処理 */</span><span class="p">}</span>

        <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span> <span class="n">list</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">const</span> <span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span> <span class="p">;</span> <span class="o">++</span><span class="n">iter</span> <span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">const</span> <span class="n">j</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span> <span class="p">;</span> <span class="o">++</span><span class="n">iter</span> <span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">const</span> <span class="n">k</span> <span class="o">=</span> <span class="o">*</span><span class="n">iter</span> <span class="p">;</span>

        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="n">c</span><span class="p">[{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初期化リストを使えば、オーバーロードされたoperator []に、複数の引数を渡すことができる。</p>
</div>
<div class="section" id="function-call">
<h3>関数呼び出し（Function call）<a class="headerlink" href="#function-call" title="Permalink to this headline">¶</a></h3>
<p>関数呼び出し（function call）の文法は、以下の通り。</p>
<div class="highlight-c++"><pre>式 ( 引数のリスト )</pre>
</div>
<p>関数呼び出しには、通常の関数呼び出しと、メンバー関数呼び出しがある。</p>
<p>通常の関数を呼び出す場合、式には、関数へのlvalueか、関数へのポインターが使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 「関数へのlvalue」への関数呼び出し</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">g</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">h</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 関数への参照</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="p">;</span>

    <span class="c1">// 「関数へのlvalue」への関数呼び出し</span>
    <span class="n">ref</span><span class="p">()</span> <span class="p">;</span>

    <span class="c1">// 関数ポインター</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span> <span class="p">;</span>

    <span class="c1">// 関数ポインターへの関数呼び出し</span>
    <span class="n">ptr</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>staticなメンバー関数は、通常の関数呼び出しになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="k">static</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">f</span> <span class="p">;</span>
    <span class="n">ptr</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 通常の関数呼び出し</span>
<span class="p">}</span>
</pre></div>
</div>
<p>メンバー関数を呼び出す場合、式には、関数のメンバーの名前か、メンバー関数へのポインター式が使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">g</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// メンバー関数の呼び出し</span>
        <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span>
        <span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">).</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span>

        <span class="c1">// メンバー関数へのポインター</span>
        <span class="kt">void</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span> <span class="n">ptr</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">f</span> <span class="p">;</span>
        <span class="c1">// 関数呼び出し</span>
        <span class="p">(</span><span class="k">this</span><span class="o">-&gt;*</span><span class="n">ptr</span><span class="p">)()</span> <span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>関数呼び出し式の結果の型は、式で呼び出した関数の戻り値の型になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">()</span> <span class="p">;</span>

<span class="c1">// 式の結果の型はvoid</span>
<span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="c1">// 式の結果の型はint</span>
<span class="n">g</span><span class="p">()</span> <span class="p">;</span>
</pre></div>
</div>
<p>関数呼び出しの結果の型は、戻り値の型になる。これはtypeidやsizeofやdecltypeのオペランドの中でも、同様である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 関数fの戻り値の型はint</span>
<span class="c1">// すなわち、fを関数呼び出しした結果の型はint</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// sizeof(int)と同じ</span>
    <span class="k">sizeof</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// typeid(int)と同じ</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// int型の変数xの宣言と定義。</span>
    <span class="n">decltype</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数が呼ばれた際、仮引数は対応する実引数で初期化される。非staticメンバー関数の場合、this仮引数もメンバー関数を呼び出した際のオブジェクトへのポインターで初期化される。</p>
<p>仮引数に対して、具体的な一時オブジェクトが生成されるかどうかは、実装依存である。たとえば、実装は最適化のために、一時オブジェクトの生成を省略するかもしれない。</p>
<p>仮引数が参照の場合をのぞいて、呼ばれた関数の中で仮引数を変更しても、実引数は変更されない。ただし、型がポインターの場合、参照を通して参照先のオブジェクトが変更される可能性がある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 実引数は変更されない</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 実引数が変更される</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 実引数は、ポインターの参照を通して変更される</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span> <span class="c1">// 実引数のポインターは変更されない</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="c1">// 実引数</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>実引数の式が、どのような順番で評価されるかは決められていない。ただし、呼び出された関数の本体に入る際には、式はすべて評価されている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="kt">int</span> <span class="nf">f1</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f1&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">f2</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f2&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">f3</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f3&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">){</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">g</span><span class="p">(</span> <span class="n">f1</span><span class="p">(),</span> <span class="n">f2</span><span class="p">(),</span> <span class="n">f3</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span><span class="c1">// f1, f2, f3関数呼び出しの順番は分からない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、関数f1, f2, f3がどの順番で呼ばれるのかが分からない。したがって、標準出力にどのような順番で文字列が出力されるかも分からない。ただし、関数gの本体に入る際には、f1, f2, f3は、すべて呼び出されている。</p>
<p>関数は、自分自身を呼び出すことができる。これを再帰呼び出しという。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 自分自身を呼び出す、無限ループ</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、main関数だけは特別で、再帰呼び出しをすることができない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">main</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-type-conversion-functional-notation">
<h3>関数形式の明示的型変換（Explicit type conversion (functional notation)）<a class="headerlink" href="#explicit-type-conversion-functional-notation" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>型名 ( 式リスト )
型名 初期化リスト</pre>
</div>
<p>関数形式の明示的型変換（Explicit type conversion (functional notation)）とは、関数呼び出しのような文法による、一種のキャストである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span><span class="p">()</span> <span class="p">;</span>
    <span class="kt">int</span><span class="p">{}</span> <span class="p">;</span>

    <span class="n">S</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">S</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>型名として使えるのは、&lt;a href=&#8221;#dcl.type.simple&#8221;&gt;単純型指定子&lt;/a&gt;か、typename指定子である。単純型指定子でなければならないということには、注意しなければならない。たとえば、ポインターやリファレンス、配列などを直接書くことはできない。ただし、typedef名は使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="c1">// これらはエラー</span>
<span class="kt">int</span> <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>

<span class="c1">// typedef名は使える</span>
<span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">*</span> <span class="p">;</span>
<span class="n">type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>単純型指定子の中でも、autoとdecltypeは、注意が必要である。まず、autoは使えない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">auto</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
</pre></div>
</div>
<p>decltypeは使える。ただし、非常に使いづらいので、使うべきではない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int型をint型にキャスト</span>
<span class="c1">// int(0) と同じ</span>
<span class="n">decltype</span><span class="p">(</span><span class="mi">0</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>たとえば、以下のコードはエラーである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span><span class="c1">// エラー</span>
</pre></div>
</div>
<p>これは、文法が曖昧だからだ。詳しくは、&lt;a href=&#8221;#stmt.ambig&#8221;&gt;曖昧解決&lt;/a&gt;を参照。何が起こっているかというと、decltype(x)(x)は、キャストではなく、変数の宣言だとみなされている。decltype(x)は、intという型である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// decltype(x)(x) と同じ</span>
<span class="c1">// decltype(x)(x) → int (x) → int x</span>
<span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
</pre></div>
</div>
<p>このため、decltypeを関数形式のキャストで使うのは、問題が多い。使うならば、typedef名をつけてから使うか、static_castを使うべきである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
<span class="n">type</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>

<span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>typename指定子も使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>式リストが、たったひとつの式である場合、&lt;a href=&#8221;#expr.cast&#8221;&gt;キャスト&lt;/a&gt;と同じ意味になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int型からshort型へのキャスト</span>
<span class="kt">short</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
<span class="c1">// int型からdouble型へのキャスト</span>
<span class="kt">double</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// 変換関数による、int型からC型へのキャスト</span>
<span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>型名がクラス名である場合、T(x1, x2, x3)という形の式は、T t(x1, x2, x3)という形と同じ意味を持つ一時オブジェクトを生成し、その一時オブジェクトを、prvalueの結果として返す。型名がクラス名でも、式リストがひとつしかない場合は、キャストである。もっとも、その場合も、ユーザー定義のコンストラクターが、変換関数として呼び出されることになるので、意味はあまり変わらない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// これはキャスト、意味としては、あまり違いはない</span>
    <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">C</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>式リストが空の場合、つまり、T()という形の式の場合。まず、Tは配列型であってはならない。Tは完全な型か、voidでなければならない。式の結果は、値初期化された型のprvalueの値になる。値初期化については、&lt;a href=&#8221;#dcl.init&#8221;&gt;初期化子&lt;/a&gt;を参照。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// int型の0で初期化された値</span>
<span class="kt">double</span><span class="p">()</span> <span class="o">:</span> <span class="c1">// double型の0で初期化された値</span>

<span class="k">struct</span> <span class="n">C</span> <span class="p">{}</span> <span class="p">;</span>
<span class="n">C</span><span class="p">()</span> <span class="p">;</span><span class="c1">// デフォルトコンストラクターが呼ばれたCの値</span>
</pre></div>
</div>
<p>void型の場合、値初期化はされない。式の結果の型はvoidである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 結果はvoid</span>
</pre></div>
</div>
<p>括弧で囲まれた式リストではなく、初期化リストの場合、式の結果は、指定された型の、初期化リストによって直接リスト初期化されたprvalueの一時オブジェクトになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;initializer_list&gt;</span>

<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="pseudo-destructor-call">
<h3>疑似デストラクター呼び出し（Pseudo destructor call）<a class="headerlink" href="#pseudo-destructor-call" title="Permalink to this headline">¶</a></h3>
<p>疑似デストラクター呼び出しとは、デストラクターを明示的に呼び出すことができる一連の式である。使い方は、operator .、operator -&amp;gt;に続けて、疑似デストラクター名を書き、さらに関数呼び出しのoperator ()を書く。この一連の式を、疑似ですトラクター呼び出しという。このような疑似デストラクター名に続けては、関数呼び出し式しか適用することができない。式の結果はvoidになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// このコードは、疑似デストラクター呼び出しの文法を示すためだけの例である</span>
<span class="k">struct</span> <span class="n">C</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 疑似デストラクター呼び出し</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span>
    <span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">C</span><span class="p">()</span> <span class="p">;</span><span class="c1">// 疑似デストラクター呼び出し</span>
<span class="p">}</span>
</pre></div>
</div>
<p>注意すべきことは、デストラクターを明示的に呼び出したとしても、暗黙的に呼び出されるデストラクターは、依然として呼び出されるということである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;destructed.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
        <span class="n">c</span><span class="p">.</span><span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="p">;</span><span class="c1">// デストラクターを呼び出す</span>
    <span class="p">}</span><span class="c1">// ブロックスコープの終りでも、デストラクターは暗黙的に呼ばれる</span>

    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span> <span class="p">;</span>
    <span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">C</span><span class="p">()</span> <span class="p">;</span><span class="c1">// デストラクターを呼び出す</span>

    <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span><span class="c1">// デストラクターが暗黙的に呼ばれる。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、通常は、デストラクターの呼び出しが重複してしまう。二重にデストラクターを呼び出すのは、大抵の場合、プログラム上のエラーである。では、疑似デストラクター呼び出しは何のためにあるのか。具体的な用途としては、placement newと組み合わせて使うということがある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// placement new用のストレージを確保</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">storage</span> <span class="o">=</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// placement new</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span>  <span class="k">new</span><span class="p">(</span><span class="n">storage</span><span class="p">)</span> <span class="n">C</span> <span class="p">;</span>
    <span class="c1">// デストラクターを呼び出す</span>
    <span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">C</span><span class="p">()</span> <span class="p">;</span>
    <span class="c1">// placement new用のストレージを解放</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この疑似デストラクターには、decltypeを使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="o">~</span><span class="n">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span>
    <span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">decltype</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>テンプレート引数の場合、型がスカラー型であっても、疑似デストラクター呼び出しができる</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">t</span> <span class="p">;</span>
    <span class="n">t</span><span class="p">.</span><span class="o">~</span><span class="n">T</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これにより、ジェネリックなテンプレートコードが書きやすくなる。</p>
</div>
<div class="section" id="class-member-access">
<h3>クラスメンバーアクセス（Class member access）<a class="headerlink" href="#class-member-access" title="Permalink to this headline">¶</a></h3>
<p>TODO: 詳細なvalue categoryを説明するかどうか。</p>
<div class="highlight-c++"><pre>クラスのオブジェクト . メンバー名
クラスのポインター -&gt; メンバー名</pre>
</div>
<p>クラスメンバーアクセスは、名前の通り、クラスのオブジェクトか、クラスのオブジェクトへのポインターのメンバーにアクセスするための演算子である。</p>
<p>. 演算子の左側の式は、クラスのオブジェクトでなければならない。-&amp;gt; 演算子の左側の式は、クラスのオブジェクトへのポインターでなければならない。演算子の右側は、そのクラスか、基本クラスのメンバー名でなければならない。-&amp;gt; 演算子を使った式、E1-&amp;gt;E2は、(<a href="#id11"><span class="problematic" id="id12">*</span></a>(E1)).E2という式とおなじになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Object</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="n">Object</span><span class="o">::</span><span class="n">y</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="p">;</span>
    <span class="c1">// . 演算子</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span>

    <span class="n">Object</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span> <span class="p">;</span>
    <span class="c1">// -&gt; 演算子</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もし、クラスのオブジェクト、クラスのオブジェクトへのポインターを表す式が依存式であり、メンバー名がメンバーテンプレートであり、テンプレート引数を明示的に指定したい場合、メンバー名の前に、templateキーワードを使わなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Object</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">obj</span> <span class="p">;</span>
    <span class="n">obj</span><span class="p">.</span><span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">obj</span><span class="p">.</span><span class="k">template</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは、&amp;lt;演算子や、&amp;gt;演算子と、文法が曖昧になるためである。この問題については、&lt;a href=&#8221;#temp.names&#8221;&gt;テンプレート特殊化の名前&lt;/a&gt;でも、解説している。</p>
<p>派生によって、クラスのメンバー名が曖昧な場合、エラーになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base1</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Base2</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>

    <span class="n">d</span><span class="p">.</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">d</span><span class="p">.</span><span class="n">Base1</span><span class="o">::</span><span class="n">x</span> <span class="p">;</span><span class="c1">// OK</span>
    <span class="n">d</span><span class="p">.</span><span class="n">Base2</span><span class="o">::</span><span class="n">x</span> <span class="p">;</span><span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>TODO: value categoryについて。むしろlvalue and rvalueのところで説明すべきか</p>
</div>
<div class="section" id="increment-and-decrement">
<h3>インクリメントとデクリメント（Increment and decrement）<a class="headerlink" href="#increment-and-decrement" title="Permalink to this headline">¶</a></h3>
<p>ここでは、後置式のインクリメントとデクリメントについて解説する。前置式のインクリメントとデクリメントについては、&lt;a href=&#8221;#expr.pre.incr&#8221;&gt;単項式のインクリメントとデクリメント&lt;/a&gt;を参照。</p>
<div class="highlight-c++"><pre>式 ++
式 --</pre>
</div>
<p>後置式の++演算子の式の結果は、オペランドの式の値になる。オペランドは、変更可能なlvalueでなければならない。オペランドの型は、数値型か、ポインター型でなければならない。式が評価されると、オペランドに1を加算する。ただし、式の結果は、オペランドに1を加算する前の値である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">++</span> <span class="p">;</span>

<span class="c1">// ここで、result == 0, x == 1</span>
</pre></div>
</div>
<p>式の結果の値は、オペランドの値と変わりがないが、オペランドには、1を加算されるということに注意しなければならない。</p>
<p>後置式の&#8211;演算子は、オペランドから1を減算する。それ以外は、++演算子と全く同じように動く。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">--</span> <span class="p">;</span>

<span class="c1">// ここで、result == 0, x == -1</span>
</pre></div>
</div>
</div>
<div class="section" id="dynamic-cast-dynamic-cast">
<h3>Dynamic cast（Dynamic cast）<a class="headerlink" href="#dynamic-cast-dynamic-cast" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>dynamic_cast &lt; 型名 &gt; ( 式 )</pre>
</div>
<p>dynamic_cast&amp;lt;T&amp;gt;(v)という式は、vという式をTという型に変換する。便宜上、vをdynamic_castのオペランド、Tをdynamic_castの変換先の型とする。変換先の型はクラスへのポインターかリファレンス、あるいは、voidへのポインター型でなければならない。オペランドは、変換先の型が、ポインターの場合はポインター、リファレンスの場合はリファレンスでなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>

    <span class="c1">// 変換先の型がポインターの場合は、オペランドもポインター</span>
    <span class="c1">// 変換先の型がリファレンスの場合は、オペランドもリファレンスでなければならない</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>

    <span class="c1">// ポインターかリファレンスかが、一致していない</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="dynamic-cast">
<h4>dynamic_castの機能<a class="headerlink" href="#dynamic-cast" title="Permalink to this headline">¶</a></h4>
<p>今、Derivedクラスが、Baseクラスから派生されていたとする。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この時、static_castを使えば、Baseへのポインターやリファレンスから、Derivedへのポインターやリファレンスに変換することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>

    <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">base_ref</span> <span class="o">=</span> <span class="n">d</span> <span class="p">;</span>
    <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">derived_ref</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">base_ref</span><span class="p">)</span> <span class="p">;</span>

    <span class="n">Base</span> <span class="o">*</span> <span class="n">base_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span> <span class="p">;</span>
    <span class="n">Derived</span> <span class="o">*</span> <span class="n">derived_ptr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">base_ptr</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、ポインターやリファレンスが指す、本当のオブジェクトは、Derivedクラスのオブジェクトだということが分かりきっているので安全である。しかし、ポインターやリファレンスを使う場合、常にオブジェクトの本当のクラス型が分かるわけではない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">base</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// baseがDerivedを参照しているかどうかは、分からない。</span>
    <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">d</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">derived</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">derived</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// ok</span>

    <span class="n">Base</span> <span class="n">base</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、ポインターやリファレンスの指し示すオブジェクトの本当のクラス型は、実行時にしか分からない。しかし、オブジェクトの型によって、特別な処理をしたいことも、よくある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">base</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="cm">/* baseの指すオブジェクトがDerivedクラスの場合*/</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 特別な処理</span>
    <span class="p">}</span>

    <span class="c1">// 共通の処理</span>
<span class="p">}</span>
</pre></div>
</div>
<p>本来、このような処理は、virtual関数で行うべきである。しかし、現実には、どうしても、このような泥臭くて汚いコードを書かなければならない場合もある。そのようなどうしようもない場合のために、C++には、基本クラスへのポインターやリファレンスが、実は派生クラスをオブジェクトを参照している場合に限り、キャストできるという機能が提供されている。それが、dynamic_castである。</p>
<p>動的な型チェックを使うためには、dynamic_castのオペランドのクラスは、ポリモーフィック型でなければならない。つまり、すくなくともひとつのvirtual関数を持っていなければならない。ポリモーフィック型の詳しい定義については、&lt;a href=&#8221;#class.virtual&#8221;&gt;virtual関数&lt;/a&gt;を参照。</p>
<p>もし、オペランドの参照するオブジェクトが、変換先の型として指定されている派生クラスのオブジェクトであった場合、変換することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span><span class="c1">// baseはDerivedを指しているとする</span>
    <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">Derived</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>実引数に、変換先の型ではないオブジェクトを渡した場合、dynamic_castの変換は失敗する。変換が失敗した場合、変換先の型がリファレンスの場合、std::bad_castがthrowされる。変換先の型がポインターの場合、nullポインターが返される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Base</span> <span class="n">base</span> <span class="p">;</span>

    <span class="c1">// リファレンスの場合</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_cast</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 変換失敗</span>
        <span class="c1">// リファレンスの場合、std::bad_castがthrowされる</span>
    <span class="p">}</span>

    <span class="c1">// ポインターの場合</span>
    <span class="n">Derived</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">base</span><span class="p">)</span> <span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">ptr</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 変換失敗</span>
        <span class="c1">// ポインターの場合、nullポインターが返される</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>基本クラスのポインターやリファレンスが、実際は何を指しているかは、実行時にしか分からない。そのため、常に変換に失敗する可能性がある。そのため、dynamic_castを使う場合は、常に変換が失敗するかもしれないという前提のもとに、コードを書かなければならない。</p>
<p>失敗せずに変換できる場合というのは、オペランドの指すオブジェクトの本当の型が、変換先の型のオブジェクトである場合で、しかもアクセスできる場合である。オブジェクトである（is a）場合というのは、例えば、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">C</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">C</span> <span class="p">{}</span> <span class="p">;</span>
</pre></div>
</div>
<p>このようなクラスがあった場合、Dは、Cであり、Bであり、Aである。従って、Dのオブジェクトを、Aへのリファレンスで保持していた場合、D、C、Bのいずれにも変換できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">D</span> <span class="n">d</span> <span class="p">;</span>
    <span class="n">A</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">d</span> <span class="p">;</span>

    <span class="c1">// OK</span>
    <span class="c1">// refの指しているオブジェクトは、Dなので、変換できる。</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">D</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">B</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>アクセスできる場合というのは、変換先の型から、publicで派生している場合である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base1</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Base2</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(){}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Base3</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">h</span><span class="p">(){}</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">Base1</span><span class="p">,</span>
      <span class="k">public</span> <span class="n">Base2</span><span class="p">,</span>
      <span class="k">private</span> <span class="n">Base3</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>
    <span class="n">Base1</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">d</span> <span class="p">;</span>

    <span class="c1">// OK、Base2はpublicなので、アクセス出来る</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Base2</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">;</span>
    <span class="c1">// 実行時エラー、Base3はprivateなので、アクセス出来ない</span>
    <span class="c1">// std::bad_castがthrowされる。</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Base3</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例の場合、refが参照するオブジェクトは、Derived型であるので、Base3型のサブオブジェクトも持っているが、Base3からは、privateで派生されているために、アクセスすることはできない。そのため、変換することが出来ず、std::bad_castがthrowされる。</p>
<p>変換先の型は、void型へのポインターとすることもできる。その場合、オペランドの指す本当のオブジェクトの、もっとも派生されたクラスを指すポインターが、voidへのポインター型として、返される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(){}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived2</span> <span class="o">:</span> <span class="n">Derived1</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived1</span> <span class="n">d1</span> <span class="p">;</span>
    <span class="n">Base</span> <span class="o">*</span> <span class="n">d1_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d1</span> <span class="p">;</span>

    <span class="c1">// Derived1を指すポインターの値が、void *として返される</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">void_ptr1</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">d1_ptr</span><span class="p">)</span> <span class="p">;</span>

    <span class="n">Derived1</span> <span class="n">d2</span> <span class="p">;</span>
    <span class="n">Base</span> <span class="o">*</span> <span class="n">d2_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d2</span><span class="p">;</span>

    <span class="c1">// Derived2を指すポインターの値が、void *として返される</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">void_ptr2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">d2_ptr</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一般に、この機能はあまり使われることがないだろう。</p>
</div>
<div class="section" id="id13">
<h4>dynamic_castのその他の機能<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>dynamic_castは、その主目的の機能の他にも、クラスへのポインターやリファレンスに限って、キャストを行うことができる。この機能は、&lt;a href=&#8221;#conv.ptr&#8221;&gt;標準型変換のポインターの型変換&lt;/a&gt;に、ほぼ似ている。このキャストは、static_castでも行える。以下の機能に関しては、実行時のコストは発生しない。</p>
<p>オペランドの型が、変換先の型と同じ場合、式の結果の型は、変換先の型になる。この時、constとvolatileを付け加えることはできるが、消し去ることは出来ない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 型と式が同じ場合の例</span>
<span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">v</span> <span class="p">;</span>

    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="k">const</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// constを付け加える</span>

    <span class="n">C</span> <span class="k">const</span> <span class="n">cv</span> <span class="p">;</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">cv</span><span class="p">)</span> <span class="p">;</span><span class="c1">// エラー、constを消し去ることは出来ない</span>

    <span class="c1">// ポインターの場合</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span> <span class="p">;</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>変換先の型が基本クラスへのリファレンスで、オペランドの型が、派生クラスへのリファレンスの場合、dynamic_castの結果は、派生クラスのうちの基本クラスを指すリファレンスになる。ポインターの場合も、同様である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span> <span class="c1">// 基本クラス</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span> <span class="c1">// 派生クラス</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>

    <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">base_ref</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Base</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">Base</span> <span class="o">*</span> <span class="n">base_ptr</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Base</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="type-identification">
<h3>型識別（Type identification）<a class="headerlink" href="#type-identification" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>typeid ( 式 )
typeid ( 型名 )</pre>
</div>
<p>typeidとは、式や型名の、型情報を得るための式である。型情報は、const std::type_infoのリファレンスという形で返される。std::type_infoについての詳細は、&lt;a href=&#8221;#support.rtti&#8221;&gt;RTTI（Run Time Type Information）&lt;/a&gt;を参照。typeidを使うには、必ず、&amp;lt;typeinfo&amp;gt;ヘッダーを#includeしなければならない。ただし、本書のサンプルコードは、紙面の都合上、必要なヘッダーのincludeを省略していることがある。</p>
<p>typeidのオペランドは、sizeofに似ていて、式と型名の両方を取ることができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;typeinfo&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 型名の例</span>
    <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 式の例</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="k">typeid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">typeid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span> <span class="p">)</span> <span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>typeidのオペランドの式が、ポリモーフィッククラス型のglvalueであった場合、実行時チェックが働き、結果のstd::type_infoが表す型情報は、実行時に決定される。型情報は、オブジェクトの最も派生したクラスの型となる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">d</span> <span class="p">;</span>

    <span class="c1">// オブジェクトの、実行時の本当の型を表すtype_infoが返される</span>
    <span class="n">std</span><span class="o">::</span><span class="n">type_info</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ti</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// true</span>
    <span class="n">ti</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">Derived</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// Derivedを表す、人間の読める実装依存の文字列</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ti</span><span class="p">.</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オペランドの式の型がポリモーフィッククラス型のglvalueの場合で、nullポインターを参照した場合は、std::bad_typeidが投げられる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ptrの値はnullポインター</span>
    <span class="n">Base</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="k">typeid</span><span class="p">(</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span> <span class="p">;</span><span class="c1">// 実行時エラー</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_typeid</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 例外が投げられて、ここに処理が移る</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オペランドの式の型が、ポリモーフィッククラス型でない場合は、std::type_infoが表す型情報は、コンパイル時に決定される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int型を表すtype_info</span>
<span class="k">typeid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
<span class="c1">// double型を表すtype_info</span>
<span class="k">typeid</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="c1">// int型を表すtype_info</span>
<span class="k">typeid</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>この際、&lt;a href=&#8221;#conv.lval&#8221;&gt;lvalueからrvalueへの型変換&lt;/a&gt;、&lt;a href=&#8221;#conv.array&#8221;&gt;配列からポインターへの型変換&lt;/a&gt;、&lt;a href=&#8221;#conv.func&#8221;&gt;関数からポインターへの型変換&lt;/a&gt;は行われない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 配列からポインターへの型変換は行われない</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>

<span class="c1">// 型情報は、int [10]</span>
<span class="c1">// int *ではない</span>
<span class="k">typeid</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">;</span>

<span class="c1">// 関数からポインターへの型変換は行われない</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// 型情報は、void (void)</span>
<span class="c1">// void (*)(void)ではない。</span>
<span class="k">typeid</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>これらの標準型変換は、C++では、非常に多くの場所で、暗黙のうちに行われているので、あまり意識しない。たとえば、テンプレートの実引数を推定する上では、これらの変換が行われる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 実引数の型を、表示してくれるはずの便利な関数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print_type_info</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">T</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
    <span class="c1">// int [10]</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
    <span class="c1">// int *</span>
    <span class="n">print_type_info</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// void (void)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
    <span class="c1">// void (*)(void)</span>
    <span class="n">print_type_info</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>std::type_info::name()の返す文字列は実装依存だが、今、C++の文法と同じように型を表示すると仮定すると、このような出力になる。C++では、多くの場面で、暗黙のうちに、これら三つの型変換が行われるので、このような差異が生じる。</p>
<p>オペランドが、型名の場合は、std::type_infoは、その型を表す。ほんの一例をあげると。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>             <span class="c1">// int型</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="p">)</span> <span class="p">;</span>           <span class="c1">// intへのポインター型</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="p">;</span>           <span class="c1">// intへのlvalueリファレンス型</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="p">;</span>         <span class="c1">// 配列型</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="p">;</span>      <span class="c1">// 配列へのポインター型</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span>       <span class="c1">// 関数型</span>
    <span class="k">typeid</span><span class="p">(</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="p">);</span>     <span class="c1">// 関数へのポインター型</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オペランドの式や型名の、トップレベル（top-level）のCV修飾子は、無視される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// トップレベルのCV修飾子は無視される</span>
    <span class="k">typeid</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// int</span>
    <span class="c1">// 当然、型情報は等しい</span>
    <span class="k">typeid</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="c1">// 型名も式も同じ</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">typeid</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// int</span>
    <span class="k">typeid</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="c1">// これはトップレベルのCV修飾子</span>
    <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="k">const</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// int *</span>

    <span class="c1">// 以下はトップレベルのCV修飾子ではない</span>
    <span class="k">typeid</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// int const *</span>
    <span class="k">typeid</span><span class="p">(</span><span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// int const *</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="static-cast-static-cast">
<h3>Static cast（Static cast）<a class="headerlink" href="#static-cast-static-cast" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>static_cast&lt; 型名 &gt;( 式 )</pre>
</div>
<p>static_castは、実に多くの静的な変換ができる。その概要は、標準型変換とその逆変換、ユーザー定義の変換、リファレンスやポインターにおける変換など、比較的安全なキャストである。以下にstatic_castの行える変換を列挙するが、これらを丸暗記しておく必要はない。もし、どのキャストを使うか迷った場合は、static_castを使っておけば、まず間違いはない。static_castがコンパイルエラーとなるキャストは、大抵、実装依存で危険なキャストである。</p>
<p>static_castによるキャストがどのように行われるかは、おおむね、以下のような順序で判定される。条件に合う変換方法が見つかった時点で、それより先に行くことはない。これは、完全なstatic_castの定義ではない。分かりやすさのため省いた挙動もある。</p>
<p>static_cast&amp;lt;T&amp;gt;(v)の結果は、オペランドvを変換先の型Tに変換したものとなる。変換先の型がlvalueリファレンスならば結果はlvalue、rvalueリファレンスならば結果はxvalue、それ以外の結果はprvalueとなる。static_castは、constとvolatileを消し去ることはできない。</p>
<p>オペランドの型が基本クラスで、変換先の型が派生クラスへのリファレンスの場合。もし、標準型変換で、派生クラスのポインターから、基本クラスのポインターへと変換できる場合、キャストできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span> <span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Derived *からBase *に標準型変換で変換できるので、キャストできる</span>
    <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">derived</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、これには実行時チェックがないので、baseが本当にDerivedのオブジェクトを参照していなかった場合、動作は未定義である。</p>
<p>glvalueのオペランドは、rvalueリファレンスに型変換できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もし、static_cast&amp;lt;T&amp;gt;(e) という式で、T t(e); という宣言ができる場合、オペランドの式eは、変換先の型Tに変換できる。その場合、一時オブジェクトを宣言して、それをそのまま使うのと、同じ意味になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// short t(0) は可能なので変換できる</span>
<span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>

<span class="c1">// float t(0) は可能なので変換できる</span>
<span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>&lt;a href=&#8221;#conv&#8221;&gt;標準型変換&lt;/a&gt;の逆変換を行うことができる。ただし、いくつかの変換は、逆変換を行えない。これには、&lt;a href=&#8221;#conv.lval&#8221;&gt;lvalueからrvalueへの型変換&lt;/a&gt;、&lt;a href=&#8221;#conv.array&#8221;&gt;配列からポインターへの型変換&lt;/a&gt;、&lt;a href=&#8221;#conv.func&#8221;&gt;関数からポインターへの型変換（Function-to-pointer conversion）&lt;/a&gt;、ポインターや関数ポインターからnullポインターへの変換、がある。</p>
<p>変換先の型に、voidを指定することができる。その場合、static_castの結果はvoidである。オペランドの式は評価される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>整数型とscoped enum型は、static_castを使うことで、明示的に変換することができる。その場合、変換先の型で、オペランドの値を表現できる場合は、値が保持される。値を表現できない場合の挙動は、規定されていない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">;</span>
    <span class="k">enum</span> <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">A</span><span class="o">::</span><span class="n">value</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">A</span><span class="o">::</span><span class="n">value</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>派生クラスへのポインターから、基本クラスへのポインターにキャストできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{}</span> <span class="p">;</span>

<span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>
<span class="n">Base</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>voidへのポインターは、他の型へのポインターに変換できる。ある型へのポインターから、voidへのポインターにキャストされ、そのまま、ある型へのポインターにキャストされなおされた場合、その値は保持される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">;</span>

    <span class="c1">// void *への変換は、標準型変換で行えるので、キャストはなくてもよい。</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">void_ptr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// キャストが必要</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">void_ptr</span><span class="p">)</span> <span class="p">;</span>

    <span class="o">*</span><span class="n">ptr</span> <span class="p">;</span> <span class="c1">// ポインターの値は保持されるので、xを正しく参照する</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="reinterpret-cast">
<h3>Reinterpret cast<a class="headerlink" href="#reinterpret-cast" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>reinterpret_cast &lt; 型名 &gt; ( 式 )</pre>
</div>
<p>reinterpret_castは、式の値をそのまま、他の型に変換するキャストである。ポインターと整数の間の変換や、ある型へのポインターを全く別の型へのポインターに変換するといったことができる。reinterpret_castを使えば、値をそのままにして、型を変換することができる。変換した結果、その値が、変換先の型としてそのまま使えるかどうかなどといったことは、ほとんど規定されていない。元の値をそのまま保持できるかどうかも分からない。それ故、reinterpret_castは、危険なキャストである。</p>
<p>多くの実装では、reinterpret_castには、何らかの具体的で実用的な意味がある。現実のC++が必要とされる環境では、reinterpret_castを使わなければならないことも、多くある。しかし、reinterpret_castを使った時点で、そのコードは実装依存であり、具体的に意味が定義されたその環境でしか動かないということを、常に意識するべきである。</p>
<p>reinterpret_castでは、constやvolatileを消し去ることはできない。</p>
<p>reinterpret_castでできる変換を、以下に列挙する。</p>
<div class="section" id="id14">
<h4>ポインター型と整数型の間の型変換<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>ある型へのポインター型から整数型へのキャスト、あるいはその逆に、整数型やenum型からポインター型へのキャストを行える。整数型は、ポインターの値をそのまま保持できるほど大きくなければならない。どの整数型ならば十分に大きいのか。もし整数型が十分に大きくなければどうなるのかなどということは、定義されていない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">;</span>

    <span class="c1">// ポインターから整数へのキャスト</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 整数からポインターへのキャスト</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これらのキャストについての挙動は、ほとんどが実装依存であり、あまり説明できることはない。</p>
<p>もし、変換先の整数型が、ポインターの値をすべて表現できるとするならば、再びポインター型にキャストし直した時、ポインターは同じ値を保持すると規定されている。しかし、int型がポインターの値をすべて表現できるという保証はない。unsigned intであろうと、long intであろうとlong long intであろうと、そのような保証はない。従って、上記のコードで、ptrが同じ値を保つかどうかは、実装依存である。</p>
</div>
<div class="section" id="id15">
<h4>異なるポインター型の間の型変換<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>ある型へのポインターは、まったく別の型へのポインターに変換できる。たとえば、int <a href="#id16"><span class="problematic" id="id17">*</span></a>からshort <a href="#id18"><span class="problematic" id="id19">*</span></a>などといった変換ができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">int_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">;</span>

    <span class="c1">// int * からshort *へのキャスト</span>
    <span class="kt">short</span> <span class="o">*</span> <span class="n">short_ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">short</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">int_ptr</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これについても、挙動は実装依存であり、特に説明できることはない。たとえば、上記のコードで、short_ptrを参照した場合どうなるのかということも、全く規定されていない。ある実装では、問題なく、int型のストレージを、あたかもshort型のストレージとして使うことができるかもしれない。ある実装では、参照した瞬間にプログラムがクラッシュするかもしれない。</p>
</div>
<div class="section" id="id20">
<h4>異なるリファレンス型の間の型変換<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<p>異なるポインター型の間の型変換に似ているが、異なるリファレンス型の変換をすることができる。例えば、int &amp;amp;からshort &amp;amp;などといった変換ができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// int &amp; からshort &amp;へのキャスト</span>
    <span class="kt">short</span> <span class="o">&amp;</span> <span class="n">short_ref</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">short</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>異なるポインター型の間の型変換と同じで、これについても、具体的な意味は実装依存である。</p>
</div>
<div class="section" id="id21">
<h4>異なるメンバーポインターの間の型変換<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h4>
<p>異なるメンバーポインターへ変換することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">B</span><span class="o">::*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">B</span><span class="o">::*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">A</span><span class="o">::</span><span class="n">value</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>意味は、実装依存である。</p>
</div>
<div class="section" id="id22">
<h4>異なる関数ポインター型の間の型変換<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h4>
<p>ある関数ポインターは、別の型の関数ポインターにキャストできるかもしれない。意味は実装依存である。「かもしれない」というのは実に曖昧な表現だが、たとえ完全に規格準拠な実装であっても、この機能をサポートする義務がないという意味である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// void (short)な関数へのポインター型</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">short</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 関数ポインターの型変換</span>
    <span class="n">type</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この変換がどういう意味を持つのか。例えば、変換した結果の関数ポインターは、関数呼び出しできるのか。できるとして、一体どういう意味になるのか、などということは一切規定されていない。</p>
</div>
<div class="section" id="id23">
<h4>reinterpret_castには、できないこと<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h4>
<p>reinterpret_castが行えるキャストは、上記にすべて列挙した。それ以外の変換は、reinterpret_castでは行うことができない。これは、そもそもreinterpret_castの目的が、危険で実装依存なキャストのみを分離するという目的にあるので、それ以外の変換は、あえて行えないようになっている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">short</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// OK、標準型変換による暗黙の型変換</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">value</span> <span class="p">;</span>
    <span class="c1">// OK、static_castによる明示的な型変換</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// エラー</span>
    <span class="c1">// reinterpret_castでは、この型変換をサポートしていない</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="const-cast">
<h3>Const cast<a class="headerlink" href="#const-cast" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>const_cast &lt; 型名 &gt; ( 式 )</pre>
</div>
<p>const_castは、constとvolatileが異なる型の間の型変換を行う。constやvolatileを取り除くことや、付け加えることができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// エラー、constを取り除くことはできない。</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">error1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">error2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// OK、ポインターの例</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
    <span class="c1">// OK、リファレンスの例</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// constを付け加えることもできる。</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="n">cptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="k">const</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ポインターへのポインターであっても、それぞれのconstを取り除くことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">c</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">***</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">***&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>const_castは、constやvolatileのみを取り除く、または付け加えるキャストのみを行える。それ以外の型変換を行うことはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="c1">// エラー、const以外の型変換を行っている。</span>
    <span class="kt">short</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">short</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>では、constを取り除くと同時に、他の型変換も行ないたい場合はどうするかというと、static_castや、reinterpret_castを併用する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="kt">short</span> <span class="o">*</span> <span class="n">ptr1</span> <span class="o">=</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">short</span> <span class="o">*&gt;</span><span class="p">(</span>
            <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span>
                <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span> <span class="p">;</span>

    <span class="kt">short</span> <span class="o">*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">short</span> <span class="o">*&gt;</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">))</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>const_castは、基本的に、ほとんどのconstをキャストすることができるが、キャストできないconstも存在する。たとえば、関数ポインターやメンバー関数ポインターに関するconstを取り除くことはできない。関数へのリファレンスも同様である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">type</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span>

    <span class="c1">// エラー、関数ポインターはキャストできない</span>
    <span class="n">type</span> <span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">type</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もちろん、関数の仮引数に対するconstをキャストすることや、constなメンバー関数を非constなメンバー関数にキャストすることなどもできない。</p>
</div>
</div>
<div class="section" id="unary-expressions">
<h2>単項式（Unary expressions）<a class="headerlink" href="#unary-expressions" title="Permalink to this headline">¶</a></h2>
<p>単項式は、オペランドをひとつしか取らないことより、そう呼ばれている。単項式の評価順序はすべて、「右から左」である。</p>
<div class="section" id="unary-operators">
<h3>単項演算子（Unary operators）<a class="headerlink" href="#unary-operators" title="Permalink to this headline">¶</a></h3>
<p>単項演算子というカテゴリーには、五つの異なる演算子がまとめられている。<a href="#id24"><span class="problematic" id="id25">*</span></a>、&amp;amp;、+、-、!、~である。</p>
<ul class="simple">
<li>演算子と&amp; 演算子</li>
</ul>
<hr class="docutils" />
<ul class="simple">
<li>単項演算子は、参照（indirection）である。オペランドは、オブジェクトへのポインターでなければならない。オペランドの型が、「Tへのポインター」であるとすると、式の結果は、lvalueのTである。</li>
</ul>
<p>&amp;amp; 演算子は、オペランドのポインターを得る。オペランドの型がTであるとすると、結果は、prvalueのTへのポインターである。&amp;amp; 演算子は、オブジェクトだけではなく、関数にも適用できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// &amp; 演算子</span>
    <span class="c1">// 変数xのオブジェクトへのポインターを得る。</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span> <span class="p">;</span>

    <span class="c1">// * 演算子</span>
    <span class="c1">// ポインターを参照する</span>
    <span class="o">*</span><span class="n">ptr</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id26">
<h4>単項演算子の+と-<a class="headerlink" href="#id26" title="Permalink to this headline">¶</a></h4>
<p>単項演算子の+と-は、オペランドの符号を指定する演算子である。</p>
<ul class="simple">
<li>単項演算子は、オペランドの値を、そのまま返す。オペランドの型には、数値型、非scoped enum型、ポインター型が使える。結果はprvalueである。</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="o">+</span><span class="mi">0</span> <span class="p">;</span> <span class="c1">// xは0</span>
    <span class="o">+</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// 結果は0</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span>
    <span class="o">+</span><span class="n">ptr</span> <span class="p">;</span> <span class="c1">// 結果はptrの値</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、オペランドには、整数のプロモーションが適用されるので、オペランドの型がcharやshort等の場合、int型になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">short</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="o">+</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// int型の0</span>
</pre></div>
</div>
<ul class="simple">
<li>単項演算子は、オペランドの値を、負数にして返す。オペランドの型には、数値型と非scoped enum型が使える。+ 単項演算子と同じく、オペランドには整数のプロモーションが適用される。</li>
</ul>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">-</span><span class="mi">0</span> <span class="p">;</span> <span class="c1">// 0</span>
<span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="c1">// -1</span>
<span class="o">-</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="c1">// +1</span>
</pre></div>
</div>
<ul class="simple">
<li>単項演算子が、unsignedな整数型に使われた場合の挙動は、明確に定義されている。オペランドのunsignedな整数型のビット数をnとする。式の結果は、2&lt;sup&gt;n&lt;/sup&gt;から、オペランドの値を引いた結果の値になる。</li>
</ul>
<p>具体的な例を挙げるために、今、unsigned int型を16ビットだと仮定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// unsigned int型は16bitであるとする。</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
<span class="c1">// result =</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h4>! 演算子<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>! 演算子は、オペランドをboolに変換し、その否定を返す。つまり、オペランドがtrueの場合はfalseに、falseの場合はtrueになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">!</span><span class="nb">true</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="o">!</span><span class="nb">false</span> <span class="p">;</span> <span class="c1">// true</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="o">!</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// 0はfalseに変換される。その否定なので、結果はtrue</span>
</pre></div>
</div>
</div>
<div class="section" id="id28">
<h4>~ 演算子<a class="headerlink" href="#id28" title="Permalink to this headline">¶</a></h4>
<p>~ 演算子は、ビット反転とも呼ばれている。オペランドには、整数型と非scoped enum型が使える。式の結果は、オペランドの1の補数となる。すなわち、オペランドの各ビットが反転された値となる。オペランドには整数のプロモーションが適用される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="c1">// ビット列の各ビットを反転する</span>
<span class="o">~</span><span class="n">x</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id29">
<h3>インクリメントとデクリメント（Increment and decrement）<a class="headerlink" href="#id29" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>++ 式
-- 式</pre>
</div>
<p>ここでは、前置式のインクリメントとデクリメントについて解説する。&lt;a href=&#8221;#expr.post.incr&#8221;&gt;後置式のインクリメントとデクリメント&lt;/a&gt;も参照。</p>
<p>前置式の++ 演算子は、オペランドに1を加算して、その結果をそのまま返す。オペランドは数値型かポインター型で、変更可能なlvalueでなければならない。式の結果はlvalueになる。</p>
<p>前置式の&#8211; 演算子は、オペランドから1を減算する。それ以外は、++演算子と同じように動く。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">++</span><span class="n">x</span> <span class="p">;</span>
<span class="c1">// ここで、result = 1, x = 1</span>
</pre></div>
</div>
</div>
<div class="section" id="sizeof-sizeof">
<h3>sizeof（Sizeof）<a class="headerlink" href="#sizeof-sizeof" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>sizeof ( 未評価式 )
sizeof ( 型名 )
sizeof ... ( 識別子 )</pre>
</div>
<p>sizeofとは、オペランドを表現するオブジェクトのバイト数を返す演算子である。オペランドは、未評価式か型名になる。</p>
<p>オペランドに型名を指定した場合、sizeof演算子は、型のオブジェクトのバイト数を返す。sizeof(char)、sizeof(signed char)、sizeof(unsigned char)は、1を返す。それ以外のあらゆる型のサイズは、実装によって定義される。たとえば、sizeof(bool)やsizeof(char16_t)やsizeof(char32_t)のサイズも、規格では決められていない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 1</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="p">;</span>
<span class="c1">// int型のオブジェクトのサイズ</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>オペランドに式を指定した場合、その式の結果の型のオブジェクトのバイト数を返す。式は評価されない。&lt;a href=&#8221;#conv.lval&#8221;&gt;lvalueからrvalueへの型変換&lt;/a&gt;、&lt;a href=&#8221;#conv.array&#8221;&gt;配列からポインターへの型変換&lt;/a&gt;、&lt;a href=&#8221;#conv.func&#8221;&gt;関数からポインターへの型変換&lt;/a&gt;は行われない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">;</span>

<span class="c1">// int型のオブジェクトのサイズ</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// int型のオブジェクトのサイズ</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>関数呼び出しの式の結果の型は、関数の戻り値の型になる。</p>
<p>オペランドには、関数と不完全型を使うことはできない。関数は、そもそもオブジェクトではないし、不完全型は、そのサイズを決定できないからだ。「関数」は使えないが、関数呼び出しは「関数」ではないので使える。また、関数ポインターにも使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span> <span class="p">()</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Incomplete</span> <span class="p">;</span>

<span class="c1">// 関数呼び出しは「関数」ではない</span>
<span class="c1">// sizeof(int) と同じ</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// 関数ポインターはオブジェクトであるので、使える</span>
<span class="c1">// sizeof ( int (*)(void) ) と同じ</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">f</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// エラー、関数を使うことはできない</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="n">f</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// エラー、不完全型を使うことはできない</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="n">Incomplete</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>オペランドがリファレンス型の場合、参照される型のオブジェクトのサイズになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">)</span>
<span class="p">{</span>
<span class="c1">// sizeof(int)と同じ</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="p">)</span> <span class="p">;</span>
<span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="p">;</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オペランドがクラス型の場合、クラスのオブジェクトのバイト数になる。これには、アライメントの調整や、配列の要素として使えるようにするための実装依存のパディングなども含まれる。クラス型のサイズは、必ず1以上になる。これは、サイズが0では、ポインターの演算などに差し支えるからである。</p>
<p>オペランドが配列型の場合、配列のバイト数になる。これはつまり、要素の型のサイズ　×　要素数となる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// sizeof(int) * 10 と同じ</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="kt">int</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">)</span> <span class="p">;</span>

<span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
<span class="c1">// sizeof(char) * 10 = 1 * 10 = 10</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// この型は配列ではなく、int</span>
<span class="c1">// sizeof(int)と同じ</span>
<span class="k">sizeof</span><span class="p">(</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>sizeof...は、オブジェクトのバイト数とは、何の関係もない。sizeof...のオペランドには、パラメーターパックの識別子を指定できる。sizeof...演算子は、オペランドのパラメーターパックの引数の数を返す。sizeof...演算子の結果は定数で、型はstd::size_tである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;cstddef&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Types</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">const</span> <span class="n">t</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">const</span> <span class="n">a</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">args</span><span class="p">)</span> <span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 0, 0</span>
    <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 3, 3</span>
    <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 5, 5</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="new">
<h3>new<a class="headerlink" href="#new" title="Permalink to this headline">¶</a></h3>
<p>確保関数と解放関数の具体的な実装方法については、&lt;a href=&#8221;#support.dynamic&#8221;&gt;動的メモリー管理&lt;/a&gt;を参照。</p>
<div class="highlight-c++"><div class="highlight"><pre>
</pre></div>
</div>
<p>newに必要な宣言の一部は、&amp;lt;new&amp;gt;ヘッダーで定義されているので、使う際は、これをincludeしなければならない。</p>
<p>new式は、型名のオブジェクトを生成する。newされる型は、完全型でなければならない。ただし、抽象クラスはnewできない。リファレンスはオブジェクトではないため、newできない。new式の結果は、型が配列以外の場合は、生成されたオブジェクトへのポインターを返す。型が配列の場合は、配列の先頭要素へのポインターを返す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">C</span> <span class="p">{}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// int型のオブジェクトを生成する</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="c1">// C型のオブジェクトを生成する</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">c</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>newが、オブジェクトのためのストレージの確保に失敗した場合、std::bad_alloc例外がthrowされる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// newが失敗した</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>詳細なエラーについては、後述する。</p>
<p>newによって生成されるオブジェクトは、&lt;a href=&#8221;#basic.stc.dynamic&#8221;&gt;動的ストレージの有効期間&lt;/a&gt;を持つ。つまり、newによって作られたオブジェクトを破棄するためには、明示的にdeleteを使わなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span> <span class="c1">// 生成</span>
    <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span> <span class="c1">// 破棄</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id30">
<h4>new式の評価<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h4>
<p>new式に、new初期化子が指定されている場合、その式を評価する。次に、確保関数（allocation function）を呼び出して、オブジェクトの生成に必要なストレージを確保する。初期化を行ない、確保したストレージ上に、オブジェクトを構築する。そして、オブジェクトへのポインターを返す。</p>
</div>
<div class="section" id="id31">
<h4>配列の生成<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h4>
<p>newで配列を生成する場合、要素数は、定数でなくても構わない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 5個のint型の配列を生成する</span>
    <span class="c1">// 要素数は定数</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>

    <span class="c1">// n個のint型の配列を生成する</span>
    <span class="c1">// 要素数は定数ではない</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配列の配列、つまり多次元配列を生成する場合、配列型の最初に指定する要素数は、定数でなくても構わない。残りの要素数は、すべて定数でなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 要素数はすべて定数</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>

    <span class="c1">// OK</span>
    <span class="c1">// 最初の要素数は定数ではない</span>
    <span class="c1">// 残りはすべて定数</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>

    <span class="k">new</span> <span class="kt">int</span> <span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="c1">// 最初の要素数は定数でなくてもよい</span>
            <span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 残りの要素数は定数でなければならない</span>

    <span class="c1">// エラー</span>
    <span class="c1">// 最初以外の要素数が定数ではない</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="p">;</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="p">;</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">5</span><span class="p">][</span><span class="n">n</span><span class="p">][</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配列の要素数が0の場合、newは、0個の配列を生成する。配列の要素数が負数であった場合の挙動は未定義である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// OK</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span>
    <span class="c1">// もちろんdeleteしなければならない</span>
    <span class="k">delete</span> <span class="p">[]</span> <span class="n">ptr</span> <span class="p">;</span>

    <span class="c1">// エラー</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もし、配列型の定数ではない要素数が、実装の制限以上の大きさである場合、ストレージの確保は失敗する。その場合、std::bad_array_new_length例外がthrowされる。要素数が定数であった場合は、通常通り、std::bad_alloc例外がthrowされる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int[n]のストレージを確保できないとする。</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="p">;</span>
        <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 要素数は定数ではない</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_array_new_length</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ストレージを確保できなかった場合</span>
    <span class="p">}</span>

    <span class="n">try</span> <span class="p">{</span>
        <span class="c1">// numeric_limitsのメンバー関数maxはconstexpr関数なので、定数になる。</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="k">const</span> <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="p">;</span>
        <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">;</span><span class="c1">// 要素数は定数</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ストレージを確保できなかった場合</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>要素数が定数でない場合で、ストレージが確保できない場合のみ、std::bad_array_new_lengthがthrowされる。要素数が定数の場合は、通常通り、std::bad_allocがthrowされる。</p>
</div>
<div class="section" id="id32">
<h4>オブジェクトの初期化<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h4>
<p>生成するオブジェクトの初期化は、new初期化子によって指定される。new初期化子とは、( 式リスト )か、初期化リストのいずれかである。new初期化子が指定された場合、オブジェクトは、直接初期化される。new初期化子が省略された場合、デフォルト初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// new初期化子が省略されている</span>
    <span class="c1">// デフォルト初期化</span>
    <span class="k">new</span> <span class="n">C</span> <span class="p">;</span>

    <span class="c1">// 直接初期化</span>
    <span class="k">new</span> <span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">new</span> <span class="n">C</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 初期化リスト</span>
    <span class="k">new</span> <span class="n">C</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="p">;</span>
    <span class="k">new</span> <span class="n">C</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>組み込み型に対するデフォルト初期化は、「初期化しない」という挙動なので、注意を要する。初期化についての詳しい説明は、&lt;a href=&#8221;#dcl.init&#8221;&gt;初期化子&lt;/a&gt;を参照。</p>
</div>
<div class="section" id="auto">
<h4>型名としてのauto<a class="headerlink" href="#auto" title="Permalink to this headline">¶</a></h4>
<p>newの型名がautoの場合、new初期化子は、( 代入式 )の形を取らなければならない。オブジェクトの型は、代入式の結果の型となる。オブジェクトは代入式の結果の値で初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// int型、値は0</span>
    <span class="k">new</span> <span class="k">auto</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// double型、値は0.0</span>
    <span class="k">new</span> <span class="k">auto</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// float型、値は0.0f</span>
    <span class="k">new</span> <span class="k">auto</span><span class="p">(</span> <span class="mf">0.0f</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// int型、値は関数fの戻り値</span>
    <span class="k">new</span> <span class="k">auto</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これは、auto指定子とよく似ている。</p>
</div>
<div class="section" id="placement-new">
<h4>placement new<a class="headerlink" href="#placement-new" title="Permalink to this headline">¶</a></h4>
<p>placement newとは、確保関数に追加の引数を渡すことができるnew式の文法である。これは、対応するnew演算子のオーバーロード関数を呼び出す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">new</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span> <span class="c1">// operator new( sizeof(int), 1 )</span>
    <span class="k">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span> <span class="c1">// operator new( sizeof(int), 1, 2 )</span>
    <span class="k">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span> <span class="c1">// operator new( sizeof(int), 1, 2, 3 )</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、newと型名の間に、通常の関数の実引数のリストのように、追加の引数を指定することができる。追加の引数は、operator newの二番目以降の引数に渡される。placement newの追加の引数は、ストレージを確保する方法を確保関数に指定するなどの用途に使える。</p>
</div>
<div class="section" id="id33">
<h4>特殊なplacement new<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h4>
<p>C++には、あらかじめplacement newが二つ定義されている。operator new(std::size_t, const std::nothrow_t &amp;amp;) throw()と、operator new(std::size_t, void <a href="#id34"><span class="problematic" id="id35">*</span></a>) throw()である。</p>
<p>operator new(std::size_t, const std::nothrow_t &amp;amp;) throw()は、ストレージの確保に失敗しても例外を投げない特別な確保関数である。これには通常、std::nothrowが渡される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// デフォルトで実装により定義される確保関数</span>
<span class="c1">// void * operator new(std::size_t, const std::nothrow_t &amp;) throw() ;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 失敗しても例外を投げない</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">ptr</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// オブジェクトの生成に成功</span>
        <span class="c1">// 参照できる</span>
        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>nothrow版のnew演算子のオーバーロードは、ストレージの確保に失敗しても、例外を投げない。かわりに、nullポインターを返す。これは、newは使いたいが、どうしても例外を使いたくない状況で使うことができる。nothrow版のnewを呼び出した場合は、戻り値がnullポインターであるかどうかを確認しなければならない。</p>
<p>std::nothrow_tは、単にオーバーロード解決のためのタグに過ぎない。また、引数として渡しているstd::nothrowは、単に便利な変数である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 実装例</span>
<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="kt">nothrow_t</span> <span class="p">{}</span> <span class="p">;</span>
    <span class="k">extern</span> <span class="k">const</span> <span class="kt">nothrow_t</span> <span class="n">nothrow</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>operator new(std::size_t, void <a href="#id36"><span class="problematic" id="id37">*</span></a>) throw()は、非常に特別な確保関数である。この形のnew演算子はオーバーロードできない。このnew演算子は、ストレージを確保する代わりに、第二引数に指定されたポインターの指すストレージ上に、オブジェクトを構築する。第二引数のポインターは、オブジェクトの構築に必要なサイズやアライメント要求などの条件を満たしていなければならない。</p>
<p>一般に、placement newといえば、この特別なnew演算子の呼び出しを意味する。ただし、正式なplacement newという用語の意味は、追加の実引数を指定するnew式の文法である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;constructed.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">C</span><span class="p">(){</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;destructed.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ストレージを自前で確保する</span>
    <span class="c1">// operator newの返すストレージは、あらゆるアライメント要求を満たす</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">storage</span> <span class="o">=</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// placement newによって、ストレージ上にオブジェクトを構築</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="n">C</span> <span class="p">;</span>

    <span class="c1">// ストレージの開放の前に、デストラクターを呼び出す</span>
    <span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">C</span><span class="p">()</span> <span class="p">;</span>

    <span class="c1">// ストレージを自前で開放する</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ストレージは自前で確保しなければならないので、通常通りdelete式を使うことはできない。デストラクターを自前で呼び出し、その後に、ストレージを自前で解放しなければならない。</p>
<p>ストレージは、動的ストレージでなくても構わない。ただし、アライメント要求には注意しなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="n">y</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ストレージは自動変数</span>
    <span class="kt">char</span> <span class="n">storage</span> <span class="p">[[</span><span class="n">align</span><span class="p">(</span><span class="n">C</span><span class="p">)]]</span> <span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">C</span><span class="p">)]</span> <span class="p">;</span>

    <span class="c1">// placement newによって、ストレージ上にオブジェクトを構築</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span> <span class="n">storage</span> <span class="p">)</span> <span class="n">C</span> <span class="p">;</span>

    <span class="c1">// デストラクターはtrivialなので呼ぶ必要はない。</span>
    <span class="c1">// ストレージは自動変数なので、開放する必要はない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、sizeof(C)の大きさのchar配列の上にオブジェクトを構築している。アトリビュートを使い、アライメントを指定していることに注意。</p>
<p>このplacement newは、STLのアロケーターを実装するのにも使われている。</p>
</div>
<div class="section" id="id38">
<h4>ストレージの確保に失敗した場合のエラー処理<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h4>
<p>確保関数がストレージの確保に失敗した場合、std::bad_alloc例外がthrowされる。placement newのstd::nothrow_tを引数に取る確保関数の場合は、戻り値のポインターが、nullポインターとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// エラー処理</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span> <span class="n">ptr</span> <span class="o">==</span> <span class="n">nullptr</span> <span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// エラー処理</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id39">
<h4>初期化に失敗した場合のエラー処理<a class="headerlink" href="#id39" title="Permalink to this headline">¶</a></h4>
<p>newが失敗する場合は、二つある。ストレージが確保に失敗した場合と、オブジェクトの初期化に失敗した場合である。</p>
<p>たとえストレージが確保できたとしても、オブジェクトの初期化は、失敗する可能性がある。なぜならば、初期化の際に、コンストラクターが例外を投げるかもしれないからだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 例外を投げるコンストラクターを持つクラス</span>
<span class="k">struct</span> <span class="n">Fail</span>
<span class="p">{</span>
    <span class="n">Fail</span><span class="p">()</span> <span class="p">{</span> <span class="k">throw</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">try</span> <span class="p">{</span>
        <span class="k">new</span> <span class="n">Fail</span> <span class="p">;</span> <span class="c1">// 必ず初期化に失敗する</span>
    <span class="p">}</span> <span class="k">catch</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>コンストラクターが例外を投げた場合、newは、確保したストレージを、対応する解放関数（deallocation function）を呼び出して解放する。そして、コンストラクターの投げた例外を、そのまま外に伝える。</p>
<p>対応する解放関数とは何か。通常は、operator delete(void <a href="#id40"><span class="problematic" id="id41">*</span></a>)である。しかし、placement newを使っている場合は、最初の引数を除く、残りの引数の数と型が一致するoperator deleteになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// placement new</span>
<span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span>
<span class="p">{</span> <span class="k">return</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">;</span> <span class="p">}</span>

<span class="c1">// placement delete</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;placement delete&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 例外を投げるかもしれないクラス</span>
<span class="k">struct</span> <span class="n">Fail</span>
<span class="p">{</span>
    <span class="n">Fail</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 例外を投げる可能性がある</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// コンストラクターが例外を投げた場合、</span>
    <span class="c1">// operator delete( /*ストレージへのポインター*/, 1, 2, 3 )が呼ばれる</span>
    <span class="n">Fail</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="n">Fail</span> <span class="p">;</span>

    <span class="c1">// operator delete(void *)が呼ばれる</span>
    <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初期化が失敗した場合のplacement deleteの呼び出しには、placement newに渡された追加の引数と、全く同じ値が渡される。</p>
<p>なお、delete式は通常通り、operator delete(void <a href="#id42"><span class="problematic" id="id43">*</span></a>)を呼び出す。たとえplacement newで確保したオブジェクトであっても、delete式では対応する解放関数は呼ばれない。あくまで、初期化の際に呼ばれるだけである。また、delete式から、placement deleteを呼び出す文法も存在しない。これは、「newの際に指定した情報を、deleteの際にまで保持しておくのは、ユーザー側にとっても実装側にとっても困難である」という思想に基づく。</p>
</div>
<div class="section" id="id44">
<h4>確保関数の選択<a class="headerlink" href="#id44" title="Permalink to this headline">¶</a></h4>
<p>new式が呼び出す確保関数は、以下の方法で選択される。</p>
<p>生成するクラスのメンバー関数に、operator newのオーバーロードがある場合、メンバー関数が選ばれる。メンバー関数によってオーバーロードされていない場合、グローバルスコープのoperator newが選ばれる。new式が、「::new」で始まる場合、たとえメンバー関数によるオーバーロードがあっても、グローバルスコープのoperator newが選ばれる</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// オーバーロードあり</span>
<span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// オーバーロードなし</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A::operator newが選ばれる</span>
    <span class="k">new</span> <span class="n">A</span> <span class="p">;</span>
    <span class="c1">// ::operator newが選ばれる</span>
    <span class="k">new</span> <span class="n">B</span> <span class="p">;</span>

    <span class="c1">// ::operator newが選ばれる</span>
    <span class="o">::</span><span class="k">new</span> <span class="n">A</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配列の場合も同様である。配列の場合メンバー関数は、配列の要素のクラス型のメンバーから探される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// オーバーロードあり</span>
<span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// オーバーロードなし</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// A::operator new[]が選ばれる</span>
    <span class="k">new</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>
    <span class="c1">// ::operator new[]が選ばれる</span>
    <span class="k">new</span> <span class="n">B1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>

    <span class="c1">// ::operator new[]が選ばれる</span>
    <span class="o">::</span><span class="k">new</span> <span class="n">A</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>placement newの場合、追加の引数が、オーバーロード解決によって考慮され、最も最適なオーバーロード関数が選ばれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="p">)</span> <span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">double</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="p">)</span> <span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">bad_alloc</span> <span class="p">)</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// operator new( std::size_t size, int )</span>
    <span class="k">new</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="c1">// operator new( std::size_t size, double )</span>
    <span class="k">new</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="c1">// operator new( std::size_t size, int, int )</span>
    <span class="k">new</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="kt">int</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="cvnew">
<h4>CV修飾されている型のnew<a class="headerlink" href="#cvnew" title="Permalink to this headline">¶</a></h4>
<p>CV修飾子のある型もnewできる。特に変わることはない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="k">const</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span>
    <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="delete">
<h3>delete<a class="headerlink" href="#delete" title="Permalink to this headline">¶</a></h3>
<p>確保関数と解放関数の具体的な実装方法については、&lt;a href=&#8221;#support.dynamic&#8221;&gt;動的メモリー管理&lt;/a&gt;を参照。</p>
<div class="highlight-c++"><div class="highlight"><pre>
</pre></div>
</div>
<p>new式によって確保したオブジェクトの寿命は、スコープにはとらわれない。オブジェクトを破棄したければ、delete式で解放しなければならない。</p>
<p>deleteのオペランドの値は、new式によって返されたポインターでなければならない。オブジェクトが配列ではない場合は、deleteを、配列の場合は、delete [ ]を使う。delete式の結果の型は、voidである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">array_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>

    <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">array_ptr</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配列であるかどうかで、deleteとdelete[]を使い分けなければならない。これは間違えやすいので注意すること。</p>
<p>deleteのオペランドがクラスのオブジェクトであった場合、非explicitなユーザー定義の変換が定義されている場合、オブジェクトへのポインターに変換される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="k">operator</span> <span class="kt">int</span> <span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="c1">// C::operator int *()を呼び出し、</span>
    <span class="c1">// 戻り値を解放する。</span>
    <span class="k">delete</span> <span class="n">c</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>delete式は、まず、ポインターの指し示すオブジェクトのデストラクターを呼び出す。次に、解放関数を呼び出して、ストレージを開放する。オブジェクトのの指す型が、メンバー関数としてoperator deleteのオーバーロードを持つ場合、メンバー関数が呼ばれる。オーバーロードされたメンバー関数が存在しない場合、グローバルスコープのoperator deleteを呼び出す。delete式が、「::delete」で始まる場合、メンバー関数のオーバーロードの有無にかかわらず、グローバルスコープのoperator deleteを呼び出す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// オーバーロードあり</span>
<span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span> <span class="p">)</span> <span class="k">throw</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// オーバーロードなし</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span> <span class="p">;</span>
    <span class="c1">// A::operator delete(void*)を呼び出す</span>
    <span class="k">delete</span> <span class="n">a</span> <span class="p">;</span>

    <span class="n">B</span> <span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span> <span class="p">;</span>
    <span class="c1">// ::operator delete(void*)を呼び出す</span>
    <span class="k">delete</span> <span class="n">b</span> <span class="p">;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span> <span class="p">;</span>
    <span class="c1">// ::operator delete(void*)を呼び出す</span>
    <span class="o">::</span><span class="k">delete</span> <span class="n">a</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>オブジェクトが、placement newで確保されたとしても、呼び出す解放関数は、必ずoperator delete(void <a href="#id45"><span class="problematic" id="id46">*</span></a>)、もしくはoperator delete[](void <a href="#id47"><span class="problematic" id="id48">*</span></a>)となる。delete式では、placement deleteは呼び出されない。また、delete式には、placement deleteを呼び出すための文法も存在しない。どうしてもplacement deleteを呼び出したい場合は、手動でデストラクターを呼び出し、さらに手動でplacement deleteを呼び出すしかない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// placement delete</span>
<span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="k">throw</span><span class="p">()</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">C</span><span class="p">(){}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">C</span> <span class="p">;</span>

    <span class="c1">// これでは、operator delete( void * )が呼び出される</span>
    <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span>

    <span class="c1">// 疑似デストラクター呼び出し</span>
    <span class="n">ptr</span><span class="o">-&gt;~</span><span class="n">C</span><span class="p">()</span> <span class="p">;</span>
    <span class="c1">// operator deleteの明示的な呼び出し</span>
    <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span> <span class="n">ptr</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="alignof">
<h3>alignof<a class="headerlink" href="#alignof" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>alignof ( 型名 )</pre>
</div>
<p>alignof式は、オペランドの型のアライメント要求を返す。オペランドの型は、完全なオブジェクト型か、その配列もしくはリファレンスでなければならない。式の結果は、std::size_t型の定数になる。</p>
<p>オペランドが、リファレンス型の場合、結果は参照される型のアライメント要求になる。配列の場合、結果は配列の要素の型のアライメント要求になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">c</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">i</span> <span class="p">;</span> <span class="kt">double</span> <span class="n">d</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// char型のアライメント要求を返す</span>
    <span class="n">alignof</span><span class="p">(</span> <span class="kt">char</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// int型のアライメント要求を返す</span>
    <span class="n">alignof</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// double型のアライメント要求を返す</span>
    <span class="n">alignof</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// C型のアライメント要求を返す</span>
    <span class="n">alignof</span><span class="p">(</span> <span class="n">C</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="noexcept-noexcept-operator">
<h3>noexcept演算子（noexcept operator）<a class="headerlink" href="#noexcept-noexcept-operator" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>noexcept ( 未評価式 )</pre>
</div>
<p>noexcept演算子は、オペランドの式が、例外を投げる可能性のある式を含むかどうかを返す。noexcept演算子の結果の型はboolの定数で、例外を投げる可能性のある式を含まない場合trueを、含む場合falseを返す。オペランドの式は、評価されない。</p>
<p>結果がfalseとなる場合、すなわち、例外を投げる可能性のある式とは、以下の通りである。</p>
<p>throw式。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// false</span>
<span class="n">noexcept</span><span class="p">(</span> <span class="k">throw</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>dynamic_cast式、dynamic_cast&amp;lt;T&amp;gt;(v)において、Tがリファレンス型で、実行時チェックが必要な場合。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// false</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">&amp;</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>typeid式において、オペランドがglvalueで、実行時チェックが必要な場合。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">Base</span> <span class="o">*</span> <span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// false</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="k">typeid</span><span class="p">(</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数、メンバー関数、関数ポインター、メンバー関数ポインターを呼び出す式において、呼び出す関数の例外指定が、無例外（non-throwing）であるもの。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">a</span><span class="p">()</span> <span class="p">;</span>
<span class="kt">void</span> <span class="n">b</span><span class="p">()</span> <span class="n">noexcept</span> <span class="p">;</span> <span class="c1">// non-throwing</span>
<span class="kt">void</span> <span class="nf">c</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// non-throwing</span>
<span class="kt">void</span> <span class="nf">d</span><span class="p">()</span> <span class="n">noexcept</span><span class="p">(</span><span class="nb">false</span><span class="p">)</span> <span class="p">;</span>
<span class="kt">void</span> <span class="nf">e</span><span class="p">()</span> <span class="k">throw</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// non-throwing</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="k">throw</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">a</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">b</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">c</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">d</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">e</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数を、「呼び出す式」というのは、関数を間接的に呼び出す場合も該当する。たとえば、new式は確保関数を呼び出すので、関数を呼び出す式である。その場合の結果は、呼び出される確保関数の例外指定に依存する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ::operator new( std::size_t ) throw( std::bad_alloc) を呼び出す</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">noexcept</span><span class="p">(</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>

    <span class="c1">// ::operator new( std::size_t, std::nothrow_t ) throw() を呼び出す</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">noexcept</span><span class="p">(</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">nothrow</span><span class="p">)</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もちろん、演算子のオーバーロード関数も、「関数」である。従って、演算子のオーバーロード関数を呼び出す式は、関数を呼び出す式である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="k">operator</span> <span class="o">+</span><span class="p">(</span> <span class="n">C</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">C</span> <span class="k">operator</span> <span class="o">-</span><span class="p">(</span> <span class="n">C</span> <span class="p">)</span> <span class="n">noexcept</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">i</span> <span class="o">+</span> <span class="n">i</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">c</span> <span class="o">+</span> <span class="n">c</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">c</span> <span class="o">-</span> <span class="n">c</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>その他にも、関数を間接的に呼び出す可能性のある式というのは、非常に多いので、注意しなければならない。</p>
<p>関数のオーバーロード解決は静的に行われるので、当然、呼び出される関数に応じて結果も変わる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">noexcept</span> <span class="p">;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">f</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>例外を投げる可能性のある式を「含む」というのは、たとえその式が絶対に評価されないでも、例外を投げる可能性があるとみなされる。例えば、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">noexcept</span><span class="p">(</span> <span class="nb">true</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">throw</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>このnoexceptのオペランドの式は、もし評価された場合、決して例外を投げることがない。しかし、例外を投げる可能性のある式を含んでいるので、noexceptの結果はfalseとなる。</p>
<p>上記以外の場合、noexceptの結果はtrueとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Base</span> <span class="o">&amp;&gt;</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">noexcept</span><span class="p">(</span> <span class="k">typeid</span><span class="p">(</span> <span class="n">d</span> <span class="p">)</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="explicit-type-conversion-cast-notation">
<h2>キャスト形式による明示的型変換（Explicit type conversion (cast notation)）<a class="headerlink" href="#explicit-type-conversion-cast-notation" title="Permalink to this headline">¶</a></h2>
<p>注意：C形式のキャストには様々な問題があるので、使ってはならない。</p>
<div class="highlight-c++"><pre>( 型名 ) 式</pre>
</div>
<p>これは、悪名高いC形式のキャストである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">i</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C形式のキャストは、static_castとreinterpret_castとconst_castを組み合わせた働きをする。組み合わせは、以下の順序で決定される。</p>
<p>0 const_cast
1 static_cast
2 static_castとconst_cast
3 reinterpret_cast
4 reinterpret_castとconst_cast</p>
<p>上から下に評価していき、変換できる組み合わせが見つかったところで、そのキャストを使って変換する。</p>
<p>ただし、C形式のキャストでは、static_castに特別な変更を三つ加える。クラスのアクセス指定を無視できる機能である。</p>
<blockquote>
<div>派生クラスへのポインターやリファレンスから、基本クラスへのポインターやリファレンスに変換できる。文字通り変換できる。アクセス指定などは考慮されない。</div></blockquote>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>

    <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">ref1</span> <span class="o">=</span> <span class="p">(</span><span class="n">Base</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">d</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">ref2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// ill-formed</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このため、publicではない基本クラスにアクセスできてしまう。</p>
<blockquote>
<div>派生クラスのメンバーへのポインターから、曖昧ではない非virtualな基本クラスのメンバーへのポインターに変換できる。文字通り変換できる。アクセス指定などは考慮されない。</div></blockquote>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">Base</span><span class="o">::*</span> <span class="n">ptr1</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">Base</span><span class="o">::*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">Derived</span><span class="o">::</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="kt">int</span> <span class="n">Base</span><span class="o">::*</span> <span class="n">ptr2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">Base</span><span class="o">::*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Derived</span><span class="o">::</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// ill-formed</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これも、アクセス指定を無視できてしまう。</p>
<blockquote>
<div>曖昧ではなく非virtualな基本クラスのポインターやリファレンスあるいはメンバーへのポインターは、派生クラスのポインターやリファレンスあるいはメンバーへのポインターに変換できる。文字通り変換できる。アクセス指定などは考慮されない。</div></blockquote>
<hr class="docutils" />
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>

    <span class="n">d</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// ill-formed. アクセス指定のため</span>

    <span class="kt">int</span> <span class="n">Derived</span><span class="o">::*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="n">Derived</span><span class="o">::*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">Base</span><span class="o">::</span><span class="n">x</span> <span class="p">;</span> <span class="c1">// well-formed.</span>
    <span class="n">d</span><span class="p">.</span><span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// well-formed. C形式のキャストを使ったため、アクセス指定を無視できている</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C形式のキャストでしかできないキャストとは、クラスのアクセス指定を無視し、しかもクラス階層のナビゲーションを行うキャストのことである。</p>
<p>これらのキャストは、reinterpret_castでもできる。ただし、reinterpret_castは、クラス階層のナビゲーションを行わないので、正しく動かない。static_castは、クラス階層のナビゲーションを行うので、正しく動く。</p>
<p>アクセス指定を無視できるキャストをしなければならない場合というのは、現実には存在しないはずである。アクセス指定を無視するぐらいならば、最初からpublicにしておけばいい。</p>
<p>reinterpret_castは必要である。C++が必要とされる環境では、ポインターの内部的な値を、そのまま別の型のポインターとして使わなければならない場合も存在する。また、既存のCのコードとの互換性のため、const_castも残念ながら必要である。しかし、アクセス指定は、C++に新しく追加された概念であるので、互換性の問題も存在しないし、また、アクセス指定を無視しなければならない場合というのも、全く考えられない。従って、アクセス指定を無視できるという理由で、C形式のキャストを使ってはならない。</p>
<p>そもそも、C形式のキャストは根本的に邪悪であるので、使ってはならない。C形式のキャストの問題点は、できることが多すぎるということだ。安全なキャストも、危険なキャストも、全く同じ文法で行うことができる。C++では、この問題を解決するために、キャストを三つに分けた。static_cast、reinterpret_cast、const_castである。C++では、この新しい形式のキャストを使うべきである。以下にその概要と簡単な使い分けをまとめる。</p>
<p>&lt;a href=&#8221;#expr.static.cast&#8221;&gt;static_cast&lt;/a&gt;は、ほとんどが安全なキャストである。static_castは、型変換を安全にするため、値を変えることもある。値を変更するので、static_castは、クラス階層のナビゲーションを行うことができる。派生クラスと基本クラスとの間のポインターの型変換は、ポインターの内部的な値が変わる可能性があるからだ。ポインターの値は、もとより実装依存であるが、最も多くの環境で再現できるコードは、複数の基本クラスを使うものだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base1</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Base2</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>
    <span class="n">Derived</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">d</span> <span class="p">;</span>

    <span class="c1">// 基本クラスへのキャスト</span>
    <span class="n">Base1</span> <span class="o">*</span> <span class="n">base1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base1</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">ptr</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">Base2</span> <span class="o">*</span> <span class="n">base2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Base2</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">ptr</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 派生クラスへのキャスト</span>
    <span class="n">Derived</span> <span class="o">*</span> <span class="n">d1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">base1</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">Derived</span> <span class="o">*</span> <span class="n">d2</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Derived</span> <span class="o">*&gt;</span><span class="p">(</span> <span class="n">base2</span> <span class="p">)</span> <span class="p">;</span>


    <span class="c1">// 派生クラスのポインターの値</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span> <span class="s">&quot;Derived *: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 基本クラスのポインターの値は同じか？</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span> <span class="s">&quot;Base1 *: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base1</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span> <span class="s">&quot;Base2 *: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">base2</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 派生クラスに戻した場合はどうか？</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span> <span class="s">&quot;from Base1 * to Derived *: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d1</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">printf</span><span class="p">(</span> <span class="s">&quot;from Base1 * to Derived *: %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">d2</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>複数の基本クラスの場合、基本クラスのサブオブジェクトが複数あるので、派生クラスと基本クラスのポインターの間で、同じ値を使うことができない。従って、基本クラスへのポインターにキャストするには、ストレージ上の、その基本クラスのサブオブジェクトを指すポインターを返さなければならない。また、派生クラスへのポインターにキャストするには、値を戻さなければならない。</p>
<p>このため、クラス階層のナビゲーションには、static_castかdynamic_castを用いなければならない。</p>
<p>&lt;a href=&#8221;#expr.reinterpret.cast&#8221;&gt;reinterpret_cast&lt;/a&gt;は、危険で愚直なキャストである。reinterpret_castは、値を変えない。ただ、その値の型だけを変更する。reinterpret_castは、クラス階層のナビゲーションができない。</p>
<p>&lt;a href=&#8221;#expr.const.cast&#8221;&gt;const_cast&lt;/a&gt;は、CV修飾子を外すキャストである。</p>
<p>もし、どのキャストを使うべきなのか判断できない場合は、まずstatic_castを使っておけば問題はない。もし、static_castが失敗した場合、本当にそのキャストは安全なのかということを確かめてから、reinterpret_castを使うべきである。const_castは、既存のCのコードの利用以外に使ってはならない。</p>
</div>
<div class="section" id="pointer-to-member-operators">
<h2>メンバーへのポインター演算子（Pointer-to-member operators）<a class="headerlink" href="#pointer-to-member-operators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 .* 式
式 -&gt;* 式</pre>
</div>
<p>メンバーへのポインター演算子は、「左から右」に評価される。</p>
<p>メンバーへのポインター演算子は、クラスのメンバーへのポインターを使って、クラスのオブジェクトのメンバーにアクセスするための演算子である。クラスのメンバーへのポインターを参照するためには、参照するクラスのオブジェクトが必要である。</p>
<p>.*演算子の第一オペランドには、クラスのオブジェクトを指定する。-&amp;gt;*演算子の第一オペランドには、クラスへのポインターを指定する。第二オペランドには、クラスのメンバーへのポインターを指定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">member</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">C</span><span class="o">::*</span> <span class="n">mem_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span>

    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="n">c</span><span class="p">.</span><span class="o">*</span><span class="n">mem_ptr</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span> <span class="p">;</span>
    <span class="n">ptr</span><span class="o">-&gt;*</span><span class="n">mem_ptr</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>メンバー関数の呼び出しの際は、演算子の優先順位に気をつけなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">member</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="n">C</span><span class="o">::*</span> <span class="n">mem_ptr</span><span class="p">)()</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">C</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span>

    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="o">*</span><span class="n">mem_ptr</span><span class="p">)()</span> <span class="p">;</span>

    <span class="n">C</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span> <span class="p">;</span>
    <span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;*</span><span class="n">mem_ptr</span><span class="p">)()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>なぜならば、メンバーへのポインター演算子の式より、関数呼び出し式の優先順位の方が高いので、c.*mem_ptr()という式は、c.*( mem_ptr() )という式に解釈されてしまう。これは、mem_ptrという名前に対して、関数呼び出し式を適用した後、その結果を、クラスのメンバーへのポインターとして使う式である。このように解釈されることを避けるために、括弧式を使わなければならない。</p>
<p>その他の細かいルールについては、&lt;a href=&#8221;#expr.ref&#8221;&gt;クラスメンバーアクセス&lt;/a&gt;と同じである。</p>
</div>
<div class="section" id="multiplicative-operators">
<h2>乗除算の演算子（Multiplicative operators）<a class="headerlink" href="#multiplicative-operators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 * 式
式 / 式
式 % 式</pre>
</div>
<p>乗除算の演算子は、「左から右」に評価される</p>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>演算子と/演算子のオペランドは、数値型かunscoped enum型でなければならない。%演算子のオペランドは、整数型かunscoped enum型でなければならない。オペランドには、通常通り数値に関する標準型変換が適用される。&lt;a href=&#8221;#expr&#8221;&gt;式&lt;/a&gt;を参照。</p>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>演算子は、乗算を意味する。</p>
<p>/演算子は、除算を意味する。%演算子は、第一オペランドを第二オペランドで割った余りを意味する。第二オペランドの値が0の場合の挙動は未定義である。/演算子の結果の型が整数の場合、小数部分は切り捨てられる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="mi">2</span> <span class="o">*</span> <span class="mi">3</span> <span class="p">;</span> <span class="c1">// 6</span>
    <span class="mi">10</span> <span class="o">/</span> <span class="mi">5</span> <span class="p">;</span> <span class="c1">// 2</span>
    <span class="mi">3</span> <span class="o">%</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 1</span>

    <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 結果は整数型、小数部分が切り捨てられるので、結果は1</span>

    <span class="mf">3.0</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="p">;</span> <span class="c1">// 結果は浮動小数点数型の1.5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下は間違っている例である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// このコードは間違っている例</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// ゼロ除算</span>
    <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// %演算子のオペランドに浮動小数点数型は使えない</span>
    <span class="mf">3.0</span> <span class="o">%</span> <span class="mf">2.0</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="additive-operators">
<h2>加減算の演算子（Additive operators）<a class="headerlink" href="#additive-operators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 + 式
式 - 式</pre>
</div>
<p>加減算の演算子は、「左から右」に評価される。</p>
<div class="section" id="id53">
<h3>両方のオペランドが数値型の場合<a class="headerlink" href="#id53" title="Permalink to this headline">¶</a></h3>
<p>+演算子は、加算を意味する。-演算子は、減算を意味する。-演算子の減算とは、第二オペランドの値を第一オペランドから引くことである。結果の型には、通常通り数値型に関する標準型変換が行われる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 2</span>
    <span class="mi">1</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 0</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id54">
<h3>オペランドがポインター型の場合<a class="headerlink" href="#id54" title="Permalink to this headline">¶</a></h3>
<p>まず、ポインターの型は、完全に定義されたオブジェクトでなければならない。ポインターは、配列の要素を指し示しているものとみなされる。たとえ実際には配列の要素を差していないとしても、配列の要素を指しているものとみなされる。</p>
<p>+演算子の片方のオペランドがポインター型の場合、もう片方は、整数型でなければならない。-演算子は、両方のオペランドが同じポインター型か、左オペランドがポインター型で右オペランドが整数型でなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>

    <span class="c1">// OK</span>
    <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
    <span class="mi">1</span> <span class="o">+</span> <span class="n">ptr</span> <span class="p">;</span>
    <span class="n">ptr</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span>
    <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">ptr</span> <span class="p">;</span>
    <span class="n">ptr</span> <span class="o">-</span> <span class="n">ptr</span> <span class="p">;</span>
    <span class="n">ptr</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span>
    <span class="n">ptr</span> <span class="o">-</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// エラー</span>
    <span class="n">ptr</span> <span class="o">+</span> <span class="n">ptr</span> <span class="p">;</span> <span class="c1">// +演算子の両オペランドがポインターとなっている</span>
    <span class="mi">1</span> <span class="o">-</span> <span class="n">ptr</span> <span class="p">;</span> <span class="c1">// -演算子の左オペランドが整数で右オペランドがポインターとなっている</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ポインターと整数の加減算の結果の型は、ポインターの型である。結果の値は、ポインターが指す要素に対する配列中の添字に、整数を加減算した要素を指すものとなる。もし、ポインターが配列の添字でi番目の要素を指し示している場合、このポインターに整数nを加算することは、i + n番目の要素を指し示すことになる。同様にして、整数nを減算することは、i - n番目の要素を指し示すことになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>

    <span class="n">ptr</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// &amp;array[5 + 2]と同じ</span>
    <span class="n">ptr</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// &amp;array[5 - 2]と同じ</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もし、ポインターが、配列の最後の要素を指している場合、これに1を加えると、結果のポインターは配列の最後の要素のひとつ後ろを指すことになる。ポインターが配列の最後の要素のひとつ後ろを指している場合、これから1を引くと、結果のポインターは配列の最後の要素を指すことになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
    <span class="c1">// 配列の最後の要素を指す</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="p">;</span>

    <span class="c1">// 配列の最後の要素のひとつ後ろを指す</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">one_past_the_last</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span>
    <span class="c1">// 配列の最後の要素を指す</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">last</span> <span class="o">=</span> <span class="n">one_past_the_last</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配列の最後の要素を指しているポインターに1を加算して、最後の要素の一つ後の要素を指すようにしても、規格上、ポインターの値のオーバーフローは起こらないと保証されている。2つ目以降の要素を指し示した場合、挙動は未定義である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 最後の要素</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// OK、最後の一つ後の要素</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 挙動は未定義</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上の例で、もし、ポインターp2を参照した場合、挙動は未定義だが、p2自体は未定義ではない。p3は未定義である。</p>
<p>ポインター同士を減算した場合、結果は、ポインターの指す配列の添字の差になる。ポインターPが配列の添字でi番目の要素を差しており、ポインターQが配列の添字でj番目の要素を指している場合、P - Qは、i - jとなる。配列の添字は、0から始まることに注意。両方のポインターが同じ配列上の要素を差していない場合、挙動は未定義である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">P</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">Q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="p">;</span>

    <span class="n">P</span> <span class="o">-</span> <span class="n">Q</span> <span class="p">;</span> <span class="c1">// 2 - 7 = -5</span>
    <span class="n">Q</span> <span class="o">-</span> <span class="n">P</span> <span class="p">;</span> <span class="c1">// 7 - 2 = 5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ポインター同士の減算の結果の型は、実装依存であるが、&amp;lt;cstddef&amp;gt;ヘッダーで定義されている、std::ptrdiff_tと同じ型になる。</p>
<p>0という値が、ポインターに足し引きされた場合、結果は、そのポインターの値になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ptr</span> <span class="o">==</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">ptr</span> <span class="o">==</span> <span class="n">ptr</span> <span class="o">-</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="shift-operators">
<h2>シフト演算子（Shift operators）<a class="headerlink" href="#shift-operators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 &lt;&lt; 式
式 &gt;&gt; 式</pre>
</div>
<p>シフト演算子のオペランドは、整数型かunscoped enum型でなければならない。オペランドには、整数のプロモーションが行われる。結果の型は、整数のプロモーションが行われた後のオペランドの型になる。</p>
<p>左シフト、E1 &amp;lt;&amp;lt; E2の結果は、E1をE2ビット、左にシフトしたものとなる。シフトされた後のビットは、0で埋められる。もし、E1の型がunsignedならば、結果の値は、E1 × 2&lt;sup&gt;E2&lt;/sup&gt;を、E1の最大値+1で剰余したものとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// コメント内の値は2進数である。</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 1101</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">9</span> <span class="p">;</span>

    <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 11010</span>
    <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 110100</span>
<span class="p">}</span>
</pre></div>
</div>
<p>E1の型がsignedの場合、E1が負数でなく、E1 × 2&lt;sup&gt;E2&lt;/sup&gt;が表現可能であれば、その値になる。その他の場合は未定義である。これは、signedな整数型の内部表現が2の補数であるとは保証していないので、このようになっている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// コメント内の値は2進数である</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 1101</span>
    <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">9</span> <span class="p">;</span>

    <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 11010</span>
    <span class="n">bits</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 110100</span>

    <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 結果は未定義</span>
<span class="p">}</span>
</pre></div>
</div>
<p>右シフト、E1 &amp;gt;&amp;gt; E2の結果は、E1をE2ビット、右にシフトしたものとなる。もし、E1の型がunsignedか、signedで正の数ならば、結果の値は、E1 ÷ 2&lt;sup&gt;E2&lt;/sup&gt;の整数部分になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// コメント内の値は2進数である</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 1101</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">9</span> <span class="p">;</span>

    <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 110</span>
    <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 11</span>

    <span class="kt">int</span> <span class="n">signed_value</span> <span class="o">=</span> <span class="mi">9</span> <span class="p">;</span>

    <span class="n">signed_value</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 110</span>
    <span class="n">signed_value</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 11</span>
<span class="p">}</span>
</pre></div>
</div>
<p>E1の型がsignedで、値が負数の場合、挙動は未定義である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="o">-</span><span class="mi">1</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// 結果は未定義</span>
<span class="p">}</span>
</pre></div>
</div>
<p>右オペランドの値が負数であったり、整数のプローモーション後の左オペランドのビット数以上の場合の挙動は未定義である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// この環境では、1バイトは8ビット</span>
<span class="c1">// sizeof(unsigned int)は2とする。</span>
<span class="c1">// すなわち、この環境では、unsigned intは16ビットとなる。</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>
    <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="c1">// 未定義</span>
    <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="o">-</span><span class="mi">1</span> <span class="p">;</span> <span class="c1">// 未定義</span>

    <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span> <span class="p">;</span> <span class="c1">// 未定義</span>
    <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span> <span class="p">;</span> <span class="c1">// 未定義</span>

    <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="mi">17</span> <span class="p">;</span> <span class="c1">// 未定義</span>
    <span class="n">value</span> <span class="o">&gt;&gt;</span> <span class="mi">17</span> <span class="p">;</span> <span class="c1">// 未定義</span>
<span class="p">}</span>
</pre></div>
</div>
<p>シフト演算には、未定義の部分が非常に多い。ただし、多くの現実の環境では、何らかの具体的な意味が定義されていて、時として、そのような未定義の挙動に依存したコードを書かなければならない場合がある。その場合、特定の環境に依存したコードだという正しい認識を持たなければならない。</p>
</div>
<div class="section" id="relational-operators">
<h2>関係演算子（Relational operators）<a class="headerlink" href="#relational-operators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 &lt; 式
式 &gt; 式
式 &lt;= 式
式 &gt;= 式</pre>
</div>
<p>関係演算子は「左から右」に評価される。</p>
<p>関係演算子のオペランドには、数値型、enum型、ポインター型を使うことができる。各演算子の意味は、以下のようになっている。</p>
<dl class="docutils">
<dt>A &lt; B</dt>
<dd>AはBより小さい</dd>
<dt>A &gt; B</dt>
<dd>AはBより大きい</dd>
<dt>A &lt;= B</dt>
<dd>AはBより小さいか、等しい</dd>
<dt>A &gt;= B</dt>
<dd>AはBより大きいか、等しい</dd>
</dl>
<p>結果の型はboolとなる。両オペランドが数値型かenum型の場合、不等号の関係が正しければtrueを、そうでなければfalseを返す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="p">;</span>
    <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span>
    <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="p">;</span>
    <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>式の結果の型はboolである。</p>
<p>ポインター同士の比較に関しては、未規定な部分が多い。ここでは、規格により保証されていることだけを説明する。</p>
<p>同じ型の二つのポインター、pとqが、同じオブジェクトか関数を指している場合、もしくは、配列の最後の要素のひとつ後の要素を指している場合、もしくは、両方ともnullの場合は、p&amp;lt;=qとp&amp;gt;=qhはtrueとなり、p&amp;lt;qとp&amp;gt;qはfalseとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object</span> <span class="p">;</span>

    <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">p</span> <span class="o">&gt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同じ型の二つのポインター、pとqが、異なるオブジェクトを差しており、そのオブジェクトは同じオブジェクトのメンバーではなく、また同じ配列内の要素ではなく、異なる関数でもなく、あるいは、どちらか片方の値のみがnullの場合、p&amp;lt;q, p&amp;gt;q, p&amp;lt;=q, p&amp;gt;=qの結果は、未規定である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">object1</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">object2</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object1</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object2</span> <span class="p">;</span>

    <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// 結果は未規定</span>
    <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// 結果は未規定</span>

    <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// 結果は未規定</span>
    <span class="n">p</span> <span class="o">&gt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// 結果は未規定</span>

    <span class="n">p</span> <span class="o">&lt;</span> <span class="n">nullptr</span> <span class="p">;</span> <span class="c1">// 結果は未規定</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同じ型の二つのポインター、pとqが、同じ配列の要素を指している場合、添字の大きい要素の方が、より大きいと評価される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>

    <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">p</span> <span class="o">&gt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>

    <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>これと同様に、pとqが指しているものが、同じ型の同じクラスのオブジェクトのサブオブジェクトである場合は、同じアクセスコントロール化にある場合、後に宣言されたメンバーの方が、ポインター同士の比較演算では、大きいと評価される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
<span class="c1">// 同じアクセスコントロール下</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// bが後に宣言されている</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">object</span> <span class="p">;</span>
    <span class="c1">// 同じオブジェクトのサブオブジェクト</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">.</span><span class="n">a</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">.</span><span class="n">b</span> <span class="p">;</span>

    <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">p</span> <span class="o">&gt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>これと似ているが、ただしクラスのメンバーのアクセスコントロールが異なる場合、結果は未規定である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="p">;</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="p">;</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="o">&amp;</span><span class="n">a</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">b</span> <span class="p">;</span> <span class="c1">// 結果は未規定</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>二つのポインター、pとqが、unionの同じオブジェクトの非staticなデータメンバーを指している場合、等しいと評価される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">union</span> <span class="n">Object</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Object</span> <span class="n">object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">.</span><span class="n">x</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object</span><span class="p">.</span><span class="n">y</span> <span class="p">;</span>

    <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">p</span> <span class="o">&gt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>

    <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="n">p</span> <span class="o">==</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>二つのポインターが、同じ配列内の要素を指している場合、添字の大きい要素を指すポインターのが、大きいと評価される。また、これはどちらか片方のポインターが、配列の範囲を超えていても、評価できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span>

    <span class="n">p1</span> <span class="o">&lt;</span> <span class="n">p2</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// p3は配列の範囲外を指す</span>

    <span class="n">p1</span> <span class="o">&lt;</span> <span class="n">p3</span> <span class="p">;</span> <span class="c1">// OK、結果はtrue</span>
<span class="p">}</span>
</pre></div>
</div>
<p>voidへのポインター型は、比較することができる。また、片方のオペランドがvoidへのポインター型で、もう片方が別のポインター型である場合、もう片方のオペランドが、標準型変換によってvoidへのポインター型に変換されるので、比較することができる。もし、両方のポインターが、同じアドレスであった場合かnullポインターの場合は、等しいと評価される。それ以外は、未規定である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">object</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">ptr</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span> <span class="n">q</span> <span class="o">=</span> <span class="n">ptr</span> <span class="p">;</span>

    <span class="n">p</span> <span class="o">&lt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">p</span> <span class="o">&gt;</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// false</span>

    <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">p</span> <span class="o">&gt;=</span> <span class="n">q</span> <span class="p">;</span> <span class="c1">// true</span>

    <span class="c1">// 標準型変換によって、別のポインター型とも比較できる</span>
    <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">ptr</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これ以外の比較の結果は、すべて未規定となっている。未定義ではなく、未規定なので、実装によっては、意味のある結果を返すこともある。しかし、実装に依存する挙動なので、移植性に欠ける。</p>
</div>
<div class="section" id="equality-operators">
<h2>等価演算子（Equality operators）<a class="headerlink" href="#equality-operators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 == 式
式 != 式</pre>
</div>
<p>==演算子（等しい）と、!=演算子（等しくない）は、&lt;a href=&#8221;#expr.rel&#8221;&gt;関係演算子&lt;/a&gt;とオペランドや結果の型、評価の方法は同じである。ただし比較の意味は、「等しい」か、「等しくない」かである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="mi">1</span> <span class="o">!=</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// false</span>

    <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="mi">1</span> <span class="o">!=</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
<p>同じ型のポインターの場合、ともにアドレスが同じか、ともにnullポインターの場合、trueと評価される。</p>
<p>==演算子は、代入演算子である=演算子と間違えやすいので、注意しなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">)</span> <span class="c1">// 間違い</span>
    <span class="p">{</span>
        <span class="c1">// 処理</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 処理</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、if文の条件式の結果は、代入式の結果となってしまう。それは、1であるので、このif文は常にtrueであると評価されてしまう。</p>
</div>
<div class="section" id="bitwise-and-operator">
<h2>ビット列論理積演算子（Bitwise AND operator）<a class="headerlink" href="#bitwise-and-operator" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 &amp; 式</pre>
</div>
<p>ビット列論理積演算子は、両オペランドの各ビットごとの論理積（AND）を返す。オペランドは整数型か、unscoped enum型でなければならない。</p>
</div>
<div class="section" id="bitwise-exclusive-or-operator">
<h2>ビット列排他的論理和演算子（Bitwise exclusive OR operator）<a class="headerlink" href="#bitwise-exclusive-or-operator" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 ^ 式</pre>
</div>
<p>ビット列排他的論理和演算子は、両オペランドの各ビットごとの排他的論理和（exclusive OR）を返す。オペランドは整数型か、unscoped enum型でなければならない。</p>
</div>
<div class="section" id="bitwise-inclusive-or-operator">
<h2>ビット列論理和演算子（Bitwise inclusive OR operator）<a class="headerlink" href="#bitwise-inclusive-or-operator" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 | 式</pre>
</div>
<p>ビット列論理和演算子は、両オペランドの各ビットごとの論理和（inclusive OR）を返す。オペランドは整数型か、unscoped enum型でなければならない。</p>
</div>
<div class="section" id="logical-and-operator">
<h2>論理積演算子（Logical AND operator）<a class="headerlink" href="#logical-and-operator" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 &amp;&amp; 式</pre>
</div>
<p>&amp;amp;&amp;amp;演算子は「左から右」に評価される。</p>
<p>論理積演算子は、オペランドの論理積を返す演算子である。両オペランドはboolに変換される。結果の型はboolである。両方のオペランドがtrueであれば、結果はtrue。それ以外はfalseとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="nb">true</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="nb">true</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="nb">true</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="nb">false</span> <span class="p">;</span> <span class="c1">// false</span>
</pre></div>
</div>
<p>第一オペランドを評価した結果がfalseの場合、第二オペランドは評価されない。なぜならば、第一オペランドがfalseであれば、第二オペランドを評価するまでもなく、結果はfalseであると決定できるからである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// g()は呼ばれない。結果はfalse</span>
    <span class="n">f</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、第一オペランドである関数fの呼び出しはfalseを返すので、第二オペランドの関数gの呼び出しが評価されることはない。つまり、関数gは呼ばれない。</p>
<p>第二オペランドが評価される時、第一オペランドの評価によって生じた値の計算や副作用は、すべて行われている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="o">++</span><span class="n">value</span> <span class="c1">// 値は1になるので、trueと評価される</span>
        <span class="o">&amp;&amp;</span>
    <span class="n">value</span> <span class="p">;</span> <span class="c1">// 値はすでに1となっているので、trueと評価される</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="logical-or-operator">
<h2>論理和演算子（Logical OR operator）<a class="headerlink" href="#logical-or-operator" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 || 式</pre>
</div>
<p>||演算子は、「左から右」に評価される。</p>
<p>論理和演算子は、オペランドの論理和を返す演算子である。両オペランドはboolに変換される。結果の型はboolである。オペランドが片方でもtrueと評価される場合、結果はtrueとなる。両オペランドがfalseの場合に、結果はfalseとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">true</span> <span class="o">||</span> <span class="nb">true</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="nb">true</span> <span class="o">||</span> <span class="nb">false</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="nb">false</span> <span class="o">||</span> <span class="nb">true</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="nb">false</span> <span class="o">||</span> <span class="nb">false</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>第一オペランドを評価した結果がtrueの場合、第二オペランドは評価されない。なぜならば、第一オペランドがtrueであれば、第二オペランドを評価するまでもなく、結果はtrueとなるからである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">bool</span> <span class="nf">g</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// g()は呼ばれない。結果はtrue</span>
    <span class="n">f</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>論理積と同じように、第二オペランドが評価される場合、第一オペランドの評価によって生じた値の計算や副作用は、すべて行われている。</p>
</div>
<div class="section" id="conditional-operator">
<h2>条件演算子（Conditional operator）<a class="headerlink" href="#conditional-operator" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 ? 式 : 代入式</pre>
</div>
<p>条件演算子は「左から右」に評価される。</p>
<p>条件演算子は、三つのオペランドを取る。C++には他に三つのオペランドを取る演算子がないことから、三項演算子といえば、条件演算子の代名詞のように使われている。しかし、正式名称は条件式であり、演算子の名称は条件演算子である。</p>
<p>条件演算子の第一オペランドはboolに変換される。値がtrueであれば、第二オペランドの式が評価され、その結果が返される。値がfalseであれば、第三オペランドの式が評価され、その結果が返される。第二オペランドと第三オペランドは、どちらか片方しか評価されない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">cond</span><span class="p">()</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">e1</span><span class="p">()</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">e2</span><span class="p">()</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">true</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 1</span>
    <span class="nb">false</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 2</span>

    <span class="c1">// 関数condの戻り値によって、関数e1、あるいはe2が呼ばれ、その戻り値が返される。</span>
    <span class="c1">// e1とe2は、どちらか片方しか呼ばれない。</span>
    <span class="n">cond</span><span class="p">()</span> <span class="o">?</span> <span class="n">e1</span><span class="p">()</span> <span class="o">:</span> <span class="n">e2</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>実は、条件演算子は見た目ほど簡単ではない。特に、結果の型をどのようにして決定するかということが、非常に難しい。ここでは、結果の型を決定する完全な詳細は説明しないが、特に重要だと思われる事を取りあげる。</p>
<p>条件演算子の第二第三オペランドには、結果がvoid型となる式を使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">true</span> <span class="o">?</span> <span class="n">f</span><span class="p">()</span> <span class="o">:</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="nb">true</span> <span class="o">?</span> <span class="k">delete</span> <span class="n">ptr</span> <span class="o">:</span> <span class="k">delete</span> <span class="n">ptr</span> <span class="p">;</span>

    <span class="nb">true</span> <span class="o">?</span> <span class="k">throw</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">throw</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>片方のオペランドがvoidで、もう片方がvoidではない場合、エラーである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="nb">true</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="nb">true</span> <span class="o">?</span> <span class="n">f</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、片方のオペランドがthrow式の場合に限り、もう片方のオペランドに、voidではない式を使うことができる。もう片方のオペランドがvoid型の場合はエラーとなる。結果はprvalueの値で、型はvoidではない式の型になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// OK</span>
    <span class="c1">// xに0を代入する</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="nb">true</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="k">throw</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// エラー</span>
    <span class="c1">// 戻り値に123を代入しようとしているが、prvalueには代入できない</span>
    <span class="p">(</span><span class="nb">true</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="k">throw</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mi">123</span> <span class="p">;</span>

    <span class="nb">true</span> <span class="o">?</span> <span class="k">throw</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>両オペランドが、ともに同じ値カテゴリーで、同じ型の場合は、条件演算子の結果は、その値カテゴリーと型になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// 両オペランドとも、lvalueのint型</span>
    <span class="c1">// 結果はlvalueのint</span>
    <span class="p">(</span> <span class="nb">true</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">x</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// lvalueなので代入も可能</span>

    <span class="c1">// 両オペランドとも、xvalueのint型</span>
    <span class="c1">// 結果はxvalueのint</span>
    <span class="nb">true</span> <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">;</span>

    <span class="c1">// 両オペランドとも、prvalueのint型</span>
    <span class="c1">// 結果はprvalueのint</span>
    <span class="nb">true</span> <span class="o">?</span> <span class="n">f</span><span class="p">()</span> <span class="o">:</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もし、オペランドの値カテゴリーや型が違う場合、暗黙の型変換によって、お互いの型と値カテゴリーを一致させようという試みがなされる。この変換の詳細は、非常に複雑で、通常は意識する必要はないため、本書では省略する。</p>
</div>
<div class="section" id="assignment-and-compound-assignment-operators">
<h2>代入と複合代入演算子（Assignment and compound assignment operators）<a class="headerlink" href="#assignment-and-compound-assignment-operators" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><div class="highlight"><pre>
</pre></div>
</div>
<p>代入演算子（=）と、複合代入演算子は、「右から左」に評価される。</p>
<p>代入演算子は、左側のオペランドに、右側のオペランドの値を代入する。左側のオペランドは変更可能なlvalueでなければならない。結果として、左側のオペランドのlvalueを返す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初期化と混同しないように注意。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// これは初期化</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// これは代入</span>
<span class="p">}</span>
</pre></div>
</div>
<p>=を代入演算子といい、その他の演算子を、複合代入演算子という。</p>
<p>クラスの代入に関する詳細は、&lt;a href=&#8221;#class.copy&#8221;&gt;クラスオブジェクトのコピーとムーブ&lt;/a&gt;や、オーバーロードの&lt;a href=&#8221;#over.ass&#8221;&gt;代入&lt;/a&gt;を参照。</p>
<p>複合代入演算子の式、E1 op = E2は、E1 = E1 op E2と同じである。ただし、E1という式は、一度しか評価されない。opには、任意の複合代入演算子の一部が入る。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span> <span class="p">;</span> <span class="c1">// x = x + 1と同じ</span>
    <span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// x = x * 2と同じ</span>
<span class="p">}</span>
</pre></div>
</div>
<p>右側のオペランドには、初期化リストを使うことができる。</p>
<p>左側のオペランドがスカラー型の場合、ある型Tの変数をxとすると、x = {v}という式は、x = T(v)という式と同じ意味になる。ただし、初期化リストなので、縮小変換は禁止されている。x = {}という式は、x = T()という式と同じ意味になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="p">;</span> <span class="c1">// x = int(1) と同じ</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">{}</span> <span class="p">;</span> <span class="c1">// x = int()と同じ</span>
    <span class="kt">short</span> <span class="n">s</span> <span class="p">;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、縮小変換は禁止されている。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>それ以外の場合は、初期化リストを実引数として、ユーザー定義の代入演算子が呼び出される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">(){}</span>
    <span class="n">C</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="comma-operator">
<h2>コンマ演算子（Comma operator）<a class="headerlink" href="#comma-operator" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>式 , 式</pre>
</div>
<p>コンマ演算子は、「左から右」に評価される。</p>
<p>コンマ演算子は、まず左のオペランドの式が評価され、次に、右のオペランドの式が評価される。左のオペランドの式を評価した結果は破棄され、右のオペランドの結果が、コンマ演算子の結果として、そのまま返される。結果の型や値、値カテゴリーは、右のオペランドの式を評価した結果と全くおなじになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">;</span> <span class="c1">// 2</span>
    <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">;</span> <span class="c1">// 5</span>
<span class="p">}</span>
</pre></div>
</div>
<p>右のオペランドの式が評価される前に、左のオペランドの式の値計算や副作用は、すでに行われている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">g</span><span class="p">()</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="c1">// 左のオペランドのiは、すでにインクリメントされている。</span>
    <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="p">;</span>
    <span class="c1">// 関数gが呼ばれる前に、関数fはすでに呼ばれ終わっている。</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">,</span> <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>コンマが特別な意味を持つ場面では、コンマ演算子を使うには、明示的に括弧で囲まなければならない。コンマが特別な意味を持つ場面には、例えば、関数の実引数リストや、初期化リストなどがある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="c1">// 括弧が必要</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、関数fは三つの引数を取る。二つめの引数は、括弧式に囲まれたコンマ演算子の式である。これは変数xに0を代入した後、そのxを引数として渡している。</p>
</div>
<div class="section" id="constant-expressions">
<h2>定数式（Constant expressions）<a class="headerlink" href="#constant-expressions" title="Permalink to this headline">¶</a></h2>
<p>定数式（constant expression）とは、値がコンパイル時に決定できる式のことである。定数式かどうかということは、C++のいくつかの場面で、重要になってくる。例えば、配列を宣言する時、要素数は定数式でなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// 整数リテラルは定数式</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>

    <span class="c1">// const修飾されていて、初期化式が定数式であるオブジェクトは定数式</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// OK</span>

    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">;</span> <span class="c1">// これは定数式ではない</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="id55">
<h3>定数式ではない式<a class="headerlink" href="#id55" title="Permalink to this headline">¶</a></h3>
<p>以下に列挙する式は、定数式ではない式である。これらの式を含む式は、その値をコンパイル時に決定することができないので、定数式にはならない。</p>
<p>TODO: constant expressionとconstexpr specifierについては、まだ議論が多く、変更される可能性があるため、執筆を保留。</p>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="stmt.stmt.html" title="文（Statements）"
             >next</a> |</li>
        <li class="right" >
          <a href="conv.html" title="標準型変換（Standard conversions）"
             >previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ezoe Ryou.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>