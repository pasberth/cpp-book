特別なメンバー関数（Special member functions）
================================================================================

コンストラクター（Constructors）
--------------------------------------------------------------------------------



コンストラクターは名前を持たない。コンストラクターの宣言には、特別な文法が用いられる。



.. code-block:: c++
  
  関数指定子もしくはconstexpr クラス名 仮引数リスト


.. code-block:: c++
  
  struct X
  {
      X() ; // コンストラクターの宣言
  } ;
  
  X::X() { } // コンストラクターの定義


コンストラクターは、クラス型のオブジェクトを初期化するのに用いられる。



コンストラクターのクラス名に、typedef名を用いることはできない。



コンストラクターに、virtual指定子、static指定子を指定することはできない。要約すれば、コンストラクターに使用可能な指定子は、inline、explicit、constexprである。コンストラクターをCV修飾することはできない。ただし、コンストラクターは、CV修飾されたオブジェクトの初期化に対しても、呼び出される。オブジェクトのCV修飾子は、構築中のオブジェクトには適用されないからである。コンストラクターをリファレンス修飾することはできない。



.. code-block:: c++
  
  struct X {
      virtual X() ; // エラー、コンストラクターにvirtual指定子は使えない
      static X() ; // エラー、コンストラクターにstatic指定子は使えない
      X() const ; // エラー、コンストラクターはCV修飾できない
      X() & ; // エラー、コンストラクターはリファレンス修飾できない
  } ;


デフォルトコンストラクター
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

実引数なしで呼べるコンストラクターを、デフォルトコンストラクター（default constructor）という。これには、仮引数を取らないコンストラクターの他に、仮引数にすべてデフォルト実引数が指定されているコンストラクターも含まれる。




以下はすべて、Xに対するデフォルトコンストラクターの宣言である。



.. code-block:: c++
  
  X() ;
  X( int = 0 ) ;
  X( int = 0, int = 0 ) ;


もし、ユーザー定義のデフォルトコンストラクターが存在しない場合、暗黙のデフォルトコンストラクターが、デフォルト化されて宣言される。



.. code-block:: c++
  
  struct X
  {
  // デフォルトコンストラクターの定義なし
  // 暗黙に、X() = default ; が宣言される
  } ;
  
  struct Y
  {
      Y(int) ; // ユーザー定義のコンストラクター
  // 暗黙のデフォルトコンストラクターはdefault化されない
  } ;


ただし、以下のいずれかの条件をみたすクラスの場合、暗黙のデフォルトコンストラクターはdelete定義される。



<a href="#variant_member">unionのようなクラス</a>で、共用メンバーが非トリビアルデフォルトコンストラクターを持つ場合



.. code-block:: c++
  
  // 非トリビアルデフォルトコンストラクターを持つクラス
  struct NonTrivial
  {
      NonTrivial() { } // 非トリビアルデフォルトコンストラクター
  } ;
  
  // 非トリビアルデフォルトコンストラクターを持つメンバーのあるunion
  union X
  {
  // 暗黙のデフォルトコンストラクターはdelete定義される
      NonTrivial nt ;
  } ;
  
  // そのような無名unionを直接のメンバーに持つクラス
  struct Y
  {
  // 暗黙のデフォルトコンストラクターはdelete定義される
      union { NonTrivial nt ; } ;
  } ;


初期化子のないリファレンス型の非staticデータメンバーを持つクラスの場合



.. code-block:: c++
  
  int OBJECT ; // グローバル変数
  
  struct X
  {
  // 初期化子のないリファレンス型の非staticデータメンバー
      int & ref ;
  } ;
  
  struct Y
  {
  // 初期化子がある
      int & ref = OBJECT ;
  } ;
  
  struct Z
  {
      int & ref ;
  // ユーザー定義のコンストラクターがある
      Z() : ref( OBJECT ) { }
  } ;
  
  int main ()
  {
      X x ; // エラー、デフォルトコンストラクターがdelete定義される
      Y y ; // OK
      Z z ; // OK
  }


クラスXのデフォルトコンストラクターは暗黙にdelete定義される。Y::refには初期化子がある。Z::refはstaticデータメンバーである。



unionのメンバーではない、const修飾された型かあるいはその配列型の、非staticデータメンバーが、ユーザー定義デフォルトコンストラクターを持たず、初期化子もない場合。



.. code-block:: c++
  
  // ユーザー定義デフォルトコンストラクターを持たないクラス
  struct NoUserDefined { } ;
  
  struct X
  {
  // 初期化子がない
      NoUserDefined const member ;
      NoUserDefined const array[1] ;
  } ;
  
  struct Y
  {
  // 初期化子がある
      NoUserDefined const member = NoUserDefined() ;
  } ;
  
  
  struct Z
  {
      NoUserDefined const member ;
  // memberに対する初期化子がないので不可
  // Z() : member() { } なら可
      Z() { }    
  } ;
  
  int main ()
  {
      X x ; // エラー
      Y y ; // OK
      Z z ; // エラー
  }


気をつける点としては、Zのユーザー定義デフォルトコンストラクターが、Z(){}という形の場合、Z::memberに対する初期化子がないので、エラーになる。Z() : member() { }という形の場合は、初期化子があるので、エラーにはならない。



<a href="#variant_member">unionのようなクラス</a>で、共用メンバーがconst修飾されている場合。これには、const修飾されている型への配列型も含む。



.. code-block:: c++
  
  union X
  { // すべてconst修飾されている
      int const a ;
      int const b ;
      int const c[1] ;
  } ;
  
  struct Y
  { // すべてconst修飾されている無名unionをメンバーに持つ
      X x ;
  } ;
  
  union Z
  {
      int a ; // const修飾されていない
      int const b ;
      int const c[1] ;
  } ;
  
  
  int main ()
  {
      X x ; // エラー
      Y y ; // エラー
      Z z ; // OK、Y::aはconst修飾されていない。
  }


unionのすべての非staticデータメンバーがconst修飾されている場合のみ、デフォルトコンストラクターが暗黙にdelete定義される。ひとつでもconst修飾されていない非staticデータメンバーがある場合、この条件には当てはまらない。




直接の基本クラス、仮想基本クラス、初期化子のない非staticデータメンバーの型が、デフォルトコンストラクターが使えない型である場合。これには、配列型も含まれる



.. code-block:: c++
  
  // デフォルトコンストラクターが使えないクラスの例
  struct X
  {
      X() = delete ;
  } ;
  
  // 直接の基本クラス
  struct A : X { } ;
  // 仮想基本クラス
  struct B : virtual X { } ;
  // 初期化子のない非staticデータメンバー
  struct C
  {
      X a ;
      X b[1] ;
  } ;


クラスA、B、Cは、いずれもデフォルトコンストラクターが暗黙にdelete定義される。



ある型のデフォルトコンストラクターが使えない場合というのは、以下の通りである。



デフォルトコンストラクターがない場合。



.. code-block:: c++
  
  // ユーザー定義コンストラクターがある場合、暗黙のデフォルトコンストラクターは定義されない。
  struct NoDefaultConstructor { NoDefaultConstructor(int) ; } ;
  struct X : NoDefaultConstructor { } ;


デフォルトコンストラクターのオーバーロード解決の結果が曖昧になる場合。



.. code-block:: c++
  
  struct Ambiguous
  {
      Ambiguous( int = 0 ) { }
      Ambiguous( double = 0.0 ) { }
  } ;
  
  struct X : Ambiguous { } ;
  
  int main ()
  {
      Ambiguous a ; // エラー、デフォルトコンストラクターのオーバーロード解決が曖昧
      X b ; // エラー、デフォルトコンストラクターは暗黙にdelete定義されている
  }


デフォルトコンストラクターがdelete定義されている場合



.. code-block:: c++
  
  struct X
  {
      X() = delete ; // デフォルトコンストラクターのdelete定義
  } ;


クラスのデフォルト化されたデフォルトコンストラクターから、ある型のデフォルトコンストラクターにアクセス出来ない場合。



.. code-block:: c++
  
  class B1
  {
  private :
      B1() = default ;
  } ;
  
  class B2
  {
  private :
      B2() { }
  } ;
  
  class D1 : public B1 { } ;
  class D2 : public B2 { } ;
  
  int main()
  {
      D1 a ; // エラー、デフォルトコンストラクターは暗黙にdelete定義されている
      D2 b ; // エラー、デフォルトコンストラクターは暗黙にdelete定義されている
  }


クラスB1、B2のデフォルトコンストラクターは、privateメンバーなので、friendではないクラスD1、D2からはアクセスできない。そのため、デフォルトコンストラクターは暗黙にdelete定義される。



これらの条件に当てはまらない場合、デフォルトコンストラクターは暗黙にdefault化される。



デフォルトコンストラクターがトリビアル（trivial）となるためには、以下の条件をすべて満たさなければならない。



デフォルトコンストラクターがユーザー定義もdelete定義もされていない。クラスはvirtual関数とvirtual基本クラスを持たない。クラスの非staticデータメンバーは、初期化子を持たない。クラスの直接の基本クラスは、トリビアルデフォルトコンストラクターを持つ。クラスの非staticデータメンバーは、トリビアルデフォルトコンストラクタを持つ。



デフォルトコンストラクターは、使われたときに、暗黙にdefault化される。デフォルトコンストラクターがdelete定義されずに、default化された場合、暗黙に定義される。この暗黙のデフォルトコンストラクターは、コンストラクター初期化子を書かずコンストラクターの本体を空にした、ユーザー定義のデフォルトコンストラクターと同等である。



.. code-block:: c++
  
  struct X
  {
      // 暗黙のデフォルトコンストラクターは、以下のコードと同じ
      // X(){}
  } ;
  
  struct Y { } ;
  
  int main()
  {
      X x ; // 暗黙のデフォルトコンストラクターを使う
  }


クラスXはデフォルトコンストラクターが使われているので、暗黙にdefault化される。クラスYのデフォルトコンストラクターは使われていないので、定義されない。



もし、暗黙のデフォルトコンストラクターが定義されていて、同等のユーザー定義のデフォルトコンストラクターを書いた場合にエラーとなる場合は、プログラムもエラーとなる。



.. code-block:: c++
  
  struct X { int & ref ; } ;
  struct Y { int & ref ; } ;
  
  int main()
  {
      X x ; // エラー
      int obj = 0 ;
      Y y = { obj } ; // OK
  }


クラスXはデフォルトコンストラクターを使っているので、暗黙のデフォルトコンストラクターがdefault化される。しかし、リファレンスの非staticデータメンバーを持つことにより、同等のユーザー定義のデフォルトコンストラクターがエラーになるので、エラーとなる。一方、クラスYでは、デフォルトコンストラクターが使われていない



同等のユーザー定義のデフォルトコンストラクターがconstexprコンストラクターの要求を満たす場合、暗黙のデフォルトコンストラクターも、constexprコンストラクターになる。



デフォルトコンストラクターは、初期化子なしで定義されたオブジェクトや、関数形式の明示的なキャストに対して呼ばれる。



.. code-block:: c++
  
  struct X { X() { } } ;
  
  X x ; // デフォルトコンストラクターが呼ばれる
  
  int main()
  {
      X x ; // デフォルトコンストラクターが呼ばれる
      new X ; // デフォルトコンストラクターが呼ばれる
      X() ; // デフォルトコンストラクターが呼ばれる
  }


クラスのオブジェクトをコピー、ムーブする際には、コピー、ムーブコンストラクターがそれぞれ使われる。詳しくは、<a href="#class.copy">クラスオブジェクトのコピーとムーブ</a>を参照。



基本クラスと非staticデータメンバーのコンストラクターが呼ばれる順番や、実引数の渡し方については、<a href="#class.base.init">基本クラスとデータメンバーの初期化</a>を参照。



その他のコンストラクターについては、<a href="#class.conv.ctor">型変換コンストラクター</a>を参照。



コンストラクターに戻り値の型を指定することはできない。コンストラクターの本体の中でreturn文を使う場合は、値を指定してはならない。コンストラクターのアドレスを取得することはできない。



constなオブジェクトの構築中に、コンストラクターのthisを、直接、間接的に経由しないglvalueによってオブジェクト、またはそのサブオブジェクトにアクセスした場合、値は未規定である。この制限には、通常、まず遭遇することはない。例えば、以下のようなコードが問題になる。



.. code-block:: c++
  
  struct C ;
  
  void f( C * ) ;
  
  struct C
  {
      int value ;
      C() : c(123)
      { // オブジェクトは、まだ構築中
          f( this ) ; // オブジェクトの構築中に呼び出す
      }
  } ;
  
  const C cobj ; // staticストレージ上のconstなオブジェクト
  
  void f( C* cptr )
  {
      cptr->value ; // OK、値は123。cptrはコンストラクターのthis由来
      cobj.value ; // 値は未規定
  }


オブジェクトは、コンストラクターを実行し終わった時点で、構築済みとなる。コンストラクターを実行中ということは、まだオブジェクトは構築中ということである。cobjは、デフォルトコンストラクターを呼び出す。したがって、関数fは、cobjの構築中に呼び出されるということになる。cptrの値は、コンストラクターのthisによって得られたアドレスである。したがって、cptrの値である、Cのオブジェクトへのアドレスを参照して、cobjにアクセスすることはできる。関数fは、クラスCのコンストラクターから呼び出されている。関数fの中からcobjを直接参照するということは、cobjの構築中に、コンストラクターのthisによらずにアクセスするということである。この場合、値は未規定となる。この例では、123であるとは保証されない。



この条件に当てはまるようなコードは、現実には極めて珍しい。


一時オブジェクト（Temporary objects）
--------------------------------------------------------------------------------



一時オブジェクト（temporary object）は、様々な場面で、自動的に生成、破棄される。例えば、prvalueをリファレンスに束縛する、prvalueを返す、prvalueを生成する型変換、例外のthrow、ハンドラーでキャッチ、初期化などである。例外における一時オブジェクトの寿命は、<a href="#except">例外</a>を参照。



.. code-block:: c++
  
  struct X { } ;
  
  X f()
  {
      return X() ; // prvalueを生成する型変換
  }
  
  int main()
  {
      int && ref = 0 ; // prvalueをリファレンスに束縛する
      f() ; // prvalueを返す
  }


実装は一時オブジェクトの生成を省略できる。例えば、以下のコードについて考える。



.. code-block:: c++
  
  struct X
  {
      X( int ) ; // コンストラクター
      X( X const & ) ; // コピーコンストラクター
      X & operator = ( X const & ) ; // コピー代入演算子
      ~X() ; // デストラクター
  } ;
  
  struct Y
  {
      Y( int ) ; // コンストラクター
      Y( Y && ) ; // ムーブコンストラクター
      ~Y() ; // デストラクター
  };
  
  X f( X ) ;
  Y g( Y ) ;
  
  int main()
  {
  
      X a = f( X(2) ) ; // #1
      Y b = g( Y(3) ) ; // #2
      X c(1) ;
      c = f(c) ; // #3
  }


#1について考える。ある実装では、X(2)という式で一時オブジェクトがひとつ作られ、関数の実引数として渡す際に、別の一時オブジェクトがひとつ作られてコピーされるかもしれない。関数の戻り値も、別の一時オブジェクトがひとつ作られて、変数aにコピーされるかもしれない。別の実装では、X(2)という式による一時オブジェクトは、関数の実引数の一時オブジェクト上に直接構築されるので、一時オブジェクトを省略できるかもしれない。関数の戻り値も、変数aのオブジェクト上に直接構築されるので、一時オブジェクトを省略できるかもしれない。



#2も、コピーがムーブに、変数aがbに変わっただけで、同じことが言える。



#3では、変数cは、すでに構築されたオブジェクトなので、関数の戻り値の一時オブジェクトを、変数cのオブジェクトの上に、直接構築することはできない。ここでは一時オブジェクトが構築され、変数cにコピーされる。



一時オブジェクトの構築が省略されたとしても、もし一時オブジェクトを作成していればエラーになるようなコードは、エラーになる。たとえば、コンストラクターやデストラクターにアクセスできない場合だ。



一般に、ある式において一時オブジェクトがいくつ構築されるかということは、規格では定義されていない。実装次第である。一時オブジェクトが構築されなければ、コンストラクターやデストラクターも呼ばれない。



逆に、一時オブジェクトが構築される場合、非トリビアルなコンストラクターは必ず呼び出されるし、破棄するときには、非トリビアルなデストラクターは必ず呼び出される。



一時オブジェクトの破棄は原則として、その一時オブジェクトを構築することになった式を含む<a href="#intro.execution">完全式</a>の評価の最後の段階として、実行される。言いかえれば、一時オブジェクトの寿命は、完全式が評価され終わるまでということもできる。



.. code-block:: c++
  
  struct X
  {
      X operator + ( X const & ){ return X() ; }
  } ;
  
  int main()
  {
      X a = 0 ;
      X b = a + a + a ;
  }


この例で、yの初期化子の中の式において構築された一時オブジェクトがもしあれば、その寿命は、ソースコード上で言えば、セミコロンまでとなる。



ただし、この原則に従わない場合が、ふたつ存在する。



ひとつは、配列の要素を初期化する際に、デフォルトコンストラクターがデフォルト実引数を持っていた場合、ある要素のデフォルトコンストラクター実行における一時オブジェクトの破棄は、次の要素の初期化の前に行われる。破棄に伴うあらゆるサイドエフェクトは、次の要素の初期化の以前にシーケンス（sequenced before）される。



.. code-block:: c++
  
  struct Fat { char [1000] ; } ;
  
  struct X
  {
      X( Fat f = Fat() ) { } // デフォルトコンストラクター
  } ;
  
  int main()
  {
      X a[1000] ;
  }


この例では、a[0]からa[999]までの1000個のX型の配列の要素に対し、デフォルトコンストラクターが呼び出される。もし、a[0]がa[1]の前に初期化された場合、a[0]のデフォルトコンストラクター呼び出しによって構築されたFat型の一時オブジェクトは、a[1]を初期化するときには、すでに破棄されている。配列のすべての要素を初期化し終わるまで、1000個のFat型の一時オブジェクトが保持されることはない。



もうひとつは、一時オブジェクトをリファレンスに束縛した場合、一時オブジェクトの寿命は、リファレンスの寿命まで延長される。一時オブジェクトは、rvalueリファレンスか、constなlvalueリファレンスで束縛できる。



.. code-block:: c++
  
  struct X { } ;
  
  int main()
  {
      {
          X const & lvalue_reference = X() ;
          X && rvalue_reference = X() ;
      // 一時オブジェクトの寿命はここまで
      }
  }


ただし、このリファレンス束縛の寿命の延長には、いくつかの例外が存在する。



コンストラクター初期化子によってリファレンスのメンバーに束縛された一時オブジェクトの寿命は、コンストラクター呼び出しが終了するまでである。



.. code-block:: c++
  
  struct Member { } ;
  
  struct X
  {
      Member const & ref ;
      X( Member const & ref ) : ref(ref)
      {
          // refは妥当なオブジェクトを参照している
      }
  } ;
  
  int main()
  {
      X x = Member()  ;
      // 一時オブジェクトが破棄される
      // x.refは無効なオブジェクトを参照している
  }


もし、クラスXのコンストラクターの実引数が、一時オブジェクトへのリファレンスだった場合、一時オブジェクトの寿命は、コンストラクター呼び出しが終了するまでである。そのため、初期化の終わった変数xのメンバーrefは、無効なオブジェクトを参照していることになる。



仮引数のリファレンスに束縛された一時オブジェクトの寿命は、関数呼び出しを含む式の完全式の評価が終了するまでである。



.. code-block:: c++
  
  struct X { } ;
  
  void f( X const & ref )
  {
      // refは妥当なオブジェクトを参照している
  }
  
  int main()
  {
      f( X() ) ;
      // 一時オブジェクトが破棄される
  }


この例で、X()を含む完全式というのは、関数fに対する関数呼び出し式のオペランドである。したがって、完全式はX()となる。しかし、この解釈に従うと、関数の本体では、refは無効なオブジェクトを参照することになってしまう。そのため、仮引数のリファレンス束縛に対しては、関数呼び出しを含む完全式になる。この場合、f( X() )である。そのため、X()によって構築された一時オブジェクトは、関数fの本体の中でも妥当である。



関数のreturn文によって構築された、関数の戻り値のリファレンスに束縛された一時オブジェクトの寿命は、延長されない。一時オブジェクトは、return文を含む完全式の終了をもって、破棄される。



.. code-block:: c++
  
  struct X { } ;
  
  X const & f( X const & ref )
  {
      return X() ;
  }
  
  int main()
  {
      X const & ref = f( X() ) ;
      // 一時オブジェクトは破棄される
      // refは無効なオブジェクトを参照している
  }


このように、関数の戻り値としてのリファレンスに束縛されても、一時オブジェクトの寿命は延長されない。これには注意が必要である。



new初期化子の中でリファレンス束縛された一時オブジェクトの寿命は、new初期化子を含む完全式の終わりまでである。



.. code-block:: c++
  
  struct X { int const & ref ; } ;
  
  int main()
  {
      X * ptr = new X{ 0 } ;
      // 一時オブジェクトが破棄される
      // ptr->refは無効なオブジェクトを参照している
  }


リファレンス束縛により、寿命の延長を受けていない一時オブジェクトの破棄の順番は、構築の逆順に行われる。後に構築された一時オブジェクトの方が、先に構築された一時オブジェクトより、先に破棄される。



もし、リファレンス束縛を受けた、複数の一時オブジェクトが、同じ場所で破棄される場合、破棄の順番は、構築の逆順に行われる。



.. code-block:: c++
  
  struct X { X( int ) { } } ;
  void f( X const &, X const & ) { }
  
  int main()
  {
      f( X(1), X(2) ) ; // #1
  }


今、#1のX(1)、X(2)という式に対して、それぞれ一時オブジェクトが構築されたとする。関数の実引数の評価順序は規定されていないので、どちらが先に構築されるかは、規格の定めるところではない。しかし、仮にX(1)の一時オブジェクトが、X(2)に先んじて構築された場合、オブジェクトの破棄は、X(2)が先になる。


型変換（Conversions）
--------------------------------------------------------------------------------



クラスの型変換を実現するには、方法がふたつある。コンストラクターと変換関数（conversion function）だ。このふたつを合わせて、ユーザー定義型変換（user-deﬁned conversions）という。ユーザー定義型変換は、暗黙の型変換、初期化、明示的な型変換に用いられる。



ひとつの値に対して、ユーザー定義型変換は1回しか適用されない。



.. code-block:: c++
  
  struct X { } ;
  struct Y
  {
      Y( int ){ } // int型からY型へ
      operator X() { return X() ; } // Y型からX型へ
  } ;
  
  int main()
  {
      Y a = 0 ; // OK、int型からY型への型変換
      X b = Y(0) ; // OK、Y型からX型への型変換
      X c = 0 ; // エラー
  }


ユーザー定義型変換によって、int型からY型に変換することはできる。また、Y型からX型に変換することはできる。ただし、int型から、暗黙にX型に変換することはできない。なぜならば、それにはユーザー定義型変換を、2回適用しなければならないからだ。



ユーザー定義型変換は、曖昧にならない場合のみ、暗黙に使われる。派生クラスの型変換関数は、基本クラスの型変換関数を隠さない。ただし、同じ型に対する型変換関数の場合を除く。複数の型変換関数がある場合、関数のオーバーロード解決と同じ方法で、最適な関数が解決される。



.. code-block:: c++
  
  struct Base
  {
      operator int() { return 0 ; }
  } ;
  struct Derived : Base
  {
      // Base::operator intを隠さない
      operator char() { return char(0) ; }
  } ;
  
  int main()
  {
      Derived obj ;
      int a = obj ; // OK
      char b = obj ; // OK
      bool c = obj ; // エラー、　曖昧
  }


コンストラクターによる型変換（Conversion by constructor）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



explicit指定子を使わずに宣言されているコンストラクターは、仮引数からクラスへの型変換の方法を指定するメンバー関数である。このような関数を、型変換コンストラクター（converting constructor）という。



.. code-block:: c++
  
  struct X
  {
      X( int ) {} // int型からの型変換を提供
      X( double ) {} // double型からの型変換を提供
      X( int, int, int ) ; // 3個のint型からの型変換を提供
  } ;
  
  int main()
  {
      X a = 0 ; // int型からの型変換
      X b(0) ; // int型からの型変換
      X c = 0.0 ; // double型からの型変換
      X d( 1, 2, 3 ) ;
  }


型変換コンストラクターは、仮引数からクラス型への変換方法を指定する。仮引数は、複数でもよい。



explicit指定子のあるコンストラクターは、explicitのないコンストラクターとほぼ同じである。ただし、explicitコンストラクターは、<a href="#dcl.init">直接初期化</a>か、キャストが明示的に使われたときにしか、使われない。



.. code-block:: c++
  
  struct X
  {
      explicit X( int ) {} // explicitコンストラクター
  } ;
  
  void f( X ) { }
  
  int main()
  {
      X a = 0 ; // エラー
      X b(0) ; // OK、直接初期化
      X c = X(0) ; // OK、明示的なキャスト
      X d = static_cast<X>(0) ; // OK、明示的なキャスト
  
      f( 0 ) ; // エラー
      f( static_cast<X>(0) ) ; // OK
  }


デフォルトコンストラクター、コピーコンストラクター、ムーブコンストラクターにも、explicitを指定できる。これらの関数も、explicit指定子を指定しない場合、暗黙に使われる。



.. code-block:: c++
  
  struct X
  {
      X() { }
      explicit X( X const & ) {} // explicitコピーコンストラクター
  } ;
  
  int main()
  {
      X a ;
      X b = a ; // エラー、コピー初期化（代入式とは違うことに注意）
      X c( a ) ; // OK、直接初期化
  }


デフォルトコンストラクターに対するexplicit指定子の有無は、以下のコード例のような違いをもたらす。



.. code-block:: c++
  
  struct X
  {
      X() { }
  } ;
  
  struct Y
  {
      explicit Y() { }
  } ;
  
  
  int main( )
  {
      X x( { } ) ; // OK、非explicitデフォルトコンストラクター
      Y y( { } ) ; // エラー、explicitデフォルトコンストラクター
  }


実用上、気になるほどの違いはない。





型変換関数（Conversion functions）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



以下のような文法で宣言されるメンバー関数を、型変換関数（Conversion function）という。



.. code-block:: c++
  
  explic

型変換関数は、仮引数を取らず、戻り値の型を指定しない。型変換関数は、メンバーであるクラス型から、型識別子の型への型変換を提供する。



.. code-block:: c++
  
  struct X
  {
      operator int() { return 0 ; } 
  } ;
  
  int main()
  {
      X x ;
      int i = x ; // 0
  }


この例では、クラスXは、暗黙にint型の0に変換できるクラスとなる。



型変換関数の型は、「仮引数を取らず、型識別子の型を返す、メンバー関数」になる。



.. code-block:: c++
  
  struct X
  {
      operator int() const { return 0 ; } 
  } ;
  
  int main()
  {
      // 型はint (X::*)(void) const
      int (X::*ptr)(void) const = &X::operator int ; // ポインターを得る
      X x ;
      (x.*ptr)() ; // 呼び出す
  }


型識別子が、自分自身のクラス型（リファレンスも含む）、自分自身の基本クラス型（リファレンスも含む）、void型、またこれらの型にCV修飾子を付けた型の場合、型変換関数が使われることはない。これらの型変換には、標準型変換が用いられる。型変換関数は使われない。これらの型変換関数を宣言することはエラーではないが、使われることはない。



.. code-block:: c++
  
  struct Base{ } ;
  
  struct Derived : Base
  {
      // これらの型変換関数は、使われることはない
      operator Derived () ; // 自分自身のクラス型
      operator Derived & () ; // 自分自身のクラスへのリファレンス型
      operator Derived const & () ; // 自分自身のクラスへのconstリファレンス型
      operator Base () ; // 基本クラス型
      operator void () ; // void型
  } ;
  
  int main()
  {
      Derived d ;
      Base b = d ; // 標準型変換が使われる。型変換関数は使われない
  }


型変換関数にexplicit指定子が指定されている場合、型変換関数は、直接初期化や明示的なキャストが使われなければ、呼び出されない。



.. code-block:: c++
  
  struct A { } ;
  struct B { } ;
  
  struct X
  {
      operator A() { return A() ; }
      explicit operator B() { return B() ; }
  
  } ;
  
  int main()
  {
      X x ;
  
      A a1 = x ; // OK
      A a2(x) ; // OK
      A a3 = A(x) ; // OK
  
      B b1 = x ; // エラー、コピー初期化
      B b2(x) ; // OK、直接初期化
      B b3 = B(x) ; // OK、明示的なキャスト
  }


型変換関数の型識別子を、関数型と配列型にすることはできない。



.. code-block:: c++
  
  struct X
  {
      operator void (void) () ; // エラー、関数型
      operator int[1] () ; // エラー、配列型
  } ;


その他の型には、特に制限はない。



.. code-block:: c++
  
  struct Y { } ;
  
  struct X
  {
      using pointer_type = void (*)(void) ;
      using reference_type = int (&)[1] ;
  
      operator pointer_type () ; // 関数ポインタ―型
      operator reference_type () ; // 配列への参照型
  
      operator Y() ; // 他のクラス型
  } ;


型変換関数は継承される。



.. code-block:: c++
  
  struct Base
  {
      operator int() { return 0 ; }
  } ;
  
  struct Derived : Base { } ;
  
  int main()
  {
      Derived d ;
      int i = d ; // Base::operator intを呼び出す
  }


型変換関数はvirtual関数にできる。



.. code-block:: c++
  
  struct Base
  {
      // ピュアvirtual関数
      virtual operator int() = 0 ;
  } ;
  
  struct Derived : Base
  {
      // オーバーライド
      virtual operator int() { return 0 ; }
  } ;


型変換関数はstatic関数にはできない。



.. code-block:: c++
  
  struct X
  {
      static operator int() ; // エラー
  } ;




デストラクター（Destructors）
--------------------------------------------------------------------------------



以下のような文法の宣言を、デストラクター（destructor）という。



.. code-block:: c++
  
  関数指

デストラクターの宣言は、~（チルダ）に続いて、クラス名、空の引数リストを指定する。関数指定子には、inlineとvirtualを指定できる。クラス名の代わりに、typedef名を使用することはできない。



.. code-block:: c++
  
  struct X
  {
      ~X() ; // デストラクターの宣言
  } ;


デストラクターはクラス型のオブジェクトを破棄する際に使われる。デストラクターには、仮引数や戻り値の型を指定することはできない。デストラクターのアドレスを得ることはできない。デストラクターはstaticメンバーにはなれない。デストラクターは、CV修飾、リファレンス修飾できない。ただし、デストラクターは、CV修飾されたクラス型のオブジェクトに対しても呼び出される。



.. code-block:: c++
  
  struct X
  {
      ~X() { }
  } ;
  
  int main()
  {
      {
          X x ;
      // オブジェクト破棄、デストラクターが呼ばれる
      }
  
      X * ptr = new X ;
      delete ptr ; // オブジェクト破棄、デストラクターが呼ばれる
  }


デストラクターの宣言に例外指定がない場合は、暗黙のデストラクターと同等の例外指定が、暗黙に指定される。詳しくは、<a href="#except.spec">例外指定</a>を参照。



<p class="editorial-note">
TODO:サンプルコードが必要だが、Madrid会議で変更される可能性があるので保留。



クラスにユーザー宣言されたデストラクターがない場合、デストラクターは暗黙にdefault化されて宣言される。暗黙に宣言されたデストラクターは、クラスのinline publicメンバーである。



暗黙のデストラクターは、以下のいずれかの条件を満たしたとき、delete定義される。



 unionのようなクラスで、共用メンバーが、非トリビアルデストラクターを持つ場合。 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

<a href="#variant_member">unionのようなクラス</a>で、共用メンバーが、非トリビアルデストラクターを持つ場合。




.. code-block:: c++
  
  struct Trivial { } ;
  struct NonTrivial { ~NonTrivial() { } } ;
  
  // デストラクターは暗黙にdefault化される
  union A1 { Trivial member ; } ;
  struct A2 { union { Trivial member ; } ; } ;
  
  // デストラクターは暗黙にdelete定義される
  union B1 { NonTrivial member ; } ;
  struct B2 { union { NonTrivial member ; } ; } ;
  
  int main()
  {
  // OK、暗黙のデストラクターを使う
      A1 a1 ; A2 a2 ;
  // エラー、暗黙のデストラクターはdelete定義されている
      B1 b1 ; B2 b2 ;
  }


クラスの非staticデータメンバーのデストラクターがdelete定義されているか、デフォルトデストラクターからアクセス出来ない場合。



.. code-block:: c++
  
  struct deleted_destructor
  {
      ~deleted_destructor() = delete ;
  } ;
  
  struct inaccessible_destructor
  {
  private :
      ~inaccessible_destructor() ;
      friend struct Y ; 
  } ;
  
  // クラスのデストラクターは暗黙にdelete定義される
  struct X
  {
      deleted_destructor m1 ; // デストラクターがdelete定義されている
      inaccessible_destructor m2 ; // デストラクターにアクセス出来ない
  } ;
  
  struct Y
  {
      inaccessible_destructor m ; // friendなので、デストラクターにアクセス可能
  } ;


直接の基本クラス、もしくは、virtual基本クラスのデストラクターがdelete定義されているか、デフォルトデストラクターからアクセス出来ない場合。



.. code-block:: c++
  
  struct Base
  { 
      ~Base() = delte ;
  } ;
  
  struct D1 : Base
  {
  // D1のデストラクターはdelete定義される
  } ;


間接の基本クラスのデストラクターは、影響しない。



.. code-block:: c++
  
  struct Base
  { 
  private :
      ~Base() { }
      friend struct D1 ;
  } ;
  
  struct D1 : Base
  {
  // friend宣言により、Baseのデストラクターにアクセスできる
  } ;
  
  struct D2 : D1
  {
  // D1のデストラクターにアクセスできる
  } ;
  
  
  int main()
  {
      D1 d1 ; // OK
      D2 d2 ; // OK
  }


ただし、virtual基本クラスには、直接と間接の違いはないので、影響する。




.. code-block:: c++
  
  struct Base
  { 
  private :
      ~Base() { }
      friend struct D1 ;
  } ;
  
  struct D1 : virtual Base
  {
  // friend宣言により、Baseのデストラクターにアクセスできる
  } ;
  
  struct D2 : D1
  {
  // virtual基本クラスのBaseのデストラクターにアクセスできない
  // デストラクターは暗黙にdelete定義される
  } ;
  
  
  int main()
  {
      D1 d1 ; // OK、暗黙のデストラクターを使う
      D2 d2 ; // エラー、デストラクターはdelete定義されている
  }


D2からD1のデストラクターにアクセスすることはできるが、D2からvirtual基本クラスであるBaseのデストラクターにアクセス出来ないため、D2のデストラクターは暗黙にdelete定義される。




デストラクターがトリビアルとなるためには、ユーザー提供もdelete定義もされておらず、以下の条件をすべて満たす必要がある。



* デストラクターはvirtualではない。
* 直接の基本クラスのデストラクターは、すべてトリビアルである。
* 非staticデータメンバーのデストラクターは、すべてトリビアルである。


注意すべきこととしては、直接の基本クラスのデストラクターがトリビアルとなるためには、直接の基本クラスの直接の基本クラスのデストラクターもトリビアルでなければならない。つまり、最終的には、間接の基本クラスのデストラクターも、すべてトリビアるでなければならない。



delete定義されていない暗黙のデストラクターは、使われたときに、定義される。もしくは、明示的にdefault化されたときにも定義される。



デストラクターの呼び出しは、コンストラクター呼び出しの逆順に行われる。コンストラクター呼び出しの順番については、<a href="#class.base.init">基本クラスとデータメンバーの初期化</a>を参照。



クラスのデストラクターの本体の実行を終え、本体内の自動変数を破棄する。<a href="#variant_member">共用メンバー</a>を除くクラスの直接のメンバーに対して、デストラクターを呼び出す。クラスの直接の基本クラスのデストラクターを呼び出す。クラスが、最上位の派生クラスならば、virtual基本クラスのデストラクターを呼び出す。



配列の要素に対するデストラクターも、コンストラクターの逆順に呼ばれる。



デストラクターは、virtual関数やピュアvirtual関数にすることができる。基本クラスのデストラクターがvirtual関数である場合、派生クラスのデストラクターもvirtualになる。基本クラスのデストラクターがピュアvirtual関数の場合、派生クラスのオブジェクトを構築するためには、デストラクターを定義しなければならない。これらは、通常のvirtual関数と変わらない。



.. code-block:: c++
  
  struct Base
  {
      virtual ~Base() { } // デストラクターはvirtual関数
  } ;
  
  struct Derived : Base
  {
      ~Derived() { } // デストラクターはvirtual関数
  } ;
  
  struct Abstract_base
  {
      virtual ~Abstract_base() = 0 ; // デストラクターはピュアvirtual関数
  } ;


デストラクターをvirtual関数にする目的は、オブジェクトに動的に構築、破棄する際に、型情報を管理しなくてもいいという点にある。



.. code-block:: c++
  
  #include <iostream>
  
  struct B1
  {
      virtual ~B1() { } // virtual関数
  } ;
  
  struct D1 : B1
  {
      ~D1() { std::cout << "D1 destructor" << std::endl ; }
  } ;
  
  struct B2
  {
      ~B2() {} // 非virtual関数
  } ;
  
  struct D2 : B2
  {
      ~D2() { std::cout << "D2 destructor" << std::endl ; } 
  } ;
  
  int main()
  {
      B1 * b1_ptr = new D1 ;
      delete b1_ptr ; // 派生クラスのデストラクターが呼ばれる
  
      B2 * b2_ptr = new D2 ;
      delete b2_ptr ; // 派生クラスのデストラクターが呼ばれない
  }


delete式に渡しているのは、基本クラスへのポインターである。そのため、非virtualなデストラクターでは、派生クラスのデストラクターが呼び出されない。デストラクターをvirtual関数にしておけば、このような場合にも、派生クラスのデストラクターが正しく呼び出される。



デストラクターが暗黙に呼ばれる条件は、以下の通りである。



* staticストレージ上のオブジェクトに対しては、プログラムの終了時に呼ばれる。
* threadストレージ上のオブジェクトに対しては、スレッドの終了時に呼ばれる。
* 自動ストレージ上のオブジェクトに対しては、オブジェクトを構築したブロックを抜けたときに呼ばれる。
* 一時オブジェクトに対しては、寿命が尽きたときに呼ばれる。
* new式で構築されたオブジェクトに対しては、delete式で破棄されるときに呼ばれる
* その他、例外として投げられたオブジェクトのキャッチに関連して呼ばれることがある


クラス型、もしくはクラスの配列型のオブジェクトが宣言された箇所で、クラスのデストラクタにアクセス出来ない場合は、エラーとなる。



.. code-block:: c++
  
  class X
  {
  private :
      ~X() { } // privateメンバー
  } ;
  
  
  int main()
  {
      X x ; // エラー、デストラクターにアクセスできない。
  }


クラスがvirtualデストラクターを持つ場合、クラスには対応する解放関数が使える状態でなければならない。解放関数は、まずクラスのスコープ内で探され、見つからない場合は、グローバルスコープで探される。解放関数が見つからないか、曖昧か、delete定義されている場合、エラーとなる。これは、たとえプログラム中でdeletex式を使わなくてもエラーとなる。



.. code-block:: c++
  
  struct X
  {
      virtual ~X() { } // OK、グローバルスコープのoperator deleteが発見される
  } ;
  
  struct Y
  {
      virtual ~Y() { } // エラー、operator deleteはdelete定義されている。
      void operator delete( void * ptr ) = delete ;
  } ;
  
  struct B1
  {
      void operator delete( void * ptr ) ;
      virtual ~B1() { }
  } ;
  
  struct B2
  {
      void operator delete( void * ptr ) ;
  } ;
  
  struct Derived : B1, B2
  {
  // エラー、曖昧
  // 暗黙のデストラクターはvirtual関数
  } ;


この規格の意図は、動的な型のオブジェクトは、常にdelete式が適用できることを保証するためである。



デストラクターは、明示的に呼び出すことができる。デストラクターを明示的に呼び出すには、メンバーアクセス演算子を使い、~に続いて、クラス型に対応する型名か、decltype指定子を使う。



.. code-block:: c++
  
  // このコードは、あくまで明示的なデストラクター呼び出しを説明するための例である
  // 関数fを呼び出すと、Xのデストラクターは4回呼び出されることになり、挙動は未定義である
  struct X { } ;
  
  void f()
  {
      X x ;
      x.~X() ; // デストラクターの明示的な呼び出し（型名）
      x.decltype(x)() ; // デストラクタの明示的な呼び出し（decltype指定子）
      x.X::~X() ; // 修飾名付き
  
      // ブロックを抜ける際に、デストラクターが暗黙に呼び出される
  }


たとえ、自動ストレージ上のオブジェクトに対してデストラクターを明示的に呼び出したとしても、ブロックを抜けた際に、デストラクターは暗黙的に呼び出される。デストラクターを呼び出した後のオブジェクトに対して、再びデストラクターを呼び出した場合、挙動は未定義なので、上記のコードの挙動も、未定義である。



一般に、自動ストレージ上のオブジェクトに対して明示的にデストラクターを呼び出した後、そのオブジェクトに対して、通常ならば暗黙にデストラクターが呼び出される状況になっている場合、挙動は未定義である。



デストラクターの明示的な呼び出しは、まず使う必要はない。デストラクターが暗黙に呼び出されることがない場合としては、placement newによる、ユーザー指定のストレージ上へのオブジェクトの構築が上げられる。



.. code-block:: c++
  
  #include <new>
  
  struct X
  {
      ~X() { /*実装*/ }
  } ;
  
  int main()
  {
      void * ptr = ::operator new( sizeof(X) ) ; // ストレージを確保
      X * x_ptr = new(ptr) X ; // ptrの指すストレージ上にX型のオブジェクトを構築
      x_ptr->~X() ; // デストラクターの明示的な呼び出し
      ::operator delete( ptr ) ; // ストレージの解放
  }


スカラー型に対しても、デストラクターを明示的に呼び出すことができる。これによって、テンプレートのコードにおいて、型が組み込み型であるかどうかを気にしなくてすむ。



.. code-block:: c++
  
  int main()
  {
      typedef int I ;
      I i ;
      i.~I() ; // OK、なにもしない
  }


デストラクターを呼び出した後のオブジェクトに対して、再びデストラクターを呼び出した場合の挙動は未定義である。



フリーストア（Free store）
--------------------------------------------------------------------------------



クラスに対する確保関数（operator new）と解放関数（operator delete）は、メンバー関数としてオーバーロードすることができる。確保関数と解放関数の具体的な実装方法については、<a href="#support.dynamic">動的メモリー管理</a>を参照。



クラスのメンバー関数としての確保関数、解放関数は、staticメンバー関数である。たとえstatic指定子が明示的に使われていなくても、staticメンバー関数となる。



.. code-block:: c++
  
  #include <cstddef>
  
  struct X
  {
      // 確保関数
      void * operator new ( std::size_t size )
      { return ::operator new( size ) ; }
      // 配列
      void * operator new[] ( std::size_t size )
      { return ::operator new( size ) ; }
      // placement form
      void * operator new ( std::size_t size, int, int, int )
      { return ::operator new( size ) ; }
  
      // 解放関数
      void operator delete( void * ptr )
      { ::operator delete ( ptr ) ; }
      // 配列
      void operator delete[] ( void * ptr )
      { ::operator delete ( ptr ) ; }
  
      // placement form
      void operator delete( void * ptr, int, int, int )
      { ::operator delete ( ptr ) ; }
  
  } ;


解放関数に例外指定がない場合、noexcept(true)が指定されたものとみなされる。



初期化（Initialization）
--------------------------------------------------------------------------------



この項目では、クラスのオブジェクトの初期化について取り扱う。特に、明示的に初期化子が指定されているオブジェクトと、クラスの基本クラスとメンバーのサブオブジェクトの初期化方法を解説する。


クラスのオブジェクトに初期化子が指定されていない場合の初期化方法は、<a href="#dcl.init">初期化子</a>を参照。



クラスオブジェクトの配列の要素を初期化する際には、コンストラクターは、添字の順番に呼ばれる。デストラクターはコンストラクターの逆順に呼ばれる。



.. code-block:: c++
  
  #include <iostream>
  
  class X
  {
  private :
      int value ; 
  public :
      X( int value ) : value(value) { std::cout << value ; }
      ~X() { std::cout << value ; }
  } ;
  
  int main()
  {
      X a[3] = { 1, 2, 3 } ;
  }


X型の配列の要素は、a[0], a[1], a[2]の順番に構築され、a[2], a[1], a[0]の順番に破棄される。したがって、出力は、123321となる。



明示的な初期化（Explicit initialization）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



クラスのオブジェクトの初期化子には括弧に囲まれた式リストを使うことができる。この場合、適切な仮引数リストのコンストラクターによって初期化される。



.. code-block:: c++
  
  struct X
  {
      X( int ) ;
      X( int, int ) ;
      X( int, int, int ) ;
  } ;
  
  int main()
  {
      X x1( 1 ) ; // X::X(int)
      X x2( 1, 2 ) ; // X::X(int,int)
      X x3( 1, 2, 3 ) ; // X::X(int,int,int)
  }


詳しくは、<a href="#dcl.init">初期化子</a>の直接初期化を参照。



また、=（イコール）記号に続いて値を指定することで、初期化することもできる。



.. code-block:: c++
  
  struct X
  {
      X( int ) ;
  } ;
  
  int main()
  {
      X x = 0 ; // X::X(int)
  }


詳しくは、<a href="#dcl.init">初期化子</a>のコピー初期化を参照。



クラスのオブジェクトは、初期化リストで初期化することができる。



.. code-block:: c++
  
  struct X
  {
      X( int ) { }
  } ;
  
  int main()
  {
      X a[3] = { 1, 2, 3 } ;
  }


詳しくは、<a href="#dcl.init.list">リスト初期化</a>を参照。




基本クラスとデータメンバーの初期化（Initializing bases and members）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



基本クラスは、コンストラクター初期化子により初期化できる。データメンバーは、コンストラクター初期化子か、メンバーの宣言に続く初期化子によって、初期化できる。また、コンストラクターはデリゲート(Delegate)できる。



コンストラクター初期化子
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

クラスのコンストラクターの定義で、直接の基本クラス、virtual基本クラス、非staticデータメンバーを初期化できる。文法は、以下のようになる。



.. code-block:: c++
  
  コンストラクター初期化子:
  : メンバー初期化 .

.. code-block:: c++
  
  struct Base
  { 
      Base( int ) { }
  } ;
  
  struct Derived : Base
  {
      int member1 ;
      int member2 ;
  
      Derived()-
      // コンストラクター初期化子
          : Base( 0 ), // 基本クラス
          member1( 0 ), // メンバー
          member2{ 0 } // メンバー（初期化リスト）
      { }
  } ;


非修飾のメンバー初期化識別子は、まずコンストラクターのクラスのスコープ内で名前探索され、見つからなかった場合は、基本クラスのスコープから探される。そのため、基本クラスの名前と、クラスの非staticデータメンバーの名前が衝突した場合、必ずメンバーの名前が使われる。その場合、基本クラスを指定するには、修飾名を用いなければならない。



.. code-block:: c++
  
  struct Base { } ;
  
  struct Derived : Base
  {
      int Base ;
      Derived() :
          Base(), // Derivedの非staticデータメンバー
          Derived::Base() // 基本クラス
      { }
  } ;


メンバー初期化識別子として使える名前は、直接の基本クラスと、Virtual基本クラス、コンストラクターのクラスの非staticデータメンバーである。



.. code-block:: c++
  
  struct A { } ;
  struct B { } ;
  struct C : B, virtual A { } ;
  struct D : C
  {
      D() :
          C(), // OK
          A()  // OK
          // BはDの直接の基本クラスではないので使えない
      { }
  } ;


メンバー初期化子識別子には、基本クラスの型を指し示すtypedef名やdecltype指定子を使うこともできる。



.. code-block:: c++
  
  struct A { } ;
  typedef A type ;
  struct B { } ;
  B b ;
  
  struct C : A
  {
      C() : type(), decltype(b)()
      { }
  } ;


複数の<a href="#variant_member">共用メンバー</a>のうちの、ひとつだけを、メンバー初期化子で初期化することができる。



.. code-block:: c++
  
  union U
  {
      int a ; int b ;
      U() : a(0) { } // OK、ひとつだけ
  } ;
  
  struct S
  {
      union { int a ; int b ; } ;
      S() : a(0) { } // OK ひとつだけ
  } ;
  
  union Error
  {
      int a ; int b ;
      Error() : a(0), b(0) // エラー、複数の指定
      { }
  
  } ;


同じunionのメンバーである共用メンバーは、オブジェクト上のストレージを共有しているので、複数初期化することはできない。




メンバー初期化子に、同じメンバー名、あるいは基本クラス名を、複数指定することはできない。



struct Base { } ;
struct Derived : Base
{
    int member ;
    Derived()
    : member(), member(), // エラー、同じメンバー名
      Base(), Base() // エラー、同じ基本クラス名
    { }          
} ;



コンストラクターのデリゲートについては、<a href="#deligating.constructor">コンストラクターのデリゲート</a>を参照。




メンバー初期化が明示的に指定されておらず、アブストラクトクラスのvirtual基本クラスでもない非staticデータメンバーと基本クラスは、次のように初期化される。



非staticデータメンバーに初期化子が指定されている場合、<a href="#dcl.init">初期化子</a>の方法に従って初期化される。



.. code-block:: c++
  
  struct S
  {
      int member = 123 ;
      S() /*メンバー初期化子によるmemberの指定なし*/ { }
  } ;


この例では、memberは、123で初期化される。



共用メンバーの場合、初期化されない。



.. code-block:: c++
  
  union U
  {
      int member ;
      U() /*メンバー初期化子による共用メンバー指定なし*/ { }
  } ;
  
  struct S
  {
      union { int member ; } ;
      S() /*メンバー初期化子による共用メンバーの指定なし*/ { }
  } ;
  
  union initialize
  {
      int member ;
      initialize() : m1(0) { } // m1を0で初期化
  } ;


共用メンバーには、明示的な初期化が必要である。



それ以外の場合、<a href="#dcl.init.default-initialize">デフォルト初期化</a>される。



.. code-block:: c++
  
  struct X { X() { } } ;
  
  struct S
  {
      int m1 ; 
      X m2 ;
      S() { }
  } ;


この例では、int型の非staticデータメンバーm1の初期化処理は<a href="#dcl.init.default-initialize">デフォルト初期化</a>で定義されているように、何もしない。X型m2は、X型のデフォルトコンストラクターによって初期化される。



同じunionに属する非staticな共用メンバーは、ひとつしか初期化できない。



.. code-block:: c++
  
  union U
  {
      int m1 ; int m2 ;
      U() : m1(0), m2(0) { } // エラー
  } ;
  
  struct X
  {
      union { int m1 ; int m2 ; } ;
      X() : m1(0), m2(0) { } // エラー
  } ;
  
  struct Y
  {
      union { int m1 ; } ;
      union { int m2 ; } ;
      Y() : m1(0), m2(0) { } // OK、違うunionの共用メンバー
  } ;


Yの例は、違うunionの共用メンバーなので、問題のないコードである。



クラスのコンストラクターの実行が終了した時点で、初期化も明示的な値の設定もされていないメンバーの値は、不定である。



.. code-block:: c++
  
  struct X
  {
      int member ;
      X() { }
  } ;
  
  X x1 ; // staticストレージ上に構築されたオブジェクトは、ゼロ初期化されるので、x1.memberの値は0
  
  int main()
  {
      X x2 ; // x2.memberの値は不定
  }


非staticデータメンバーの宣言に初期化子があり、メンバー初期化子も指定されている場合、メンバー初期化子が優先される。この場合、メンバー宣言の初期化子は無視される。



.. code-block:: c++
  
  struct X
  {
      int member = 1;
      X() { } // memberは1で初期化される
      X( int arg ) : member( arg ) { } // memberはargで初期化される
  } ;
  
  
  int main()
  {
      X x1 ; // x1.memberの値は1
      X x2(2) ; // x2.memberの値は2
  }


デリゲートしていないコンストラクターにおける初期化は、以下のように行われる。



まず始めに、クラスが最も派生した型である場合、virtual基本クラスが初期化される。



.. code-block:: c++
  
  struct V { } ;
  
  struct B : virtual V { } ;
  struct C : B { } ;
  struct D : C { } ;
  
  int main()
  {
      D d ; // DのコンストラクターでVが初期化される
      C c ; // CのコンストラクターでVが初期化される。
      B b ; // BのコンストラクターでVが初期化される。
  }


virtual基本クラスは、最も派生したクラスで初期化されるということには、注意が必要である。例えば、以下のような場合、



.. code-block:: c++
  
  struct V
  {
      int member ;
      V( int arg ) : member( arg )  { }
  } ;
  
  struct B : virtual V
  {
      B() : V(1) { }
  } ;
  struct C : B { } ;
  
  int main()
  {
      C c ; // エラー、Vのデフォルトコンストラクターは暗黙にdelete定義されている。
  }


VはCで初期化されるので、Bによる初期化は、無視されてしまう。Cのメンバー初期化子には、Vは記述されていないので、Vはデフォルト初期化される。Vのデフォルトコンストラクターは暗黙にdelete定義されているので、エラーとなる。



複数のvirtual基本クラスを持つ場合、初期化の順番は、深度優先（depth-ﬁrst）かつ、左から右（left-to-right）となる。「深度」とは、基本クラスに行くほど深くなる。「左から右」とは、基本クラス指定子リストに現れるvirtual基本クラスの順番である。



.. code-block:: c++
  
  struct V1 { } ; struct V2 { } ; struct V3 { } ;
  
  struct B : virtual V1, virtual V2 { } ;
  struct C : B, virtual V3 { } ;
  
  C c ; // V1, V2, V3の順番で初期化される


<p class="editorial-note">
TODO: directed acyclic graphを表現する図



virtual基本クラスの初期化が終わった後で、直接の基本クラスが、基本クラス指定子リストに現れる順番で初期化される。メンバー初期化子は、初期化の順番に影響しない。



.. code-block:: c++
  
  struct B1 { } ; struct B2 { } ;
  struct D : B1, B2
  {
      D() : B2(), B1() { }
  } ;
  
  D d ; // B1, B2の順番に初期化される


メンバー初期化子は、初期化の順番に何の影響も与えないことに注意しなければならない。これは、副作用が初期化に影響をあたえるような場合、問題になる。



.. code-block:: c++
  
  int i ;
  
  struct B1 { B1(int) { } } ;
  struct B2 { B2(int) { } } ;
  
  struct D1 : B1, B2
  {
      D1() : B2(++i), B1(++i) { }
  } ;
  
  struct D2 : B2, B1
  {
      D2() : B2(++i), B1(++i) { }
  } ;
  
  int main()
  {
      i = 0 ;
      D1 d1 ; // B1(1)、B2(2)で初期化される
      D2 d2 ; // B2(1)、B1(2)で初期化される
  }


メンバー初期化子の順番は、基本クラスの初期化順序に影響しない。そのため、ある基本クラスの初期化における副作用が、次の基本クラスの初期化に影響をあたえるようなコードでは、基本クラスの記述の順番を変えるだけで、初期化の結果が異なってしまう。一般に、直接の基本クラスの初期化の順番が保証されていることを前提にしたコードを書くべきではない。



直接の基本クラスの初期化が終わった後で、クラス定義内の非staticデータメンバーが、宣言されている順番で初期化される。メンバー初期化子は、初期化の順番に影響しない。



.. code-block:: c++
  
  struct X
  {
      int m1 ;
      int m2 ;
      X() : m2(0), m1(0) { }
  } ;
  
  X x ; // m1, m2の順番で初期化される


直接の基本クラスの場合と同じく、メンバー初期化子は初期化の順番に影響しないということに注意しなければならない。非staticデータメンバーの初期化の順番は、クラス定義の中でメンバーが宣言されている順番である。したがって、あるメンバーの初期化の副作用が、次のメンバーの初期化に影響をあたえるようなコードでは、メンバーの宣言の順番を変えただけで、初期化処理が異なってしまう。具体的な問題例は、直接の基本クラスの場合と同じである。一般に、非staticデータメンバーの初期化の順番が保証されていることを前提にしたコードを書くべきではない。



最後に、コンストラクターの本体が実行される。



.. code-block:: c++
  
  struct V { } ;
  struct B { } ;
  struct M { } ;
  
  struct D : B, virtual V
  {
      M m ;
      D() { /* コンストラクターの本体*/ }
  } ;
  
  D d ; // V, B, m, コンストラクターの本体の順番で初期化される


メンバー初期化子における名前は、コンストラクターの本体で評価される。



.. code-block:: c++
  
  int  ;
  
  struct X
  {
      int x ;
      int y ;
      X() : x(0), y(x) { }
  } ;


メンバー初期化子では、thisを使うことができる。ただし、thisの参照先はまだ構築途中である場合もあるので、注意が必要である。




非staticメンバー関数は、virtual関数を含めて、構築中のオブジェクトであっても呼び出すことができる。また、構築途中のオブジェクトを、<a href="#expr.typeid">typeid演算子</a>や<a href="#expr.dynamic.cast">Dynamic cast（Dynamic cast）</a>のオペランドに渡すこともできる。



ただし、コンストラクター初期化子において、まだすべての基本クラスの初期化が終わっていない時点で、この種の操作を行った場合、結果は未定義である。これは、間接的に操作が行われる場合も含む。



.. code-block:: c++
  
  struct A { A(int) { } } ;
  struct B : A
  {
      int f() { return 0 ; }
      B() : A( f() ) // 結果は未定義
      { }
  } ;
  
  // 間接的に操作が行われる例
  struct C : A
  {
      static int call_f( C * ptr ) { return ptr->f() ; }
      int f() { return 0 ; }
      C() : A( call_f( this ) ) // 未定義
      { }
  } ;


構築中のオブジェクトに対してvirtual関数を呼び出したり、typeidやdynamic_castを使った場合の挙動は、<a href="#class.cdtor">生成と破棄</a>を参照。



メンバー初期化子では、パック展開できる。



.. code-block:: c++
  
  template < typename Bases >
  struct X : Bases...
  {
      X() : Bases()...
      { }
  } ;


コンストラクターのデリゲート
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



メンバー初期化識別子に、クラス型を指定することによって、別のコンストラクターに初期化処理をデリゲートすることができる。これを、コンストラクターのデリゲート(delegate)という



.. code-block:: c++
  
  struct X
  {
      int member ;
  
      X( int value ) : member( value )
      { /* 初期化処理 */ }
  
      X( double d ) : X(123) // コンストラクターのデリゲート
      {
          // 追加の処理
      }
  } ;


この例では、コンストラクターX::X(double)は、初期化処理をX::X(int)にデリゲートしている。



別のコンストラクターにデリゲートしているコンストラクターのことを、デリゲートコンストラクター(delegating constructor)といい、デリゲート先のコンストラクターのことを、ターゲットコンストラクター(target constructor)という。またオブジェクトの初期化のために最初に呼び出されたコンストラクターのことを、最初のコンストラクター(principal constructor)という。



.. code-block:: c++
  
  struct X
  {
      X() : X( 0 ) { }
      X( int ) : X( 0.0 ) { }
      X( double ) { }
  } ;
  
  X x ; // 初期化


上に例における、Xのオブジェクトxの初期化では、最初のコンストラクターとして、X::X()が選ばれる。これは、デリゲートコンストラクターであり、ターゲットコンストラクターであるX::X(int)にデリゲートする。X::X(int)もデリゲートコンストラクターであり、ターゲットコンストラクターのX::X(double)にデリゲートする。



デリゲートコンストラクターは、他のメンバー初期化識別子を指定してはならない。



.. code-block:: c++
  
  struct Base { } ;
  
  struct X : Base
  {
      int member ;
      X() : X( 0 ),
          Base(), member(0) // エラー、デリゲートコンストラクターは他の識別子を指定できない
      { }
      X( int ) { }
  } ;


ターゲットコンストラクターは、オーバーロード解決により選ばれる。



.. code-block:: c++
  
  struct X
  {
      X() : X( 0 ) { } // X::X(int)を呼ぶ
      X( int ) : X( 0.0 ) { } // X::X(double)を呼ぶ
      X( double ) { }
  } ;


ターゲットコンストラクターが処理を返した後に、デリゲートコンストラクターの本体が実行される。



.. code-block:: c++
  
  struct X
  {
      int member ;
      X() : X( 0 )
      { /* 処理2 */ }
      X( int value ) : member( value )
      { /* 処理1 */ }
  } ;
  
  X x ;


この例では、オブジェクトxの初期化の際、最初のコンストラクターとしてX::X()が選ばれる。これはデリゲートコンストラクターである。ターゲットコンストラクターは、X::X(int)となる。ターゲットコンストラクターは、通常のコンストラクターと同じように基本クラスやメンバーの初期化を終えた後、コンストラクターの本体を実行し（処理1）、処理を返す。ターゲットコンストラクターが処理を返したので、最初のコンストラクターの本体が実行される（処理2）。



デリゲートコンストラクターが、直接的にせよ、間接的にせよ、自分自身にデリゲートを行った場合は、エラーとなる。



.. code-block:: c++
  
  struct X
  {
      X() : X() {} // エラー、直接的な自分自身へのデリゲート
  } ;
  
  struct Y
  {
      Y() : Y(0) { } // エラー、間接的な自分自身へのデリゲート
      Y(int) : Y(0.0) { } // エラー、間接的な自分自身へのデリゲート
      Y(double) : Y() { } // エラー、間接的な自分自身へのデリゲート
  } ;


クラスYは、間接的に、自分自身へのデリゲートを行う例である。デリゲートのネスト、つまり他のデリゲートコンストラクターへのデリゲートは可能である。ただし、間接的であっても、自分自身へのデリゲートは認められない。







生成と破棄（Construction and destruction）
--------------------------------------------------------------------------------



クラスのオブジェクトが構築される前、破棄された後、あるいは構築や破棄の最中には、いくつか気を付けなければならないことがある。



非トリビアルコンストラクターを持つクラスのオブジェクトのコンストラクターの実行が始まる前に、非staticメンバーや基本クラスにアクセスした場合、挙動は未定義である。



.. code-block:: c++
  
  struct X
  {
      X() { } // 非トリビアルコンストラクター
      int member ;
  } ;
  
  
  int main()
  {
      X * ptr = static_cast<X *>( operator new( sizeof(X) ) )  ; // 初期化されていないストレージ
      ptr->member ; // 未定義
      &ptr->member ; // 未定義、ポインターを得ることもできない
      new(ptr) X ; // 初期化
      ptr->member ; // OK
      &ptr->member ; // OK
      operator delete( ptr ) ;
  }


非トリビアルデストラクターを持つクラスのオブジェクトのデストラクターの実行が終わった後に、非staticメンバーや基本クラスにアクセスした場合、挙動は未定義である。



.. code-block:: c++
  
  struct X
  {
      ~X() { } // 非トリビアルデストラクター
      int member ;
  } ;
  
  
  int main()
  {
      X * ptr = static_cast<X *>( operator new( sizeof(X) ) )  ; // 初期化されていないストレージ
      new(ptr) X ; // 初期化
      ptr->~X() ; // デストラクターの実行
  
      ptr->member ; // 未定義
      operator delete( ptr ) ;
  }


クラスへのポインターを、基本クラスへのポインターに型変換する際には、クラスとそのすべての基本クラスのコンストラクターの実行が始まっていなければならない。また、デストラクターの実行が完了していてはならない。そうでない場合の挙動は未定義である。これは、トリビアルクラスにも当てはまる。



.. code-block:: c++
  
  struct X { } ;
  struct Y : X { } ;
  
  int main()
  {
      Y * y_ptr = static_cast<Y *>( operator new( sizeof(Y) ) )  ; // 初期化されていないストレージ
  
      X * x_ptr = y_ptr ; // 未定義
      new (y_ptr) Y ; // 初期化
      x_ptr = y_ptr ; // OK
      y_ptr->~Y() ; // デストラクターの実行
      x_ptr = y_ptr ; // 未定義
  
      operator delete( y_ptr ) ;
  }


オブジェクトの構築や破棄の途中で、メンバー関数を呼び出すことはできる。ただし、virtual関数をコンストラクターやデストラクターの中で呼び出す際には、注意が必要である。virtual関数をコンストラクターやデストラクターの中、あるいはその中から呼び出された関数内で呼び出すと、そのコンストラクターあるいはデストラクターのクラスの型にとってのファイナルオーバーライダーが用いられ、派生クラスは考慮されない。これは、基本クラスのコンストラクターの実行中には、派生クラスはまだ完全に初期化されていないからである。



.. code-block:: c++
  
  struct A
  {
      virtual void f() { }
      virtual void g() { }
      // A::f、A::gを呼び出す
      A() { f() ; g() ;  }
      virtual ~A() { f() ; g() ; }
  } ;
  
  struct B : A
  {
      virtual void f () { }
      // B::f, A::gを呼び出す
      B() { f() ; g() ; }
      virtual ~B() { f() ; g() ; }
  } ;
  
  struct C : B
  {
      virtual void g() { }
      // B::f, C::gを呼び出す
      C() { f() ; g() ; }
      virtual ~C() { f() ; g() ; }
  } ;


この例で、たとえクラスCのオブジェクトを構築したとしても、基本クラスAのコンストラクターの中ではA::f, A::gが呼ばれることになる。



オブジェクトの構築や破棄の途中で、typeid演算子を使うことはできる。typeid演算子がコンストラクターやデストラクターの中、あるいはその中から呼び出された関数内で使われていて、typeid演算子のオペランドが、そのクラスの構築中のオブジェクトである場合、typeidはコンストラクターやデストラクターのクラス型情報を表すstd::type_infoオブジェクトを返す。これは、基本クラスの構築中は、まだ派生クラスは構築し終わっていないからである。



.. code-block:: c++
  
  struct A
  {
      A()
      {
          typeid( *this ) == typeid( A ) ; // true
      }
      virtual ~A()
      {
          typeid( *this ) == typeid( A ) ; // true
      } 
  } ;
  
  struct B : A { } ;


この例では、たとえBのオブジェクトが構築されたとしても、typeidはA型を表すstd::type_infoオブジェクトを返す。



オブジェクトの構築や破棄の途中で、dynamic_castを使うことはできる。dynamic_castがコンストラクターやデストラクターの中、あるいはその中から呼び出された関数内で使われていて、オペランドがそのクラスの構築中のオブジェクトである場合、コンストラクターやデストラクターの属するクラスが、最終的に派生された型であるとみなされる。これは、基本クラスの構築中は、まだ派生クラスは構築し終わっていないからである。



.. code-block:: c++
  
  struct A
  {
      A() ;
      virtual ~A() ;
  } ;
  
  struct B : A { } ;
  
  A::A()
  {
      B * ptr = dynamic_cast<B *>( this ) ; // 常にnullポインター
  }
  
  A::~A()
  {
      B * ptr = dynamic_cast<B *>( this ) ; // 常にnullポインター
  }


たとえ、Aから派生されたB型のオブジェクトであっても、Aのコンストラクター、デストラクターの中では、A型が最終的な派生クラスであるとみなされる。



クラスのコピーとムーブ
--------------------------------------------------------------------------------



<p class="editorial-note">
TODO: プログラミング上のコピーとムーブの解説へのリンク。



ここでは、クラスのコピーとムーブを行うための特別なコンストラクターと代入演算子の宣言について説明している。コピーとムーブのプログラミング上の意味については、[TODO]を参照。



クラスのオブジェクトは、初期化と代入によって、コピーもしくはムーブされる。コピーやムーブを行うためのコンストラクターと代入演算子を、それぞれ特別に、コピーコンストラクター、ムーブコンストラクター、コピー代入演算子、ムーブ代入演算子と呼ぶ。





コピーコンストラクター（copy constructor）とは、あるクラスXにおいて、非テンプレートなコンストラクターで、一つ目の仮引数の型が、X &amp;、const X &amp;、volatile X &amp;、const volatile X &amp;のいずれかであり、二つ目以降の仮引数は存在しないか、すべてデフォルト実引数があるものをいう。



.. code-block:: c++
  
  struct X
  {
      // コピーコンストラクター
      X( X & ) ;
      X( X const & ) ;
      X( X volatile & ) ;
      X( X const volatile & ) ; 
      X( X const &, int x = 0, int y = 0 ) ; // 二つ目以降の仮引数にデフォルト実引数がある
  
      // コピーコンストラクターではない
      X( ) ;
      X( int ) ;
      template < typename T >
      X( T ) ; // テンプレートコンストラクターはコピーコンストラクターではない
      X( X const &, short ) ; // 二つ目以降の仮引数にデフォルト実引数がない
  } ;


ムーブコンストラクター（move constructor）とは、あるクラスXにおいて、非テンプレートなコンストラクターで、一つ目の仮引数の型が、X &amp;&amp;、const X &amp;&amp;、volatile X &amp;&amp;、const volatile X &amp;&amp;のいずれかであり、二つ目以降の仮引数は存在しないか、すべてデフォルト実引数があるものをいう。



.. code-block:: c++
  
  struct X
  {
      X( X && ) ;
      X( X const && ) ;
      X( X volatile && ) ;
      X( X const volatile && ) ;
      X( X const &&, int x = 0 ) ;
  } ;


クラスXのコンストラクターの一つ目の仮引数の型がXで、二つ目以降の仮引数が存在しないか、すべてデフォルト実引数が指定されている場合は、エラーとなる。



.. code-block:: c++
  
  struct X
  {
      X( X ) ; // エラー
  } ;


また、テンプレートコンストラクターのインスタンス化の結果が、このようなシグネチャになる場合、そのテンプレートはインスタンス化されない。



.. code-block:: c++
  
  struct X
  {
      template < typename T >
      X( T ) { } // X<X>というインスタンス化は起こらない。
  } ;
  
  int main()
  {
      X a( 0 ) ; // テンプレートコンストラクターが使われる。
      X b( a ) ; // 暗黙のコピーコンストラクターが使われる
  }


あるクラスにおいて、コピーコンストラクターが明示的に宣言されていない場合、コピーコンストラクターは暗黙的に宣言される。もし、クラスにユーザー定義のムーブコンストラクター、ムーブ代入演算子、コピー代入演算子、デストラクターが存在する場合、コピーコンストラクターは暗黙的にdelete定義される。そうでない場合は、default定義される。



.. code-block:: c++
  
  struct A
  {
      // コピーコンストラクターは暗黙的にdefault定義される
      // A( A const & ) = default ;
  } ;
  
  struct B
  {
      B( B && ) ; // ユーザー定義ムーブコンストラクター
      B & operator = ( B && ) ; // ユーザー定義ムーブ代入演算子
      B & operator = ( B & ) ; // ユーザー定義コピー代入演算子
      ~B() ; // ユーザー定義デストラクター
  
      // コピーコンストラクターは暗黙的にdelete定義される
      // B( B const & ) = delete ;
  } ;


クラスXの暗黙のコピーコンストラクターのシグネチャは、通常、



.. code-block:: c++
  
  X::X( const X & )


となる。ただし、直接の基本クラスやvirtual基本クラス、非staticデータメンバーがconst修飾されていない仮引数のコンストラクターを持つ場合、



.. code-block:: c++
  
  X::X( X & )


となる。



.. code-block:: c++
  
  struct A
  {
      A() = default ;
      A( A const & ) { }
  } ;
  
  struct B : A
  {
  // 暗黙のコピーコンストラクターのシグネチャ
  // B( B const & ) = default ;
  } ;
  
  struct C
  {
      C() = default ;
      C( C & ) { }
  } ;
  
  struct D : C
  {
  // 暗黙のコピーコンストラクターのシグネチャ
  // D( D & ) = default ;
  } ;


あるクラスにおいて、ムーブコンストラクターが明示的に宣言されていない場合、ムーブコンストラクターは暗黙的に宣言される。もし、あるクラスがユーザー定義の、コピーコンストラクター、コピー代入演算子、ムーブ代入演算子、デストラクターを持たず、またムーブコンストラクターがdelete定義されていない場合、ムーブコンストラクターはdefault定義される。



ユーザー定義のムーブ代入演算子が存在する場合、ムーブコンストラクターは暗黙的にdefault定義されない。これは、デフォルトのムーブコンストラクターの挙動と、ユーザー定義のムーブ代入演算子の挙動が異なる可能性があるため、安全のためにdefault定義されないのである。



.. code-block:: c++
  
  struct X
  {
      // ムーブコンストラクターはdefault定義されない
  
      // ユーザー定義のムーブ代入演算子
      X & operator = ( X && obj )
      {
          // ユーザー定義のムーブを実装
      }
  } ;


そのため、自前実装のムーブ構築とムーブ代入を行いたい場合、ムーブコンストラクターとムーブ代入演算子を両方ユーザー定義する必要がある。



ムーブコンストラクターが、暗黙にも明示的にも宣言されていない場合、ムーブコンストラクターを呼び出す式は、代わりにコピーコンストラクターを呼び出す。



.. code-block:: c++
  
  struct X
  {
      X() = default ;
      // ユーザー定義のコピーコンストラクター
      X( X const & ) { }
      // ムーブコンストラクターは宣言されない
  } ;
  
  
  int main()
  {
      X a ;
      // コピーコンストラクターを呼び出す
      X b( static_cast< X && >( a ) ) ;
  }


クラスXの暗黙のムーブコンストラクターのシグネチャは、以下の通りである。



.. code-block:: c++
  
  X::X( X && )


あるクラスが以下の条件を満たした時、コピー/ムーブコンストラクターはdelete定義される。




* 
  
クラスがunionのようなクラスで、共用メンバーがそれぞれ非トリビアルなコピー/ムーブコンストラクターを持つ場合、対応するコンストラクターがdelete定義される。



  .. code-block:: c++  
    
    struct NonTrivial
    {
        NonTrivial( NonTrivial const & ) { }
        NonTrivial( NonTrivial && ) { }
    } ;
    
    struct X
    { 
        X() { }
        union { NonTrivial n ; } ;
        // コピーコンストラクターは、nが非トリビアルなコピーコンストラクターを持つためにdelete定義される
        // ムーブコンストラクターは、nが非トリビアルなムーブコンストラクターを持つためにdelete定義される。
    } ;
  


* 
  






<p class="editorial-note">
TODO:あとで書く


コンストラクター継承（Inheriting constructors）
--------------------------------------------------------------------------------



using宣言を使って派生クラスから基本クラスのコンストラクターを指定することで、基本クラスのコンストラクターを明示的に継承できる。これにより、機械的な手書きのコードを省くことができる。



.. code-block:: c++
  
  class Base
  {
  private :
      int member ;
  public :
      Base( int value ) : member(value) { }
  } ;
  
  class Derived : Base
  {
  public :
      // Base::Base(int)を継承
      using Base::Base ;
  } ;
  
  int main()
  {
      Derived d(0) ; // 継承コンストラクターを使う
  }


using宣言は通常通り、アクセス指定の影響を受けることに注意すること。派生クラスによって継承された基本クラスのコンストラクターは、同じ仮引数をとり、引数をそのままメンバー初期化子で基本クラスに渡し、関数本体は空であるコードを手書きした場合と同じように動く。



.. code-block:: c++
  
  struct Base { Base(int, double) { } } ;
  struct Derived : Base
  {
      // Baseクラスのコンストラクターの継承
      using Base::Base ;
      // 以下のコードを手書きした場合と同等
      // Derived( int p1, double p2 )
      // : Base( p1, p2 )
      // { }
  } ;


このような手書きのコンストラクターを、実際に使うとエラーとなる場合、継承コンストラクターの使用もエラーとなる。



派生クラスで同じシグネチャーのコンストラクターをユーザー定義した場合、そのコンストラクターの継承は起こらない。



.. code-block:: c++
  
  struct Base
  {
      Base( int ) { }
      Base( double ) { }
  } ;
  struct Derived : Base
  {
      using Base::Base ;
  
      Derived( int value ) : Base(value)
      {
          // 処理
      }
  }


この場合、Base::Base(double)は継承されるが、Base::Base(int)は継承されない。クラスDerivedでユーザー定義されたコンストラクターが使用される。



継承コンストラクターの詳細はすこし難しい。まず、継承される基本クラスのコンストラクターが、継承コンストラクターの候補(candidate set of inherited constructors)として列挙される。この際、コンストラクターにデフォルト実引数がある場合は、デフォルト実引数を省略したシグネチャーの関数も追加される。たとえば、以下のようなクラスの場合、



.. code-block:: c++
  
  struct A
  {
      A( int i ) { }
  } ;
  
  struct B
  {
      A( int p1 = 1, int p2 = 2 ) { }
  } ;


クラスAの継承コンストラクターの候補は、以下の通り。



.. code-block:: c++
  
  A( int )
  A( A const & )
  A( A && )


クラスBの継承コンストラクターの候補は、以下の通り。



.. code-block:: c++
  
  B( ) // デフォルト実引数の省略形
  B( int = 1 ) // デフォルト実引数の省略形
  B( int = 1, int = 2 )
  B( B const & )
  B( B && )


さて、この継承コンストラクターの候補から、引数を取らないコンストラクター（デフォルトコンストラクター）、引数をひとつだけ取るコピー/ムーブコンストラクターを除くコンストラクターが継承コンストラクターとなる。これらのコンストラクターは、派生クラス側で暗黙に宣言されるものだからだ。ただし、派生クラスで同じシグネチャーのコンストラクターがユーザー定義されている場合は、継承されない。



いくつか例を示す。



.. code-block:: c++
  
  struct Base
  {
      Base( int ) { }
  } ;
  
  struct Derived : Base
  {
      using Base::Base ;
  } ;


この場合、クラスDerivedのコンストラクターは、以下のようになる。



.. code-block:: c++
  
  Derived( ) // 継承コンストラクターではない。使うとエラーになる
  Derived( int ) // クラスBから継承されたコンストラクター
  Derived( Derived const & ) // 継承コンストラクターではない
  Derived( Derived && ) // 継承コンストラクターではない


デフォルトコンストラクターやコピー/ムーブコンストラクターは継承されないので、通常通りの挙動になる。この場合、クラスBaseのデフォルトコンストラクターは暗黙に宣言されていないし、ユーザー定義もされていないため、使うとエラーになる。



.. code-block:: c++
  
  struct A
  {
      A( int ) { }
  } ;
  
  struct B
  {
      B( int ) { }
  } ;
  
  struct C : A, B
  {
      using A::A ;
      using B::B ;
  // エラー、宣言の重複
  } ;
  
  struct D : A, B
  {
      using A::A ;
      using B::B ;
      D( int x ) : A(x), B(x) { } // OK、ユーザー定義を優先
  }


クラスCでは、C(int)を重複して宣言してしまうので、エラーとなる。クラスDでは、ユーザー定義があるために、コンストラクターの継承は起こらない。もっとも、この場合、using宣言を使ってコンストラクターを継承する意味がない。








