
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>派生クラス（Derived classes） &mdash; C++11: Syntax and Feature</title>
    
    <link rel="stylesheet" href="_static/cpp-book.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="C++11: Syntax and Feature" href="index.html" />
    <link rel="next" title="メンバーのアクセス指定（Member access control）" href="class.access.html" />
    <link rel="prev" title="クラス（Classes）" href="class.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="class.access.html" title="メンバーのアクセス指定（Member access control）"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="class.html" title="クラス（Classes）"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="derived-classes">
<h1>派生クラス（Derived classes）<a class="headerlink" href="#derived-classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="multiple-base-classes">
<h2>複数の基本クラス（Multiple base classes）<a class="headerlink" href="#multiple-base-classes" title="Permalink to this headline">¶</a></h2>
<p>基本クラスは、複数指定することができる。これを、複数の基本クラスという。複数の基本クラスを指定することを、俗に、多重継承（Multiple Inheritance）ということがあるが、これは、C++の規格上、正しい用語ではない。継承は、基本クラスのメンバーを派生クラスも受け継ぐことを意味する用語であって、クラスの派生関係を表すのに使う言葉ではないからだ。</p>
<p>ただし、歴史的に言えば、Multiple Inheritanceという言葉を最初に使ったのは、他ならぬBjarne Stroustrupご本人である。当時、Stroustrup氏が複数の基本クラスの設計をしていた時に使った言葉が、多重継承であった。ちなみに、多重継承が初めて使われたコードは、Jerry Schwarzによって書かれたiostreamである。</p>
<p>複数の基本クラスは、コンマで区切ることによって指定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span>
     <span class="o">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この例では、Dは、A、B、Cという3個の基本クラスを持っている。</p>
<p>同じクラスを複数、直接の基本クラスとして指定することは出来ない。間接の基本クラスとしては指定できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span>
     <span class="o">:</span> <span class="n">Base</span><span class="p">,</span> <span class="n">Base</span> <span class="c1">// エラー、直接の基本クラス</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived2</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived3</span>
     <span class="o">:</span> <span class="n">Derived1</span><span class="p">,</span> <span class="n">Derived2</span> <span class="c1">// OK、間接の基本クラス</span>
    <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この場合、Derived3は、Baseクラスのサブオブジェクトを、2個持つことになる。</p>
<p>基本クラスに、virtualが指定されていない場合、非virtual基本クラス（non-virtual base class）となる。非virtual基本クラスには、それぞれ独立したサブオブジェクトが割り当てられる。</p>
<p>&lt;p class=&#8221;editorial-note&#8221;&gt;
TODO: 派生階層を表現する図</p>
<p>同じクラスが複数、非virtual基本クラスとして存在することは、基本クラスのメンバーの名前に対するオブジェクトが容易に曖昧になる。このとき、派生クラスから基本クラスのメンバーを使うには、名前を正しく修飾しなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">member</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived2</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// Derived3には、2個のBaseサブオブジェクトが存在する</span>
<span class="k">struct</span> <span class="n">Derived3</span> <span class="o">:</span> <span class="n">Derived1</span><span class="p">,</span> <span class="n">Derived2</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">member</span> <span class="p">;</span> <span class="c1">// エラー、曖昧</span>
        <span class="n">Base</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span> <span class="c1">// エラー、曖昧</span>
        <span class="n">Derived1</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span> <span class="c1">// OK</span>
        <span class="n">Derived2</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived3</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">x</span><span class="p">.</span><span class="n">member</span> <span class="p">;</span> <span class="c1">// エラー、曖昧</span>
    <span class="n">x</span><span class="p">.</span><span class="n">Derived1</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">x</span><span class="p">.</span><span class="n">Derived2</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、staticメンバーの名前は、曖昧にならない。これは、staticメンバーの利用には、クラスのオブジェクトは必要ないからである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">static_member</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">static_data_member</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">Base</span><span class="o">::</span><span class="n">static_data_member</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived2</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived3</span> <span class="o">:</span> <span class="n">Derived1</span><span class="p">,</span> <span class="n">Derived2</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">static_member</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
        <span class="n">static_data_member</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>直接、間接の両方の基本クラスに、同じクラスを持つことは可能である。ただし、そのような派生クラスは、基本クラスの非staticメンバーを使うことができない。なぜなら、基本クラスの名前自体の曖昧性を解決する方法がないからだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">member</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 非staticメンバー</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">static_member</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// staticメンバー</span>
<span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived1</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// Baseという名前自体が曖昧になる</span>
<span class="k">struct</span> <span class="n">Derived2</span> <span class="o">:</span> <span class="n">Base</span><span class="p">,</span> <span class="n">Derived1</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// Baseの非staticメンバーを使う方法はない</span>

        <span class="n">static_member</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、staticメンバーは使える</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>このため、直接、間接の両方で同じクラスを基本クラスに持つ派生クラスの利用は、かなり制限される。</p>
<p>基本クラスに、virtualが指定されている場合、virtual基本クラス（virtual base class）という。virtual基本クラスには、ひとつしかオブジェクトが割り当てられない。virtual基本クラスのオブジェクトは、派生クラスで共有される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">L</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">L</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">L</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">C</span> <span class="o">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>&lt;p class=&#8221;editorial-note&#8221;&gt;
TODO: クラス階層を表す図</p>
<p>この例で、Cクラスには、Lのサブオブジェクトは1個存在する。これは、A、Bで共有される。</p>
<p>virtual基本クラスでは、サブオブジェクトが共有されているため、virtual基本クラスのメンバーは、曖昧にならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">member</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived1</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived2</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived3</span> <span class="o">:</span> <span class="n">Derived1</span><span class="p">,</span> <span class="n">Derived2</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">member</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>非virtual基本クラスとvirtual基本クラスは、両方持つことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Y</span> <span class="o">:</span> <span class="k">virtual</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Z</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="o">:</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>&lt;p class=&#8221;editorial-note&#8221;&gt;
TODO:クラス階層を表す図</p>
<p>この例では、Aクラスには、Bのサブオブジェクトは、2個存在する。X、Yで共有されるサブオブジェクトと、Zのサブオブジェクトである。</p>
</div>
<div class="section" id="member-name-lookup">
<h2>メンバーの名前探索（Member name lookup）<a class="headerlink" href="#member-name-lookup" title="Permalink to this headline">¶</a></h2>
<p>メンバーの名前探索は、すこし難しい。派生クラスのメンバー名は、基本クラスのメンバー名を隠すということだ。あるメンバー名を名前探索する際に、派生クラスで名前が見つかった場合、その時点で名前探索は終了する。基本クラスのメンバーを探すことはない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">object</span><span class="p">;</span>
    <span class="n">object</span><span class="p">.</span><span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// Derived::f( double )が呼ばれる</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで、Derivedクラスには、二つのfという名前のメンバーが存在する。Derived::fとBase::fである。もし、名前探索によって両方の名前が発見された場合、オーバーロード解決によって、Base::f(int)が選ばれるはずである。しかし、実際には、Derived::f(double)が選ばれる。これは、Derivedクラスに、fという名前のメンバーが存在するので、その時点で名前探索が終了するからである。Baseのメンバー名は発見されない。名前が発見されない以上、オーバーロード解決によって選ばれることもない。</p>
<p>これは、名前探索に対するルールなので、型は関係がない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// fという名前のint型のデータメンバー</span>
<span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">f</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// fという名前のvoid (void)型のメンバー関数</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">object</span><span class="p">;</span>
    <span class="n">object</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// エラー、メンバー関数Derived::fに0を代入することはできない</span>
    <span class="n">object</span><span class="p">.</span><span class="n">Base</span><span class="o">::</span><span class="n">f</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// OK、明示的な修飾</span>
<span class="p">}</span>
</pre></div>
</div>
<p>したがって、基本クラスと同じ名前のメンバーを派生クラスで使う際には、注意が必要である。</p>
<p>名前探索という仕組みを考えずに、この挙動を考えた場合、これは、派生クラスのメンバー名が、基本クラスのメンバー名を、隠していると考えることもできる。もし、基本クラスのメンバー名を隠したくない場合、&lt;a href=&#8221;#namespace.udecl&#8221;&gt;using宣言&lt;/a&gt;を使うことができる。using宣言を使うと、基本クラスのメンバー名を、派生クラスのスコープに導入することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">f</span> <span class="p">;</span> <span class="c1">// using宣言</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Derived</span> <span class="n">object</span><span class="p">;</span>
    <span class="n">object</span><span class="p">.</span><span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// Base::f( int )が呼ばれる</span>
<span class="p">}</span>
</pre></div>
</div>
<p>名前探索で、派生クラスのメンバーが見つからない場合は、直接の基本クラスのメンバーから、名前が探される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">member</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">member</span> <span class="p">;</span> <span class="c1">// Base::member</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバー名を探す基本クラスは、直接の基本クラスだけである。間接の基本クラスのメンバーは、直接の基本クラスを通じて、探される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">member</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">C</span> <span class="o">:</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">member</span> <span class="p">;</span> <span class="c1">// A::member</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この例では、C::fでmemberという名前のメンバーを使っている。Cクラスにはmemberという名前のメンバーが見つからないので、名前探索はBクラスに移る。クラスは、基本クラスのメンバー名を継承している。そのため、Bクラスの基本クラスのAクラスのメンバー名は、Bクラスのスコープからも発見することができる。</p>
<p>直接の基本クラスが複数ある場合、それぞれの直接の基本クラスから、名前が探される。この際、複数のクラスから同じ名前が発見され、名前の意味が違う場合、名前探索は無効となる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base1</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">member</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Base2</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">member</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span> <span class="c1">// 複数の直接の基本クラス</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">member</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、名前探索が無効</span>
        <span class="n">Base1</span><span class="o">::</span><span class="n">member</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>これは、memberという名前に対し、複数の直接の基本クラスで、複数の同じ名前が見つかり、しかも意味が違っているので、名前検索が無効となる。その結果、memberという名前が見つからず、エラーとなる。</p>
<p>もし、この例で、Derivedから、明示的な修飾をせずに、両方の基本クラスのメンバー関数を呼び出したい場合、&lt;a href=&#8221;#namespace.udecl&#8221;&gt;using宣言&lt;/a&gt;が使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base1</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">member</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Base2</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">member</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base1</span><span class="p">,</span> <span class="n">Base2</span>
<span class="p">{</span>
    <span class="c1">// 基本クラスのメンバー名をDerivedスコープで宣言する</span>
    <span class="k">using</span> <span class="n">Base1</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span>
    <span class="k">using</span> <span class="n">Base2</span><span class="o">::</span><span class="n">member</span> <span class="p">;</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">member</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、オーバーロード解決により、Base1::member(int)が呼ばれる</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この例は、複数の直接の基本クラスがある場合の制限である。複数の間接の基本クラスでは、名前探索が失敗することはない。ただし、名前探索の結果として、複数の名前が発見され、曖昧になることはある。</p>
</div>
<div class="section" id="virtual-virtual-functions">
<h2>virtual関数（Virtual functions）<a class="headerlink" href="#virtual-virtual-functions" title="Permalink to this headline">¶</a></h2>
<p>本書のサンプルコードは、解説する文法のための最小限のコードであり、virtual関数を持つクラスがvirtualデストラクターを持たないことがある。これは現実ではほとんどの場合、不適切である。</p>
<p>メンバー関数にvirtual指定子を指定すると、virtual関数となる。virtual関数を宣言しているクラス、あるいはvirtual関数を継承しているクラスは、ポリモーフィッククラス（polymorphic class）となる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// virtual関数</span>
<span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>BaseとDerivedは、ポリモーフィッククラスである。</p>
<p>クラスがポリモーフィックであるかどうかということは、dynamic_castやtypeidを使う際に、重要である。</p>
<p>基本クラスのvirtual関数は、派生クラスのメンバーに、同じ名前、同じ仮引数リスト、同じCV修飾子、同じリファレンス修飾子という条件を満たすメンバー関数があった場合、オーバーライドされる。この時、派生クラスのメンバー関数は、virtual指定子がなくても、自動的にvirtual関数になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// オーバーライドしない</span>
<span class="k">struct</span> <span class="n">C</span> <span class="o">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// オーバーライド</span>
<span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// オーバーライドしない</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// オーバーライドしない</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// リファレンス修飾子が違う例</span>
<span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>もちろん、virtualをつけてもよい。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Bae</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span>  <span class="p">;</span> <span class="c1">// オーバーライド</span>
</pre></div>
</div>
<p>派生クラスで、最後にオーバーライドしたvirtual関数を、ファイナルオーバーライダー（final overrider）と呼ぶ。あるクラスのオブジェクトに対して、virtual関数を呼び出す際は、オブジェクトの実行時の型によって、最後にオーバーライドしたvirtual関数が呼び出される。これは、基本クラスのポインターやリファレンスを経由してオブジェクトを使った場合でも、同様である。通常のメンバー関数は、virtual関数とは違い、実行時の型チェックを行わない。オブジェクトを指しているリファレンスやポインターの型によって、決定される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// virtual関数と非virtual関数の違いの例</span>
<span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">virtual_function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="o">:</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">virtual_function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">C</span> <span class="o">:</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">virtual_function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">call</span><span class="p">(</span> <span class="n">A</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ref</span><span class="p">.</span><span class="n">virtual_function</span><span class="p">()</span> <span class="p">;</span>
    <span class="n">ref</span><span class="p">.</span><span class="n">function</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span> <span class="p">;</span> <span class="n">B</span> <span class="n">b</span> <span class="p">;</span> <span class="n">C</span> <span class="n">c</span> <span class="p">;</span>

    <span class="n">call</span><span class="p">(</span> <span class="n">a</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// A::virtual_function, A::functionが呼び出される</span>
    <span class="n">call</span><span class="p">(</span> <span class="n">b</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// B::virtual_function, A::functionが呼び出される</span>
    <span class="n">call</span><span class="p">(</span> <span class="n">c</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// C::virtual_function, A::functionが呼び出される</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Aは、virtual_functionとfunctionという名前のvirtual関数を持っており、Aから派生しているB、Bから派生しているCは、オーバーライドしている。call関数の仮引数refは、オブジェクトの型が、実際に何であるかは、実行時にしか分からない。virtual関数であるvirtual_functionは、オブジェクトの型に合わせて正しく呼び出されるが、virtual関数ではないfunctionは、Aのメンバーが呼び出される。</p>
<p>virt指定子(final, override)は、virtual関数の宣言子の後、pure指定子の前に記述できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// virt指定子の文法の例示のための記述</span>
<span class="k">virtual</span> <span class="n">f</span><span class="p">()</span> <span class="n">final</span> <span class="n">override</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
</pre></div>
</div>
<p>finalが指定されたvirtual関数を持つクラスから派生したクラスが、同virtual関数をオーバーライドした場合はエラーになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">derived</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="n">final</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">ok</span> <span class="o">:</span> <span class="n">derived</span>
<span class="p">{</span>
<span class="c1">// OK</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">error</span> <span class="o">:</span> <span class="n">derived</span>
<span class="p">{</span>
    <span class="c1">// エラー、final指定されているderived::fをオーバーライド</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>virtual関数にfinalを指定すると、それ以上のオーバーライドを禁止できる。</p>
<p>overrideが指定されたvirtual関数が、基本クラスのメンバー関数をオーバーライドしていない場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">virtual_function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">ok</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="c1">// OK、ok::virtual_functionはbase::virtual_functionをオーバーライドしている</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">virtual_function</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">typo</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="c1">// OK、typo::virtal_functionはbase::virtual_functionとは別のvirtual関数</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">virtal_function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">error</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="c1">// エラー、error::virtal_functionはオーバーライドしていない</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">virtal_function</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>これにより、タイプミスによる些細な間違いをコンパイル時に検出できる。</p>
<p>オーバーライドであることに注意。以下のコードはエラーである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 非virtual関数</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">error</span> <span class="o">:</span> <span class="n">base</span>
<span class="p">{</span>
    <span class="c1">// エラー、オーバーライドしていない</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="n">override</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>finalとoverrideを両方指定することもできる。</p>
<p>virtual関数をオーバーライドする関数は、戻り値の型が同じでなくても構わない。ただし、何でもいいというわけではない。戻り値の型は、まったく同じ型か、相互変換可能（covariant）でなければならない。covariantは、以下のような条件をお互いに満たした型のことである。</p>
<p>今、関数D::fが、関数B::fをオーバーライドしているとする。</p>
<div class="highlight-c++"><pre>// D::f、B::fの例
struct B { virtual 戻り値の型 f() ; } ;
struct D : B { virtual 戻り値の型 f() ; } ;</pre>
</div>
<p>その場合、戻り値の型は、以下の条件を満たさなければならない。</p>
<p>お互いにクラスへのポインター、もしくは、お互いにクラスへのlvalueリファレンス、もしくは、お互いにクラスへのrvalueリファレンスであること。</p>
<hr class="docutils" />
<p>片方がポインターで片方がリファレンスの場合や、片方がlvalueリファレンスで片方がrvalueリファレンスの場合は、不適である。もちろん、ポインターでもリファレンスでもない型は不適である。また、クラスでもない型へのポインターやリファレンスも不適である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ポインター</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">B</span> <span class="o">*</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">*</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// lvalueリファレンス</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">B</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// rvalueリファレンス</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">B</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>B::fの戻り値の型のクラスは、D::fの戻り値の型のクラスと同じか、曖昧がなくアクセスできる基本クラスでなければならない。</p>
<hr class="docutils" />
<p>オーバーライドしている関数が、基本クラスを戻り値に使っていたり、そもそもクラスの派生関係にない場合は、不適である。private派生していて、派生クラスからはアクセスできない場合や、基本クラスのサブオブジェクトが複数あって曖昧な場合はエラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// 基本クラス</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// 派生クラス</span>
<span class="k">struct</span> <span class="n">Other</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// BaseやDerivedとは派生関係にないクラス</span>

<span class="c1">// クラスが同じ</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// B::fのクラスはD::fのクラスの基本クラス</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">Other</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>両方のポインターは同じCV修飾子を持たなければならない。D::fの戻り値の型のクラスは、B::fの戻り値の型のクラスと同じCV修飾子を持つか、あるいは少ないCV修飾子を持たなければならない。</p>
<hr class="docutils" />
<p>補足：ポインターに対するCV修飾子とは、T cv1 * cv2という型がある場合、cv2である。クラスに対するCV修飾子は、cv1である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int *に対するCV修飾子</span>
<span class="kt">int</span> <span class="o">*</span> <span class="k">const</span>
<span class="c1">// intに対するCV修飾子</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 両方のポインターは同じCV修飾子を持たなければならない例</span>

<span class="c1">// ポインターのCV修飾子はconst</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">B</span> <span class="o">*</span> <span class="k">const</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// OK</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">*</span> <span class="k">const</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラーのDクラスの例、ポインターのCV修飾子が一致していない</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">*</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">*</span> <span class="k">volatile</span> <span class="k">const</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">*</span> <span class="k">const</span> <span class="k">volatile</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// D::fの戻り値の型のクラスは、B::fの戻り値の型のクラスと同じCV修飾子を持つか、</span>
<span class="c1">// あるいは少ないCV修飾子を持たなければならない例</span>

<span class="c1">// B::fの戻り値の型のクラスのCV修飾子はconst</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">B</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// 問題ないDクラスの例、CV修飾子が同じか少ない</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラーのDクラスの例、CV修飾子が多い</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="k">volatile</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">D</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span> <span class="k">virtual</span> <span class="n">D</span> <span class="k">const</span> <span class="k">volatile</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>明示的な修飾を用いた場合は、virtual関数呼び出しが阻害される。これは、オーバーライドしたvirtual関数から、オーバーライドされたvirtual関数を呼び出すのに使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// Derived::fの呼び出し</span>
        <span class="n">Base</span><span class="o">::</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 明示的なBase::fの呼び出し</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>virtual関数とdelete定義は併用できる。ただし、delete定義のvirtual関数を、非delete定義のvirtual関数でオーバーライドすることはできない。非delete定義のvirtual関数を、delete定義のvirtual関数でオーバーライドすることはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// OK、delete定義のvirtual関数を、delete定義のvirtual関数でオーバーライドしている</span>
<span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、非delete定義ではないvirtual関数を、delete定義のvirtual関数でオーバーライドしている</span>
<span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、delete定義のvirtual関数を、非delete定義のvirtual関数でオーバーライドしている</span>
<span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="abstract-classes">
<h2>アブストラクトクラス（Abstract classes）<a class="headerlink" href="#abstract-classes" title="Permalink to this headline">¶</a></h2>
<div class="highlight-c++"><pre>ピュア指定子:
    = 0</pre>
</div>
<p>アブストラクトクラス（abstract class）は、抽象的な概念としてのクラスを実現する機能である。これは、例えば図形を表すクラスである、CircleやSquareなどといったクラスの基本クラスであるShapeや、動物を表すDogやCatなどといったクラスの基本クラスであるAnimalなど、異なるクラスに対する共通のインターフェースを提供する目的に使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Shape</span>
<span class="p">{</span>
    <span class="c1">// 図形描画用の関数</span>
    <span class="c1">// Shapeクラスは抽象的な概念であり、具体的な描画方法を持たない</span>
    <span class="c1">// 単に共通のインターフェースとして提供される</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Circle</span> <span class="o">:</span> <span class="n">Shape</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* 円を描画 */</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Square</span> <span class="o">:</span> <span class="n">Shape</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* 正方形を描画 */</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">Shape</span> <span class="o">*</span> <span class="n">ptr</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">draw</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 実行時の型に応じて図形を描画する</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここでは、Shapeクラスというのは、具体的に描画する方法を持たない。そもそも、Shapeクラス自体のオブジェクトを使うことは想定されていない。このように、そのクラス自体は抽象的な概念であり、実体を持たない場合、ピュアvirtual関数を使うことで、共通のインターフェースとすることができる。</p>
<p>他の言語では、この機能を明確にクラスから分離して、「インターフェース」という名前の機能にしているものもある。C++では、抽象クラスも、制限はあるものの、クラスの一種である。</p>
<p>少なくともひとつのピュアvirtual関数を持つクラスは、アブストラクトクラスとなる。ピュアvirtual関数は、virtual関数の宣言に、ピュア指定子を書くことで宣言できる。</p>
<div class="highlight-c++"><pre>ピュア指定子:
    = 0</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">abstract_class</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ピュアvirtual関数には、定義を与えることはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="c1">// エラー</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この、=0という文法は、初期化子や代入式とは、何の関係もない。ただ、C++の文法上、メンバー関数の宣言の中の、=0というトークン列を、特別な意味を持つものとして扱っているだけである。ピュア指定子を記述する位置は、virt-specifierの後である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">f</span> <span class="p">;</span> <span class="p">}</span>
<span class="k">struct</span> <span class="n">abstract_class</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">new</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span><span class="c1">// virt-specifierの後</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>&lt;p class=&#8221;editorial-note&#8221;&gt;
TODO: virt-specifierに対する適切な訳語。これは将来のドラフトで変更されるかもしれない。</p>
<p>アブストラクトクラスは、他のクラスの基本クラスとして使うことしかできない。アブストラクトクラスのオブジェクトは、派生クラスのサブオブジェクトとしてのみ、存在することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">abstract_class</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">abstract_class</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>アブストラクトクラスのオブジェクトを、直接作ることはできない。これには、変数や関数の仮引数、new式などが該当する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">abstract_class</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、abstract_classのオブジェクトは作れない</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">abstract_class</span> <span class="n">param</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">abstract_class</span> <span class="n">obj</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="k">new</span> <span class="n">abstract_class</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>アブストラクトクラスへのポインターやリファレンスは使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">abstract_class</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// OK、ポインターとリファレンスはよい</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">abstract_class</span> <span class="o">*</span><span class="p">,</span> <span class="n">abstract_class</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>ピュアvirtual関数を継承していて、ファイナルオーバーライダーがピュアvirtual関数である場合も、アブストラクトクラスとなる。これは例えば、アブストラクトクラスから派生されているクラスが、ピュアvirtual関数をオーバーロードしていなかった場合などが、該当する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この場合、Derivedも、Baseと同じく、アブストラクトクラスになる。</p>
<p>派生クラスによって、ピュアvirtual関数ではないvirtual関数をオーバーライドして、ピュアvirtual関数にすることができる。その場合、派生クラスはアブストラクトクラスとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Base</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、Baseはアブストラクトクラスではない。Derivedはアブストラクトクラスである。</p>
<p>構築中、または破棄中のアブストラクトクラスのコンストラクターやデストラクターの中で、ピュアvirtual関数を呼び出した場合の挙動は、未定義である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

    <span class="c1">// この関数を、Baseのコンストラクターやデストラクターから呼ぶとエラー</span>
    <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
    <span class="p">{</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span>

    <span class="c1">// コンストラクター</span>
    <span class="n">Base</span><span class="p">()</span> <span class="c1">// エラー、未定義の挙動</span>
    <span class="p">{</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span>

    <span class="c1">// デストラクター</span>
    <span class="o">~</span><span class="n">Base</span><span class="p">()</span> <span class="c1">// エラー、未定義の挙動</span>
    <span class="p">{</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="c1">// Derivedはアブストラクトクラスではないので、問題はない</span>
    <span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span>
    <span class="o">~</span><span class="n">Derived</span><span class="p">()</span> <span class="p">{</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="class.access.html" title="メンバーのアクセス指定（Member access control）"
             >next</a> |</li>
        <li class="right" >
          <a href="class.html" title="クラス（Classes）"
             >previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ezoe Ryou.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>