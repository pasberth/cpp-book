字句規約（Lexical conventions）
================================================================================

翻訳単位（Separate translation）
--------------------------------------------------------------------------------



プログラムは、ソースファイルという単位に分割される。ソースファイルとは、プリプロセッサが実行された後のソースコードである。


ソースファイルの変換（Phase of translation）
--------------------------------------------------------------------------------



ソースファイルは、コンパイルにかけられる前に、変換される。この変換の詳しい定義は略すが、特に知っておくべき変換が、いくつかある。



基本ソース文字セットではない文字は、UCNに変換される。



変換前


.. code-block:: c++
  
  あ


変換後


.. code-block:: c++
  
  \u3042


TODO:行末バックスラッシュを説明するのはやめようかと思う。


行末の\（バックスラッシュ）と、それに続く改行は、取り除かれる。



変換前


.. code-block:: c++
  
  int \
  value \
  = 0 ;


変換後



.. code-block:: c++
  
  int value = 0 ;


この改行の除去のルールは、注意を要する。例えば、



変換前


.. code-block:: c++
  
  /\
  /\
  これはコメント
  int va\
  lue = 0 ;


変換後



.. code-block:: c++
  
  //これはコメント
  int value = 0 ;


連続する文字列リテラルのトークンは、連結される。



変換前


.. code-block:: c++
  
  "aaa"
  "bbb" ;


変換後


.. code-block:: c++
  
  "aaabbb" ;


文字セット（Character sets）
--------------------------------------------------------------------------------



C++は、ソースファイルの文字コードを定めていない。ソースファイル内の文字は、環境依存の文字コードで表現される。



基本ソース文字セット
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



基本ソース文字セット（basic source character set）とは、ソースファイルで使うことができる文字のことである。印字可能な文字は、以下の通り。



.. code-block:: c++
  
  a b c d e f g h i j k l m n o p q r s t u v w x y z
  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
  0 1 2 3 4 5 6 7 8 9
  _ { } [ ] # ( ) < > % : ; . ? * + - / ^ & | ! = , \ " '


上記に加えて、スペース、水平タブ、垂直タブ、フォームフィード、改行も使うことができる。



たとえば、ASCIIでいえば、@（アットマーク）や`（グレイヴ・アクセント）のような文字は、使われていない。




ユニバーサル文字名
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



ユニバーサル文字名（UCN：universal character name）とは、ISO/IEC 10646で定義されている文字コードのことである。この文字コードは、ユニバーサル文字セットと呼ばれている。また、厳密には同じではないが、俗に、Unicodeと呼ばれることもある。UnicodeはUnicodeで、別の規格があるのだが、実用上、どちらもコードポイントやエンコード方式に、差がないため、よく混同される。本書では、ユニバーサル文字セットや、UTFエンコードに関する解説は行わない。



Nを16進数の一文字とすると、\uNNNNは、UCSにおけるコードポイント、0000NNNNで表される文字という意味になり、\UNNNNNNNNは、NNNNNNNNで表される文字と同じ意味になる。



例：


.. code-block:: c++
  
  \u3042      あ
  \u3043      い
  \U00003044  う


このユニバーサル文字名は、リテラルやエスケープシーケンスではなく、もっと根本的に、文字と同等に扱われる。つまり、対応するユニバーサル文字として認識される。ユニバーサル文字名は、ソースコードのあらゆる場所で使うことができる。ソースコードのある場所に、ユニバーサル文字名を記述した場合、その場所に、対応するユニバーサル文字を記述したのと、全く同じ扱いがなされる。



ただし、生文字列リテラルの中では、ユニバーサル文字名は使えない。サロゲートの範囲のコードポイント(0xD800–0xDFFF)を指定することはできない。文字列リテラルの中では、ユニバーサル文字は実装により自動的にエンコードされるので、サロゲートコードポイントを明示的に使う必要はない。もし文字としてサロゲートコードポイントを使う必要があるならば、エスケープシーケンス\xが使える。文字リテラルや文字列リテラルの中以外では、コントロール文字の範囲のコードポイント(0x00–0x1F と 0x7F–0x9F)と、基本ソース文字セットに該当するコードポイントを指定することはできない。



.. code-block:: c++
  
  R"(\u3042)" ; // ユニバーサル文字名ではなく、文字通りに解釈されることに注意
  u8"\u00E3\u0081\u0082" ; // OK、u8"あ"と同じ
  
  u"\ud842\udfb7" ; // エラー、サロゲートコードポイントを明示的に使うことはできない
  u"\u00020bb7" ; // OK、u"𠮷"と同じ
  
  int \u0041 = 0 ; // エラー、ここで基本ソース文字セットは使えない
  int \u3042 = 0 ; // OK








トークン（Tokens）
--------------------------------------------------------------------------------



TODO:これは本当に必要な項目だろうか。この項目で定義されている、ホワイトスペースは、どこかで言及しておかなければならないが。むしろ、この項目を、空白とすべきか。


コメント（Comments）
--------------------------------------------------------------------------------



コメントには、二種類ある。/* */で囲まれた、複数行にわたるコメントと、//から始まり行末までの、一行コメントである。



.. code-block:: c++
  
  /* ここからコメント開始
  これはコメント
  これもコメント
  ここでコメント終わり*/
  
  // これは一行コメント。改行までがコメントとなる。


コメントは、/*、で始まり、*/で終わる。この形式のコメントは、ネストできない。



.. code-block:: c++
  
  /* これはコメント*/
  
  /*ここから
  
  
  
  ここまでコメント*/
  
  /* /* これはエラー。ネストしている。*/ */


//で始まるコメントは、行末までが、コメントとなる。これは、/**/形式のコメントの中にも、書くことができる。



.. code-block:: c++
  
  // これは一行コメント。行末までがコメントとなる。
  
  
  /*
  // これは正しいコード。
  */


識別子（Identifiers）
--------------------------------------------------------------------------------



識別子には、大文字小文字のアルファベット、_（アンダースコア）、数字、ユニバーサル文字名、その他の実装依存の文字が使える。大文字と小文字は区別される。



.. code-block:: c++
  
  int aaa ;
  int AAA ;// aaaとは別の識別子、大文字と小文字は、区別される。
  int bbb ;
  int this_is_an_identifier ;
  int n1234567890 ;
  int \u3042 ;// ユニバーサル文字名
  int 変数 ;


ただし、識別子の先頭は、数字から始まってはならない。



.. code-block:: c++
  
  // エラー
  int 0aaa ;


また、キーワードや予約語は、識別子として使うことができない。



.. code-block:: c++
  
  // エラー、templateはキーワードである。
  int template ;
  // エラー、andは代替表現である。
  int and ;


以下の識別子は、特定の文法上の場所で現れた場合に、特別な意味を持つ。これは俗に、文脈依存キーワードとも呼ばれている。



.. code-block:: c++
  
  final override


特定の文法は、識別子が現れることがない場所なので、この文脈依存キーワードは、通常通り何の問題もなく識別子として使うことができる。



.. code-block:: c++
  
  int final ; // OK
  int override ; // OK


以下のような記述も合法だ。



.. code-block:: c++
  
  // OK、クラス名finalをfinalに指定
  class final final { } ;
  
  struct base
  {
      virtual void override() { }
  }
  
  struct derived : base
  {
      // OK、virtual関数名overrideにoverrideを指定
      virtual void override() override { }
  } ;


予約語
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



予約語とは、C++の実装や標準ライブラリの実装のために予約されていて、使ってはならない名前のことである。ユーザーコードで予約語を使った場合、プログラムの動作は保証されない。



以下のいずれかの条件に当てはまる名前は、あらゆる利用を予約されている。


* ひとつのアンダースコアに大文字から始まる名前
* アンダースコアが二つ連続している、いわゆるダブルアンダースコアを含む名前


以下のコードは、すべて予約名を使っているので、エラーである。



.. code-block:: c++
  
  int _A ;    // アンダースコアに大文字から始まる名前は、予約されている。
  int __a ;   // ダブルアンダースコアを含む名前は、予約されている。
  int ___a ;  // 三つの連続したアンダースコアも、ダブルアンダースコアを含むので、使えない。
  int a__b ;  // 先頭以外でも、どこかにダブルアンダースコアが含まれている場合、使えない。
  int a__ ; // ダブルアンダースコアを含む
  int __ ; // ダブルアンダースコアを含む


ひとつのアンダースコアから始まる名前は、グローバル名前空間で、利用を予約されている。ただし、グローバル名前空間との名前の衝突が、時として、意外な結果をもたらすこともあるので、言語のルールの詳細を把握していない限り、利用はおすすめできない。



.. code-block:: c++
  
  // エラー、グローバル名前空間
  int _a ;
  
  // OK
  namespace NS { int _a ; }
  
  int main()
  {
      int _a ;// OK
  }


ひとつのアンダースコアだけの名前は、予約語ではない。



.. code-block:: c++
  
  int _ ; // OK
  int __ ; // エラー、ダブルアンダースコア


簡単にまとめると、アンダースコアから始まる名前は、使うべきではない。ダブルアンダースコアを含む名前は、あらゆる使用を禁止されている。



名前の衝突を防ぐため、しばしばC++の理解の浅い者によってアンダースコアが用いられるが、予約語と衝突した場合、コード自体の動作が保証されなくなってしまうので、名前の衝突を防ぐ目的でアンダースコアを使ってはならない。名前の衝突を防ぐためには、名前空間という言語機能がある。




キーワード（Keywords）
--------------------------------------------------------------------------------



C++では、以下のキーワードが使われている。これらのキーワードは、プログラム中で特別な意味を持つので、識別子に使うことはできない。



.. code-block:: c++
  
  alignof decltype goto reinterpret_cast try
  asm default if return typedef
  auto delete inline short typeid
  bool do int signed typename
  break double long sizeof union
  case dynamic_cast mutable static unsigned
  catch else namespace static_assert using
  char enum new static_cast virtual
  char16_t explicit noexcept struct void
  char32_t export nullptr switch volatile
  class extern operator template wchar_t
  const false private this while
  constexpr float protected thread_local
  const_cast for public throw
  continue friend register true


以下は、キーワードではないが、記号と同じ意味を持つので、識別子に使うことはできない。これは、代替表現（alternative representation）と呼ばれている。



.. code-block:: c++
  
  and and_eq bitand bitor compl not
  not_eq or or_eq xor xor_eq


リテラル（Literals）
--------------------------------------------------------------------------------



ここでは、リテラルについて解説している。型については、<a href="#basic.types">型（Types）</a>を参照。



整数リテラル（Integer literals）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



整数リテラルには、10進数リテラル、8進数リテラル、16進数リテラルがある。C++には、2進数リテラルは存在しない。



十進数リテラルには、0123456789の文字を使うことができる。



8進数リテラルには、01234567の文字を使うことができる。プレフィクス、0から始まる整数リテラルは、8進数リテラルである。



16進数リテラルには、0123456789, abcdef, ABCDEFの文字を使うことができる。大文字と小文字は、区別されない。プレフィクス、0xから始まる整数リテラルは、16進数リテラルである。



.. code-block:: c++
  
  //10進数リテラル
  1234 ;
  
  // 8進数リテラル
  01234 ;// 10進数では、668
  
  // 16進数リテラル
  0x1234 ;// 10進数では、4660


0xというプレフィクスが、16進数リテラルを表すのは、他のプログラミング言語でも、よくあることだ。しかし、C++では、8進数リテラルのプレフィクスが変わっている。これは、注意を要する。



.. code-block:: c++
  
  // if ( x == 8 ) と同じ。
  if ( x == 010 )


C++の8進数リテラルは、10進数と区別しにくいので、気をつける必要がある。



整数リテラルには、後ろにサフィックスをつけることができる。このサフィックスは、大文字小文字が区別されない。



サフィックス、u、Uは、整数リテラルの型が、unsignedであることを示す



.. code-block:: c++
  
  // signed int
  auto type1 = 0 ;
  
  // unsigned int
  auto type2 = 0u ;
  auto type3 = 0U ;


サフィックス、l、Lは、型がlong intであることを示す。サフィックス、ll、LLは、型がlong long intであることを示す。



.. code-block:: c++
  
  // long int
  auto type1 = 0l ;
  auto type2 = 0L ;
  // long long int
  auto type3 = 0ll ;
  auto type4 = 0LL ;


unsignedであることを示すサフィックスと、long int、またはlong long intであることを示すサフィックスは、組み合わせることができる。順番は、どちらでもいい。



.. code-block:: c++
  
  // unsigned long int
  auto type1 = 0ul ;
  auto type2 = 0lu ;


整数リテラルの型の決定は、複雑である。もし、10進数の整数リテラルの値が、intの範囲で表現できない場合は、long intが使われる。long intでも表現できない場合は、long long intが使われる。8進数と16進数の整数リテラルの場合は、unsigned int, unsigned long int, unsigned long long intも、考慮に入れられる。



ただし、l, Lというサフィックスが指定されている場合は、long int以降が使われる。u, Uが指定されている場合は、unsignedな整数型に限られる。



いずれの型でも、整数リテラルの値を表現できない場合は、ill-formedである。




浮動小数点数リテラル（Floating literals）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



浮動小数点数のリテラルは、10進数で記述する。



.. code-block:: c++
  
  1.0 ;
  123456789.0 ;
  3.14 ;
  0.00000001 ;


浮動小数点数リテラルには、e, Eに続けて、指数（exponent）を指定することができる。指数を指定すると、小数に、10の指数乗をかけた値になる。



.. code-block:: c++
  
  // 1 × 

浮動小数点数リテラルの型は、非常に簡単である。サフィックス、f, Fが指定されているリテラルの型は、float、サフィックスが指定されていない型は、double、サフィックス、l, Lが指定されている型は、long doubleである。このサフィックスは、大文字小文字が区別されない。



.. code-block:: c++
  
  // float
  auto f1 = 1.0f ;
  auto f2 = 1.0F ;
  
  // double
  auto d1 = 1.0 ;
  auto d2 = 1.0 ;
  
  // long double
  auto l1 = 1.0l ;
  auto l2 = 1.0L ;


もし、リテラルの値を、リテラルの型で、完全に表現できない場合は、最も近い値に丸められる。値をどのようにして丸めるかは、実装依存である。もし、リテラルの値を、リテラルの型で表現できない場合は、エラーとなる。




文字リテラル（Character literals）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



文字リテラルとは、ある一文字を表すリテラルのことである。文字リテラルは、以下のように記述する。



.. code-block:: c++
  
  ’x’     通常の文字リテラル（ordinary character literal）
  u’x’    char16_t型の文字リテラル
  U’x’    char32_t型の文字リテラル
  L’x’    wchar_t型の文字リテラル。


プレフィクスのついていない、'x'は、通常の文字リテラル（ordinary character literal）である。型は、charである。このリテラル内に書かれている一文字の値が、そのまま、リテラルの値になる。通常の文字リテラルの具体的な値については、実装依存である。



プレフィクス、Lのついている文字リテラル、L'X'は、ワイド文字リテラルである。型は、wchar_tである。このリテラル内に書かれている一文字の値が、そのまま、リテラルの値になる。ワイド文字リテラルの具体的な値については、実装依存である。



プレフィクス、uのついている文字リテラル、u'x'は、char16_t型の文字リテラルである。これは、一文字のユニバーサル文字セット内の、16bitで表現できるコードポイントに当たる文字を使うことができる。このエンコード方式は、UTF-16と呼ばれている。文字リテラルは、16bitで表せる一文字しか使えないので、サロゲートペアは使えない。もちろん、文字列リテラルでは、サロゲートペアもサポートされている。



プレフィクス、Uのついている文字リテラル、U'x'は、char32_t型の文字リテラルである。これは、一文字の任意のユニバーサル文字セット内の文字を使うことができる。このエンコード方式は、UTF-32と呼ばれている。



.. code-block:: c++
  
  // 型はchar、値は実装依存。
  auto ordinary_c = 'x' ;
  // 型はwchar_t、値は実装依存。
  auto wide_c = L'x' ;
  // 型は、char16_t、値は、0x3042。
  auto u16_c = u'あ' ;
  // 型は、char32_t、値は、0x00003042。
  auto u32_c = U'あ' ;


エスケープシーケンス
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



文字リテラルの中では、バックスラッシュは、特別なエスケケープシーケンスとして扱われる。そのため、バックスラッシュを直接使うことはできない。



エスケープシーケンスは、以下の通り。



.. code-block:: c++
  
  改行 new-line NL(LF) \n
  水平タブ horizontal tab HT \t
  垂直タブ vertical tab VT \v
  バックスペース backspace BS \b
  キャリッジリターン carriage return CR \r
  フォームフィード form feed FF \f
  アラート文字、ベル文字 alert BEL \a
  バックスラッシュ backslash \ \\
  疑問符 question mark ? \?
  単一引用符 single quote ’ \’
  二重引用符 double quote " \"


文字リテラルの中では、二重引用符と、疑問符は、そのまま使うことも出来る。



.. code-block:: c++
  
  '\n' ;  // 改行
  '\\' ; // バックスラッシュ
  
  // 二重引用符と疑問符は、そのまま使える。
  '"' ;   '\"' ;
  '\?' ;  '?' ;
  
  
  // エラー、バックスラッシュはエスケープシーケンスの始まりとみなされるため、使えない。
  '\' ;






文字列リテラル（String literals）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



文字列リテラル（String Literal）には、通常の文字列リテラル、UTF-8文字列リテラル、char16_t文字列リテラル、char32_t文字列リテラルが存在する。また、それぞれの文字列リテラルに対して、生文字列リテラル（Raw String Literal）という書き方ができる。



文字列リテラルの文法は、以下の通りである。



.. code-block:: c++
  


文字列リテラルは、<i>文字列</i>の内容で初期化される。ただし、文字列の一番最後には、null文字が付加される。



.. code-block:: c++
  
  // 以下の二行のコードは同じ意味である。
  char s[4] = { 'a', 'b', 'c', '\0' } ;
  char s[] = "abc" ;


文字列リテラルでは、文字リテラルと同じ、エスケープシーケンスが使える。ただし文字リテラルと違い、二重引用符は、そのまま使うことができないので、エスケープシーケンス、\"で表さなければならない。単一引用符、'は、そのまま使うことができる。それ以外は、文字リテラルのエスケープシーケンスと、違いはない。



文字列リテラルの型は、要素数nの、constな文字型の配列である。要素数は、文字列リテラル内の文字型の数 + 1である。+ 1は、null文字が付加されるためである。エスケープシーケンスや、ユニバーサル文字名は、一文字として認識される。文字型の数と、文字数とは、同じではない。なぜならば、エンコード方式によっては、ひとつの文字を、複数の文字型で表現するからである。これについては、後述する。



エンコード方式
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



エンコード方式には、実装依存のエンコード、UTF-8、UTF-16、UTF-32がある。



"..."のように、エンコーディングプレフィクス（Encoding Prefix）の指定されていない文字列は、通常の文字列リテラル（ordinary string literal）である。これは、実装依存のエンコード方式が使われる。



.. code-block:: c++
  
  "abcdefg" ;
  "hello" ;


u8"..."のように、u8というプレフィクスの指定されている文字列リテラルは、UTF-8文字列リテラルである。これは、UTF-8というエンコードが使われる



通常の文字列リテラルと、UTF-8文字列リテラルの型は、要素数nの、const charの配列である。



.. code-block:: c++
  
  // const char [4]
  "abc" ;
  u8"abc" ;
  // const char [1]
  "" ;
  u8"" ;


u"..."のように、小文字のuというプレフィクスの指定されている文字列リテラルは、UTF-16文字列リテラルである。これは、UTF-16というエンコードが使われる。



UTF-16文字列リテラルの型は、要素数nの、const char16_tの配列である。



.. code-block:: c++
  
  // const char16_t [4]
  u"abc" ;
  // const char16_t [1]
  u"" ;


U"..."のように、大文字のUというプレフィクスの指定されている文字列リテラルは、UTF-32文字列リテラルである。これは、UTF-32というエンコードが使われる。



UTF-32文字列リテラルの型は、要素数nの、const char32_tの配列である。



.. code-block:: c++
  
  // const char32_t [4]
  U"abc" ;
  // const char32_t [1]
  U"" ;


L"..."のように、Lというプレフィクスの指定されている文字列リテラルは、ワイド文字列リテラルである。これは、実装依存のエンコードが使われる。



ワイド文字列リテラルの型は、要素数nの、const wchar_tの配列である。



.. code-block:: c++
  
  // const wchar_t [4]
  L"abc" ;
  // const wchar_t [1]
  L"" ;




文字列リテラルの型は、配列であるので、標準変換の、<a href="#conv.array">配列からポインターへの型変換</a>で、ポインターへ、暗黙のうちに変換できる。しかし、C++11では、以前のC++にあった、互換性のための機能が、削られているので、注意を要する。



.. code-block:: c++
  
  // エラー
  char * ptr = "abc" ;
  // OK
  char const * ptr = "abc" '


なぜか。文字列リテラルの型は、constな文字型の配列である。constは、暗黙のうちに消しさることはできない。たとえば、int型の場合、これは、従来のC++でも、エラーである。



.. code-block:: c++
  
  int const a[4] = {0} ;
  // エラー
  int * ptr = a ;


今までは、互換性のためだけの理由で、文字型の配列に限り、constを暗黙のうちに消しさることが、特別に許されていた。しかし、そもそも、文字列リテラルへの変更は、未定義である。



.. code-block:: c++
  
  // エラー、未定義動作
  "abc"[0] = 'd' ;


このため、C++では、文字列リテラルは、constな文字型の配列であることが、1993年に決定された。本来、この時点で、constではない文字型へのポインターへの変換は、廃止されるべきであった。しかし、char *に文字列リテラルを代入している既存のコードが、あまりにも多いため、仕方なく、特別なルールを付け加えた。それが、この、文字型の配列に限り、constを消すことができるというルールである。



constを暗黙のうちに消し去ることができると、C++の型システムに穴があいてしまう。いままでは、互換性の問題から、仕方なくこのルールがあったが、C++11では、とうとう、この忌々しい穴は塞がれた。もし、どうしても、既存のコードを利用したい場合は、いくつか方法がある。



.. code-block:: c++
  
  // 既存の汚いコードの関数
  void f( char * ) ;
  
  // 配列を確保して、渡す。
  char temp[] = "abc" ;
  f( temp ) ;
  
  // const_castを使用する（非推奨）
  f( const_cast<char *>("abc") ) ;


そもそも、constではないポインターということは、そのポインターの参照先が、変更されるかもしれないということを意味している。つまり、この関数f()は、ポインターの参照先を書き換えるかもしれない。しかし、文字列リテラルの変更は、そもそも未定義である。したがって、f()には、書き換えられる配列を確保して、そのポインターを渡すのが、正しい。const_castは、f()が、既存のコードであり、今更修正できず、なおかつ、ポインターの参照先を変更しないと保証できる場合に限り、const_castを使うべきである。



これから書くコードは、もちろん、constをつけるべきである。本来、変更できないオブジェクトを、非constなポインターで参照できるということが、そもそも間違っている。C++11では、このような暗黙の型変換は存在しない。



文字列リテラルの型の要素数
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



文字列リテラルの型の要素数については、注意が必要である。エスケープシーケンスや、ユニバーサル文字名は、一文字として認識される。さらに、文字数＝要素数ではない。UTF-8によるエンコードは、一文字が、1～４バイトで表される。



たとえば、"abc"という文字列リテラルは、UTF-8では、以下のようにエンコードされる。二行のコードは、全く同じ意味である。


.. code-block:: c++
  
  char abc[] = u8"abc" ;
  char abc[4] = { 0x61, 0x62, 0x63, 0x00 } ;


末尾にnull文字が付加されることを除けば、このコードは、それほど難しくもない。いずれも、一文字がひとつの文字型で表現できる。では、"あ"という文字リテラルを、UTF-8で表現するとどうなるか。



.. code-block:: c++
  
  char str[] = u8"あ" ;
  char str[4] = { 0xe3, 0x81, 0x82, 0x00 } ;


UTF-8というエンコード方式では、"あ"（U+3042）を表現するのに、三つの要素が必要である。文字数＝要素数ではないということは、よく覚えて置かなければならない。



では、UTF-16はどうか。「あ」という文字に関しては、UTF-16は、ひとつの要素で表現できる。



.. code-block:: c++
  
  char16_t str[] = u"あ" ;
  char16_t str[2] = { 0x3042, 0x0000 } ;


しかし、UTF-16にも、サロゲートペアが存在する。例えば、「𠮷」(U+020bb7)という古い漢字は、以下のようにエンコードされる。



.. code-block:: c++
  
  char utf8[] = u8"𠮷" ;
  char utf8[5] = { 0xf0, 0xa0, 0xae, 0xb7, 0x00 } ;
  
  char16_t utf16[] = u"𠮷" ;
  char16_t utf16[3] = { 0xd842, 0xdfb7, 0x0000 } ;


このように、UTF-16でも、サロゲートペアが必要なコードポイントについては、二つの要素が必要である。またこの字の場合、UTF-8にいたっては、四つもの要素が必要になる。



UTF-32には、このような問題はない。



.. code-block:: c++
  
  char32_t utf32[] = U"𠮷" ;
  char32_t utf32[2] = { 0x00020bb7, 0x00000000 } ;


ユニバーサル文字セットや、UTFのエンコード方式の詳細は、本書の範疇を超えるので、これ以上深くは解説しない。



また、charとwchar_tのエンコード方式については、実装依存である。




生文字列リテラル（Raw String Literal）
@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@



文字列リテラルには、直接記述することができない文字が存在する。エスケープシーケンスや、ユニバーサル文字セットだ。その他、改行コードなども、直接記述することはできない。たとえば、以下の文字列を、文字列リテラルを使って書く場合、



.. code-block:: c++
  
  aaa
  bbb
  ccc
  \\\
  """


通常の文字列リテラルでは、以下のように書かなければならない。



.. code-block:: c++
  
  "aaa\nbbb\nccc\n\\\\\\\n\"\"\""


これは、非常に分かりにくい。そこで、C++には、生文字列リテラル（Raw String Literal）というものがある。これは、文字列を、そのままの形で書くことができる文字列リテラルである。文法は、以下のようになる。



.. code-block:: c++
  


実際の例は、以下の通り。



.. code-block:: c++
  
  // ""と同じ
  R"()" ;
  
  // "aaa\nbbb\nccc\n\\\\\\\n\"\"\""と同じ
  R"(aaa
  bbb
  ccc
  \\\
  """)" ;


生文字列リテラルの文字列には、バックスラッシュを含めて、あらゆる文字を書くことができる。二重引用符ですら書ける。



問題は、文法の都合上、「)"」という文字列が使えないことだ。これは、デリミターを指定すれば、使えるようになる。



.. code-block:: c++
  
  R"delimiter( )" )delimiter" ;


ただし、この場合、「)delimiter"」という文字列は、使うことができない。このデリミターは、16文字以内の、基本ソース文字セット内の文字からなる文字列でなければならない。



.. code-block:: c++
  
  // エラー、@という字は、基本ソース文字セットには存在しない。
  R"@()@" ;
  
  // エラー、17文字以上書くことはできない。
  R"12345678901234567()12345678901234567" ;


基本的に、デリミターは、どのような16文字以内の基本ソース文字セット内の文字列ならば、どのような組み合わせでもよいが、左右のデリミターが一致していなければならない。しかし、大抵の場合は、デリミターをわざわざ使う必要はない。



生文字列リテラルは、エンコーディングプレフィクスとともに使うことが出来る。



.. code-block:: c++
  
  u8R"" ;
  uR"" ;
  UR"" ;
  LR"" ;


生文字列リテラルと、文字列リテラルは、エンコードが同じである場合、連結できる。文字列リテラルのトークンの連結については、<a href="#lex.phases">ソースファイルの変換</a>を参照のこと。



.. code-block:: c++
  
  // "1\n2\n3456"
  R"(1
  2
  3)"
  "456" ;






boolリテラル（Boolean literals）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



boolリテラルは、bool型の真偽を表現するリテラルである。trueとfalseという、二つの値がある。



.. code-block:: c++
  
  bool t = true ;
  bool f = false ;




ポインターリテラル（Pointer Literals）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



C++には、nullポインターを表すリテラルが存在する。nullptrである。これは、あらゆるポインター型の、nullポインターを表す。



.. code-block:: c++
  
  void * pointer_to_void = nullptr ;
  int * pointer_to_int = nullptr ;


従来のC++では、NULLというマクロを使ったり、0を使ったりしてきた。しかし、マクロは問題が多いし、0にも、問題がある。nullポインターは、その内部表現の、すべてのビットが0であることを意味するのではない。ポインターが、何も参照していないということを表す、概念上のものである。そこで、nullptrという、nullポインターを表すポインターリテラルが存在する。従来のNULLや、単なる0のかわりに、nullptrを使うべきである。




ユーザー定義リテラル（User-defined literals）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



ユーザー定義リテラル（User-defined literal）とは、リテラルを、関数として定義できるようにする機能のことである。整数、浮動小数、文字、文字列に対するユーザー定義リテラルが存在する。



.. code-block:: c++
  
  // ユーザー定義整数リテラル
  123_x ;
  // ユーザー定義浮動小数リテラル
  1.23_x ;
  // ユーザー定義文字リテラル
  'a'_x ;
  // ユーザー定義文字列リテラル
  "abc"_x ;


ユーザー定義リテラルは、演算子のオーバーロードとして、定義する。詳しくは、<a href="#over.literal">ユーザー定義リテラル（User-defined literals）</a>を参照のこと。




