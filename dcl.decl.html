
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>宣言子（Declarators） &mdash; C++11: Syntax and Feature</title>
    
    <link rel="stylesheet" href="_static/cpp-book.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="C++11: Syntax and Feature" href="index.html" />
    <link rel="next" title="クラス（Classes）" href="class.html" />
    <link rel="prev" title="宣言（Declarations）" href="dcl.dcl.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="class.html" title="クラス（Classes）"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="dcl.dcl.html" title="宣言（Declarations）"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="declarators">
<h1>宣言子（Declarators）<a class="headerlink" href="#declarators" title="Permalink to this headline">¶</a></h1>
<div class="section" id="type-names">
<h2>型名（Type names）<a class="headerlink" href="#type-names" title="Permalink to this headline">¶</a></h2>
<p>キャスト、sizeof、alignof、new、typeidでは、型の名前を指定する。これには、型名が用いられる。型名とは、変数や関数を宣言する場合と同じ指定子と宣言子だが、名前を省略したものである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">value</span> <span class="p">;</span>         <span class="c1">// int型の変数</span>
<span class="kt">int</span>                 <span class="c1">// 型名</span>
<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>     <span class="c1">// 配列型の変数</span>
<span class="kt">int</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span>            <span class="c1">// 型名</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="p">;</span>    <span class="c1">// 関数ポインター型の変数</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">)</span>       <span class="c1">// 型名</span>
</pre></div>
</div>
<p>ただし、あまりにも複雑な型名は、typedefやエイリアス宣言でtypedef名を定義した方が分かりやすい。</p>
</div>
<div class="section" id="ambiguity-resolution">
<h2>曖昧解決（Ambiguity resolution）<a class="headerlink" href="#ambiguity-resolution" title="Permalink to this headline">¶</a></h2>
<p>宣言文は、文法上、曖昧になる場合がある。これは、通常気にする必要はない。ただし、まれにこの曖昧性に引っかかり、不可解なコンパイルエラーを引き起こす可能性がある。</p>
<p>仮引数名に無駄な括弧のある関数の宣言と、初期化式に関数形式のキャストを用いた変数の宣言は曖昧である。その場合、=が使われていると、初期化であるとみなされる。また、仮引数の周りの不必要な括弧は取り除かれる。その結果、変数の宣言のつもりで書いたコードが、関数の宣言とみなされてしまうことがある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="n">S</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="p">;</span>

    <span class="n">S</span> <span class="n">w</span><span class="p">(</span> <span class="kt">int</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">);</span> <span class="c1">// S(int)型の関数の宣言、dは仮引数名、無駄な括弧</span>
    <span class="n">S</span> <span class="n">x</span><span class="p">(</span> <span class="kt">int</span><span class="p">()</span> <span class="p">);</span> <span class="c1">// S(int)型の関数の宣言、仮引数名の省略、無駄な括弧</span>

    <span class="n">S</span> <span class="n">y</span><span class="p">(</span> <span class="k">static_cast</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">);</span> <span class="c1">// S型の変数yの宣言</span>
    <span class="n">S</span> <span class="n">z</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// S型の変数zの宣言</span>
<span class="p">}</span>
</pre></div>
</div>
<p>一般に、この曖昧解決の結果、変数を宣言したいのに、関数の宣言とみなされてしまい、コンパイルエラーになることがある。この文法上の曖昧性を避けるためには、static_castなどの他のキャストを使うか、=を使った初期化に書き換える必要がある。</p>
<p>関数形式のキャストと型名は、曖昧になることがある。例えば、int()というコードは、関数形式のキャストにも、int(void)型の関数の型名にも解釈できる。この場合、型名が期待される場所では、常に型名として解釈される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">int</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、intは関数形式のキャスト</span>
    <span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// エラー、int()は型名</span>
    <span class="n">C</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">())</span> <span class="p">;</span> <span class="c1">// エラー、int()は型名</span>
    <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="meaning-of-declarators">
<h2>宣言子の意味（Meaning of declarators）<a class="headerlink" href="#meaning-of-declarators" title="Permalink to this headline">¶</a></h2>
<p>&lt;a href=&#8221;#dcl.simple-declaration&#8221;&gt;単純宣言&lt;/a&gt;は、指定子と宣言子で構成される。</p>
<div class="highlight-c++"><pre>指定子 宣言子 ;</pre>
</div>
<p>宣言子は、必ず、識別子を持たなければならない。この識別子を、規格上では、宣言識別子（declarator-id）と名付けている。この識別子は、宣言される名前となる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">name1</span> <span class="p">;</span> <span class="c1">// name1はint型の変数の名前</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">name2</span> <span class="p">;</span> <span class="c1">// name2 はint *型の変数の名前</span>
<span class="kt">int</span> <span class="nf">name3</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// name3 はint (void)型の関数の名前</span>
</pre></div>
</div>
<p>static, thread_local, extern, register, mutable, friend, inline, virtual, typedefといった指定子は、この宣言子の識別子に適用される。</p>
<p>宣言子の識別子の意味は、指定子と宣言子の組み合わせによって決定される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 識別子aはint型の変数</span>
<span class="kt">int</span>     <span class="c1">// 指定子</span>
<span class="n">a</span> <span class="p">;</span>     <span class="c1">// 宣言子、</span>
<span class="c1">// 識別子bはint型のtypedef名</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="c1">// 指定子</span>
<span class="n">c</span> <span class="p">;</span>         <span class="c1">// 宣言子</span>
</pre></div>
</div>
<p>変数、関数、型は、すべてこの指定子と宣言子の組み合わせによって宣言される。宣言子は、識別子の他にも、様々な文法があり、それによって、指定子の型を変更する。これには、ポインター、リファレンス、メンバーへのポインター、配列、関数、デフォルト実引数がある。</p>
<div class="section" id="pointers">
<h3>ポインター（Pointers）<a class="headerlink" href="#pointers" title="Permalink to this headline">¶</a></h3>
<p>宣言子が以下のように記述されている場合、ポインターを意味する。</p>
<div class="highlight-c++"><pre>* CV修</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="o">*</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// intへのポインター型</span>
</pre></div>
</div>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>に続くCV修飾子は、ポインター型に対するCV修飾子として解釈される。</p>
<p>int * constは、指定子intへのポインターに対するconstである。intに対するconstではない。const int <a href="#id3"><span class="problematic" id="id4">*</span></a>とint const <a href="#id5"><span class="problematic" id="id6">*</span></a>はどちらも同じ型である。const intもint constも指定子だからだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">type1</span> <span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="n">type2</span> <span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">type3</span> <span class="p">;</span>
</pre></div>
</div>
<p>このように宣言されている場合、type1とtype2は同じ型である。type3は、type1やtype2とは別の型である。</p>
<p>宣言子の中に、ポインターは複数書くことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">obj</span> <span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">obj</span> <span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span> <span class="o">*</span> <span class="n">pp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">p</span> <span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span> <span class="o">*</span> <span class="o">*</span> <span class="n">ppp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pp</span> <span class="p">;</span>

<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="o">*</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// int const *へのポインター</span>
<span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// int * constへのポインター</span>
<span class="kt">int</span> <span class="o">*</span> <span class="o">*</span> <span class="k">const</span> <span class="n">c</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span> <span class="c1">// int *へのconstなポインター</span>
</pre></div>
</div>
<p>T * <a href="#id7"><span class="problematic" id="id8">*</span></a>という型は、T <a href="#id9"><span class="problematic" id="id10">*</span></a>へのポインターということになる。</p>
<p>リファレンスへのポインターは存在しない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="o">&amp;</span> <span class="o">*</span> <span class="n">ptr_to_ref</span> <span class="p">;</span> <span class="c1">// エラー、リファレンスへのポインターは存在しない</span>
</pre></div>
</div>
<p>ビットフィールドのアドレスを取得することは禁止されているので、ビットフィールドへのポインターも存在しない。</p>
<p>関数へのポインターや、配列へのポインターは存在する。ただし、記述がやや難しい。コードの可読性を挙げるために、これらの型や変数を宣言するには、typedefやエイリアス宣言、autoなどを使うという手もある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 型はvoid (void)</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_func</span><span class="p">)(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span> <span class="p">;</span>
    <span class="n">ref_func</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 関数呼び出し</span>

    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 型はint [5]</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr_array</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">array</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="references">
<h3>リファレンス（References）<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h3>
<p>宣言子が以下のように記述されている場合、リファレンスを意味する。</p>
<div class="highlight-c++"><pre>&amp; 識別子
&amp;&amp; 識別子</pre>
</div>
<p>&amp;amp;の場合、lvalueリファレンスとなり、&amp;amp;&amp;amp;の場合、rvalueリファレンスとなる。lvalueリファレンスとrvalueリファレンスは、ほとんど同じ働きをする。単にリファレンスといった場合、lvalueリファレンスとrvalueリファレンスの両方を指す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">obj</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">lvalue_reference</span> <span class="o">=</span> <span class="n">obj</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">rvalue_reference</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">obj</span> <span class="p">)</span> <span class="p">;</span>

    <span class="n">lvalue_reference</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// objに0を代入</span>
    <span class="n">rvalue_reference</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// objに0を代入</span>
<span class="p">}</span>
</pre></div>
</div>
<p>リファレンスは、CV修飾できない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">obj</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">obj</span> <span class="p">;</span> <span class="c1">// OK、int constへのリファレンス</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="k">const</span> <span class="n">b</span> <span class="o">=</span> <span class="n">obj</span> <span class="p">;</span> <span class="c1">// エラー、リファレンスへのCV修飾はできない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、typedefやテンプレート実引数にCV修飾子が使われた場合は、単に無視される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// typedefの例</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">;</span> <span class="c1">// OK、int constへのリファレンス</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">type</span> <span class="p">;</span>
    <span class="k">typedef</span> <span class="k">const</span> <span class="n">type</span> <span class="n">type2</span> <span class="p">;</span> <span class="c1">// type2の型はint &amp;</span>
    <span class="k">const</span> <span class="n">type</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">;</span> <span class="c1">// エラー、bの型はint &amp;</span>
<span class="p">}</span>

<span class="c1">// テンプレート実引数の例</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span> <span class="n">type</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">S</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="n">type</span> <span class="p">;</span> <span class="c1">// type はint &amp;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>typedefの例では、typeというtypedef名にconst修飾子が使われているが、これは単に無視される。したがって、bの型は、int &amp;amp;である。int &amp;amp; constとはならないし、int const &amp;amp;ともならない。</p>
<p>テンプレートの例では、テンプレート仮引数Tの実際の型が決定されるのは、テンプレート実引数が渡されて、インスタンス化されたときである。</p>
<p>void型へのリファレンスは存在しない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">void</span> <span class="o">&amp;</span> <span class="n">type</span> <span class="p">;</span> <span class="c1">// エラー</span>
</pre></div>
</div>
<p>リファレンスへのリファレンス、リファレンスの配列、リファレンスへのポインターは存在しない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="o">&amp;</span> <span class="n">type1</span> <span class="p">;</span> <span class="c1">// エラー、リファレンスへのリファレンス</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">type2</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>   <span class="c1">// エラー、リファレンスの配列</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="o">*</span> <span class="n">type3</span> <span class="p">;</span>     <span class="c1">// エラー、リファレンスへのポインター</span>
</pre></div>
</div>
<p>その他の型へのリファレンスは存在する。例えば、配列へのリファレンスや、関数へのリファレンスは存在する。ただし、ポインターと同じく、記述がやや難しい。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 型はvoid (void)</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ref_func</span><span class="p">)(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">=</span> <span class="n">func</span> <span class="p">;</span>
    <span class="n">ref_func</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 関数呼び出し</span>

    <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 型はint [5]</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ref_array</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>リファレンスの宣言には、&lt;a href=&#8221;#dcl.init&#8221;&gt;初期化子&lt;/a&gt;が必要である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">obj</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref1</span> <span class="p">;</span> <span class="c1">// エラー、初期化子がない</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref2</span> <span class="o">=</span> <span class="n">obj</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、宣言がextern指定子を含む場合、クラスのメンバーの宣言である場合、関数の仮引数や戻り値の型の宣言である場合は、初期化子は必要ない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">obj</span> <span class="p">;</span>

<span class="c1">// クラスの例</span>
<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">;</span>
    <span class="n">S</span><span class="p">()</span> <span class="o">:</span> <span class="n">ref</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// extern指定子の例</span>
<span class="c1">// このリファレンスは単なる宣言。</span>
<span class="c1">// 実態はどこか別の場所で定義されている</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">external_ref</span> <span class="p">;</span>

<span class="c1">// 関数の仮引数と戻り値の型の例</span>
<span class="kt">int</span> <span class="o">&amp;</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">ref</span> <span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>リファレンスは必ず、有効なオブジェクトか関数を参照していなければならない。nullリファレンスというものはあり得ない。なぜならば、nullリファレンスを作る方法というのは、nullポインターを参照することである。nullポインターを参照することは、それ自体が未定義動作となるので、規格の上では、合法にnullリファレンスを作ることはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span> <span class="p">;</span> <span class="c1">// エラー、nullポインターを参照している</span>
<span class="p">}</span>
</pre></div>
</div>
<p>リファレンスのリファレンスは存在しないということはすでに延べた。ただし、見かけ上、リファレンスが重なるという場合が存在する。</p>
<p>typedef、テンプレート仮引数の型、decltype指定子が、Tへのリファレンス型であるとする。リファレンスというのは単なるリファレンスであり、lvalueリファレンスとrvalueリファレンスの両方を含む。その場合、この型に対するlvalueリファレンスを宣言した場合、Tへのlvalueリファレンスになる。一方、この型に対するrvalueリファレンスを宣言した場合、Tへのリファレンス型になる。</p>
<p>これはどういうことかというと、すでにリファレンス型であるtypedef、テンプレート仮引数、decltype指定子に対して、さらにリファレンスの宣言子を付け加えるという意味である。もし、この型に対して、lvalueリファレンスを宣言しようとした場合、元のリファレンス型の如何に関わらず、lvalueリファレンスとなる。rvalueリファレンスを宣言しようとした場合、元のリファレンス型になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">lvalue_ref</span> <span class="p">;</span> <span class="c1">// lvalueリファレンス</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">rvalue_ref</span> <span class="p">;</span> <span class="c1">// rvalueリファレンス</span>

    <span class="c1">// lvalueリファレンスを宣言しようとした場合</span>
    <span class="c1">// 元のリファレンス型が、lvalueリファレンスでもrvalueリファレンスでも、lvalueリファレンスになる</span>
    <span class="k">typedef</span> <span class="n">lvalue_ref</span> <span class="o">&amp;</span> <span class="n">type1</span> <span class="p">;</span> <span class="c1">// int &amp;</span>
    <span class="k">typedef</span> <span class="n">rvalue_ref</span> <span class="o">&amp;</span> <span class="n">type2</span> <span class="p">;</span> <span class="c1">// int &amp;</span>

    <span class="c1">// rvalueリファレンスを宣言しようとした場合</span>
    <span class="c1">// 元のリファレンス型になる</span>
    <span class="k">typedef</span> <span class="n">lvalue_ref</span> <span class="o">&amp;&amp;</span> <span class="n">type3</span> <span class="p">;</span> <span class="c1">// int &amp;</span>
    <span class="k">typedef</span> <span class="n">rvalue_ref</span> <span class="o">&amp;&amp;</span> <span class="n">type4</span> <span class="p">;</span> <span class="c1">// int &amp;&amp;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>換言すれば、lvalueリファレンスは優先され、rvalueリファレンスは無視されるということである。</p>
<p>リファレンスが、内部的にストレージを確保するかどうかは規定されていない。したがって、memcpyなどをつかい、リファレンスを他のストレージの上にコピーすることはできない。</p>
</div>
<div class="section" id="pointers-to-members">
<h3>メンバーへのポインター（Pointers to members）<a class="headerlink" href="#pointers-to-members" title="Permalink to this headline">¶</a></h3>
<p>宣言子が以下のように記述されている場合、メンバーへのポインターを意味する。</p>
<div class="highlight-c++"><div class="highlight"><pre>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="p">(</span> <span class="n">S</span><span class="o">::</span> <span class="o">*</span> <span class="n">ptr_func</span> <span class="p">)(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">S</span><span class="o">::</span><span class="n">func</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">S</span><span class="o">::</span> <span class="o">*</span> <span class="n">ptr_value</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">S</span><span class="o">::</span><span class="n">value</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバーへのポインターは、クラスのstaticなメンバーを参照することはできない。また、リファレンス型のメンバーを参照することもできない</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">S</span><span class="o">::</span><span class="n">value</span> <span class="p">;</span>

<span class="kt">void</span> <span class="p">(</span> <span class="n">S</span><span class="o">::</span> <span class="o">*</span> <span class="n">p1</span> <span class="p">)(</span> <span class="kt">void</span> <span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">S</span><span class="o">::</span><span class="n">func</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="kt">void</span> <span class="p">(</span> <span class="o">*</span><span class="n">p2</span> <span class="p">)</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">S</span><span class="o">::</span><span class="n">func</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="kt">int</span> <span class="n">S</span><span class="o">::</span> <span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">S</span><span class="o">::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// エラー</span>
</pre></div>
</div>
<p>メンバーへのポインターは、ポインターとは異なる型である。staticメンバー関数へのポインターは、メンバー関数ポインターではなく、通常の関数ポインターである。</p>
</div>
<div class="section" id="arrays">
<h3>配列（Arrays）<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h3>
<p>宣言子が以下のように記述されている場合、配列を意味する。</p>
<div class="highlight-c++"><pre>識別子 [ 定</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 要素数5のint型の配列</span>
<span class="kt">float</span> <span class="n">b</span><span class="p">[</span><span class="mi">123</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 要素数123のfloat型の配列</span>
</pre></div>
</div>
<p>型指定子と、配列以前の宣言子を合わせた型を、配列の要素型（element type）という。要素型は、void以外の基本型、ポインター型、メンバーへのポインター型、クラス、enum型、配列型でなければならない。要素型には、リファレンス型、void型、関数型、&lt;a href=&#8221;#class.abstract&#8221;&gt;抽象クラス&lt;/a&gt;は使えない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// void以外の基本型</span>

<span class="kt">int</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// ポインター型</span>

<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">value</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">S</span><span class="o">::*</span><span class="n">c</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// メンバーへのポインター型</span>

<span class="n">S</span> <span class="n">d</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// クラス</span>

<span class="k">enum</span> <span class="k">struct</span> <span class="n">E</span><span class="p">{</span> <span class="n">value</span> <span class="p">}</span> <span class="p">;</span>
<span class="n">E</span> <span class="n">e</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// enum型</span>
</pre></div>
</div>
<p>配列に対する配列を作ることができる。これを、多次元配列（multidimensional array）という。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">5</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>ここでは、aは3 × 5 × 7の配列である。詳しく言うと、aは要素数3の配列である。その各要素は、要素数5の配列である。その各要素は、要素数7のint型の配列である。</p>
<p>配列の定数式は、整数の定数式でなければならない。また、その値は、0より大きくなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// エラー</span>
</pre></div>
</div>
<p>定数式は、配列の要素数を表す。今、定数式の値がNであるとすると、配列の要素数はN個であり、0からN-1までの数字を持って表される。その配列のオブジェクトは、連続したストレージ上に、N個の要素型のサブオブジェクトを持っていることになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">constexpr</span> <span class="kt">int</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 要素数5の配列</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// 最初要素</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// 最後の要素</span>
<span class="p">}</span>
</pre></div>
</div>
<p>配列の定数式が省略された場合、要素数の不明な配列となる。これは不完全なオブジェクト型である。多次元配列の場合は、最初の配列の定数式のみ省略できる。</p>
<p>定数式の省略された配列は、不完全なオブジェクト型なので、不完全なオブジェクト型の使用が許可されている場所で使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">b</span><span class="p">[][</span><span class="mi">5</span><span class="p">][</span><span class="mi">7</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// 最初の定数式のみ省略可</span>
</pre></div>
</div>
<p>また、関数の仮引数の型として使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">parameter</span><span class="p">[]</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>ただし、関数の仮引数の場合、型は、要素型への配列ではなく、要素型へのポインターに置き換えられる。詳しくは、宣言子の&lt;a href=&#8221;#dcl.fct&#8221;&gt;関数&lt;/a&gt;を参照。</p>
<p>宣言に初期化子がある場合、配列の定数式を省略できる。この場合、要素数は、初期化子から決定される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// 型はint [3]</span>
</pre></div>
</div>
<p>詳しくは、初期化子の&lt;a href=&#8221;#dcl.init.aggr&#8221;&gt;アグリゲート&lt;/a&gt;を参照</p>
</div>
<div class="section" id="functions">
<h3>関数（Functions）<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>&lt;p class=&#8221;editorial-note&#8221;&gt;
TODO: さらに詳しく説明する可能性あり。</p>
<div class="section" id="id11">
<h4>関数の宣言方法<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<p>関数の宣言子には、文法が二つある。指定子がautoではない場合、以下の文法となる。</p>
<div class="highlight-c++"><pre>識別子 ( 仮引数リスト ) CV修</pre>
</div>
<p>この場合、指定子と、指定子に続く識別子以前の宣言子が、戻り値の型になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// int型の引数を取り、int型の戻り値を返す関数</span>
<span class="kt">int</span> <span class="o">*</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// int型の引数とint型の引数を取り、int *型の戻り値を返す関数</span>
</pre></div>
</div>
<p>この例では指定子のint型は、戻り値の型を意味する。</p>
<p>指定子がautoの場合、以下の文法で関数を宣言できる。</p>
<div class="highlight-c++"><pre>識別子 ( 仮引数リスト ) CV修</pre>
</div>
<p>この場合、戻り値の型は、指定子ではなく、宣言子の中に記述される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">auto</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">;</span> <span class="c1">// int型の引数を取り、int型の戻り値を返す関数</span>
<span class="k">auto</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="p">;</span> <span class="c1">// int型の引数とint型の引数を取り、int *型の戻り値を返す関数</span>
</pre></div>
</div>
<p>違いは、戻り値の型を指定子で指定するか、宣言子の最後で指定するかである。同じ名前と型の関数は、どちらの文法で宣言されたとしても、同じ関数となる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 関数fの宣言</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// 同じ関数fの再宣言</span>
<span class="k">auto</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">;</span>
</pre></div>
</div>
<p>指定子にautoを書く、新しい関数の宣言子では、戻り値の型を後置できる。この新しい関数の宣言子によって、戻り値の型名の記述に、仮引数名を使うことができる。例えば、今、二つの引数に、operator <a href="#id12"><span class="problematic" id="id13">*</span></a>を適用する関数を考える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="o">???</span> <span class="n">multiply</span><span class="p">(</span> <span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで、???という部分で、戻り値の型を指定したい。ところが、T1とT2に対してoperator +を適用した結果の型は、テンプレートをインスタンス化するまで分からない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Mass</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Acceleration</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Force</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// ニュートンの運動方程式、F=ma</span>
<span class="n">Force</span> <span class="k">operator</span> <span class="o">*</span><span class="p">(</span> <span class="n">Mass</span><span class="p">,</span> <span class="n">Acceleration</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Force</span><span class="p">()</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Mass</span> <span class="n">m</span> <span class="p">;</span> <span class="n">Acceleration</span> <span class="n">a</span> <span class="p">;</span>
    <span class="n">Force</span> <span class="n">f</span> <span class="o">=</span> <span class="n">multiply</span><span class="p">(</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、Massクラス型とAccelerationクラス型同士をかけ合わせると、結果はForceクラス型となる。すると、関数multiplyの戻り値の型は、式の結果の型でなければならない。一体どうするか。これには、decltypeが使える。decltypeは、式の結果の型を得る指定子である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Mass</span> <span class="n">m</span> <span class="p">;</span> <span class="n">Acceleration</span> <span class="n">a</span> <span class="p">;</span>
    <span class="k">typedef</span> <span class="n">decltype</span><span class="p">(</span> <span class="n">m</span> <span class="o">*</span> <span class="n">a</span> <span class="p">)</span> <span class="n">type</span> <span class="p">;</span> <span class="c1">// Force</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ところが問題は、従来の関数の文法では、戻り値を記述する場所では、まだ仮引数名が宣言されていないということである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="n">decltype</span><span class="p">(</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span> <span class="p">)</span> <span class="c1">// エラー、t1とt2は宣言されていない</span>
<span class="n">multiply</span><span class="p">(</span> <span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これを解決するには、やや不自然なメタプログラミングの手法を用いるか、引数を後置できる文法を用いるしかない。新しい関数宣言の文法を用いれば、以下のように書ける。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">auto</span> <span class="n">multiply</span><span class="p">(</span> <span class="n">T1</span> <span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">t2</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">decltype</span><span class="p">(</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">t2</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>仮引数リスト<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<p>仮引数リストは、コンマで区切られた0個以上の仮引数の宣言である。仮引数リストは、関数を呼び出す際に、実引数の型や数を指定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">,</span> <span class="kt">double</span> <span class="n">d</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span> <span class="o">*</span> <span class="n">c</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>仮引数リストが空である場合、引数を取らないことを意味する。仮引数が(void)の場合は特別なケースで、仮引数リストが空であることと同義である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 引数を取らない関数</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// 同じ意味</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>仮引数の名前は省略できる。&lt;a href=&#8221;#dcl.fct.def&#8221;&gt;関数の定義&lt;/a&gt;に、仮引数の名前が書かれている場合、その名前が仮引数を表す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// OK、関数fの宣言、仮引数の名前がない</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// OK、同じ関数fの宣言、仮引数に名前がある</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// OK、同じ関数fの定義</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="p">;</span> <span class="c1">// 仮引数を表す</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数の定義で、仮引数に名前が与えられていない場合、関数の本体から、実引数を使えない。ただし、実引数としては、渡されている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="cm">/* 実引数を使えない */</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// 実引数を渡すことには変わりない。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>仮引数の名前は、関数の型には影響を及ぼさない。以下はすべて、同じ関数である。型も同じである。オーバーロードではない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 型はvoid (int, int)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bar</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// 同じ関数fの宣言</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">bar</span><span class="p">,</span> <span class="kt">int</span> <span class="n">foo</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// 同じ関数fの定義</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">hoge</span><span class="p">,</span> <span class="kt">int</span> <span class="cm">/*名前の省略*/</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4>関数の型<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<p>関数の型として意味のあるものは、戻り値の型、仮引数の型リスト、リファレンス修飾子、CV修飾子である。関数の型は、以下のように決定される。</p>
<p>まず、仮引数リストの中のそれぞれの仮引数に対して、指定子と宣言子から、型を決定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 仮引数リスト：int</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// 仮引数リスト：int *, int *</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>このようにして得られた仮引数リストの型に対して、以下の変換を行う。</p>
<p>「T型への配列型」は、「T型へのポインター型」に置き換えられる。「関数型」は、「関数ポインター型」に置き換えられる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// void ( int * )</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// void ( int * )</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span> <span class="p">[]</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// void ( void (*)(int) )</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">(</span> <span class="kt">void</span> <span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>この変換は、関数の本体の中でも有効である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">)</span>
<span class="p">{</span>
<span class="c1">// arrayの型は int *である。int [5]ではない</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span>
<span class="c1">// funcの型は、void (*)(int)である。void (int)ではない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このようにして得られた仮引数の型のリストに対し、さらに変換が行われる。これ以降の変換は、関数の型を決定するための変換であり、関数本体の中の引数の型には影響しない。</p>
<p>トップレベルのCV修飾子を消す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// void (int)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="k">const</span> <span class="k">volatile</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// void (int const *)</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// void (int)</span>
<span class="kt">void</span> <span class="nf">h</span><span class="p">(</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span>
<span class="p">{</span>
<span class="c1">// 関数の本体では、xの型はconst int</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数の本体の中では、引数の型には、トップレベルのCV修飾子も含まれる。しかし、関数の型としては、仮引数に指定されたトップレベルのCV指定子は影響しない。</p>
<p>仮引数の名前がdecltypeに使われている場合、型は、配列からポインター、関数から関数ポインターへの変換が行われた後の型となる。トップレベルのCV修飾子は残る。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// void ( int *, int * )</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="n">b</span><span class="p">)</span>  <span class="p">;</span>
<span class="c1">// void ( int, int const * ) ;</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">a</span><span class="p">,</span> <span class="n">decltype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>  <span class="p">;</span>
</pre></div>
</div>
<p>仮引数の型に影響を与える&lt;a href=&#8221;#dcl.stc&#8221;&gt;ストレージクラス指定子&lt;/a&gt;を消す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// void (int)</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="k">register</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>ただし、現行のC++には、仮引数の型に影響を与えるストレージクラス指定子は、registerだけである。registerの使用は推奨されていない。</p>
<p>上記の変換の結果を、仮引数の型リスト（parameter-type-list）という。</p>
<p>関数が非staticなメンバー関数の場合、CV修飾子があるかどうかが、型として考慮される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="c1">// void S::f(void)</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
    <span class="c1">// void S::f(void) const</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">const</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>関数が非staticなメンバー関数の場合、リファレンス修飾子があるかどうかが、型として考慮される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="c1">// void S::f(void) &amp;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">;</span>
    <span class="c1">// void S::f(void) &amp;&amp;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">;</span>

    <span class="c1">// リファレンス修飾子が省略された関数</span>
    <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバー関数に対するCV修飾子とリファレンス修飾子については、&lt;a href=&#8221;#class.mfct.non-static&#8221;&gt;非staticメンバー関数&lt;/a&gt;を参照。リファレンス修飾子については、&lt;a href=&#8221;#over.match.funcs&#8221;&gt;オーバーロード解決の候補関数と実引数リスト&lt;/a&gt;も参照。</p>
<p>この他の記述、仮引数名やデフォルト実引数や例外指定は、関数の型には影響しない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// void f(int)</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">param</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="n">noexcept</span> <span class="p">;</span>
</pre></div>
</div>
<p>関数の戻り値の型には、関数や配列を使うことはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>ただし、関数や配列へのポインターやリファレンスは、戻り値の型として使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// OK、ポインター</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">auto</span> <span class="nf">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span>
<span class="c1">// OK、リファレンス</span>
<span class="k">auto</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">)[</span><span class="mi">5</span><span class="p">]</span>
</pre></div>
</div>
<p>同じ名前で、型の違う関数を、同じスコープ内で複数宣言して使うことができる。これを、関数のオーバーロードという。詳しくは&lt;a href=&#8221;#over&#8221;&gt;オーバーロード&lt;/a&gt;項目を参照。</p>
</div>
</div>
<div class="section" id="default-arguments">
<h3>デフォルト実引数（Default arguments）<a class="headerlink" href="#default-arguments" title="Permalink to this headline">¶</a></h3>
<p>仮引数に対して、=に続けて式が書かれていた場合、その式は、デフォルト実引数として用いられる。デフォルト実引数は、関数呼び出しの際に、実引数が省略された場合、かわりに引数として渡される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">456</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// f( 123, 456 )と同じ</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// f( 0, 456 )と同じ</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// デフォルト実引数を使用しない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>式は、単にリテラルでなくてもよい。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="nf">g</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>関数の呼び出しの再に、前の実引数を省略して、あとの実引数を指定することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">456</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>デフォルト実引数は、関数のパラメーターパックに指定することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Types</span> <span class="p">..</span> <span class="n">args</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
</pre></div>
</div>
<p>デフォルト実引数は、後から付け加えることも出来る。ただし、再宣言してはいけない。たとえ同じ式であったとしても、再宣言はできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// OK、デフォルト実引数を付け加える</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// エラー、デフォルト実引数の再宣言</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// 定義</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>可読性のためには、デフォルト実引数は、関数の最初の宣言に記述すべきである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// 宣言</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 定義</span>
</pre></div>
</div>
<p>デフォルト実引数が使われる場合、式は、関数呼び出しの際に、毎回評価される。評価の順序は規定されていない。</p>
</div>
</div>
<div class="section" id="function-definitions">
<h2>関数の定義（Function definitions）<a class="headerlink" href="#function-definitions" title="Permalink to this headline">¶</a></h2>
<p>&lt;p class=&#8221;editorial-note&#8221;&gt;
TODO: FDIS後のdefault化とdelete定義の関数の本体への移行に対応すること。</p>
<div class="highlight-c++"><pre>関数の定義:
    関数の宣言 関数の本体
    関数の宣言 = default ;
    関数の宣言 = delete ;

関数の本体:
    コンストラクター初期</pre>
</div>
<p>関数の定義とは、関数の宣言に続けて、関数の本体の書かれている関数宣言である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 宣言</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// 定義</span>

<span class="kt">void</span> <span class="c1">// 指定子</span>
<span class="n">g</span> <span class="p">()</span> <span class="c1">// 宣言子</span>
<span class="p">{</span> <span class="p">}</span> <span class="c1">// 関数の本体</span>
</pre></div>
</div>
<p>関数は、名前空間スコープか、クラススコープの中でのみ、定義できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// グローバル名前空間スコープ</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="c1">// クラススコープ</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{}</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">h</span><span class="p">(){}</span> <span class="p">;</span> <span class="c1">// エラー、関数のブロックスコープの中では定義できない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>コンストラクター初期化子は、クラスのコンストラクターで用いる。詳しくは、クラスの&lt;a href=&#8221;#class.ctor&#8221;&gt;コンストラクター&lt;/a&gt;と、クラスの&lt;a href=&#8221;#class.init&#8221;&gt;初期化&lt;/a&gt;を参照。</p>
<p>関数の定義には、複合文の他に、関数tryブロックを使うこともできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="n">try</span>
<span class="p">{</span>
<span class="c1">// 関数の本体</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
<span class="c1">// 例外ハンドラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数tryブロックについて詳しくは、&lt;a href=&#8221;#except&#8221;&gt;例外&lt;/a&gt;を参照。</p>
<p>関数の本体では、__func__（ダブルアンダースコアであることに注意）という名前の変数が、以下のようにあらかじめ定義されている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__func__</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;関数名&quot;</span> <span class="p">;</span>
</pre></div>
</div>
<p>「関数名」とは、実装依存の文字列である。C++規格では、この実装依存の文字列の意味は、何も規定されていない。この機能はC言語から取り入れられたものである。C99規格では、関数本体の属する関数の名前を表す、実装依存の文字列とされている。いずれにせよ、具体的な文字列については、何も規定されていない。</p>
<div class="section" id="default-explicitly-defaulted-functions">
<h3>default定義（Explicitly-defaulted functions）<a class="headerlink" href="#default-explicitly-defaulted-functions" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>関数の宣言 = default ;</pre>
</div>
<p>関数の宣言に続けて、= default ;と書く関数の定義を、明示的にデフォルト化された関数（Explicitly-defaulted functions）という。本書では、default定義と呼ぶ。</p>
<p>明示的にデフォルト化された関数は、&lt;a href=&#8221;#special&#8221;&gt;特別なメンバー関数&lt;/a&gt;でなければならない。また、暗黙的に定義された場合と同等の型でなければならない。デフォルト実引数と例外指定は使えない。</p>
<p>明示的なデフォルト化は、暗黙の定義と同等の定義を、明示的に定義するための機能である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span> <span class="p">;</span> <span class="c1">// default定義</span>
    <span class="n">S</span><span class="p">(</span><span class="kt">int</span><span class="p">){</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この例では、もし、明示的なデフォルト化が書かれていない場合、Sのデフォルトコンストラクターは、暗黙的に定義されない。</p>
<p>明示的にデフォルト化された関数を、暗黙的に定義される関数をあわせて、デフォルト化された関数（defaulted function）という。</p>
</div>
<div class="section" id="delete-deleted-definitions">
<h3>delete定義（Deleted definitions）<a class="headerlink" href="#delete-deleted-definitions" title="Permalink to this headline">¶</a></h3>
<div class="highlight-c++"><pre>関数の宣言 = delete ;</pre>
</div>
<p>関数の宣言に続けて、= delete ; と書く関数の定義を、削除された定義（Deleted definitions）という。また、本書では、分かりやすさのため、delete定義と呼ぶ。</p>
<p>削除された関数定義は、宣言として存在しているが、定義のない関数である。宣言としては存在しているので、名前解決やオーバーロード解決、テンプレートのインスタンス化の際には、通常通り考慮される。</p>
<p>ただし、削除された関数定義を、宣言以外の方法で参照した場合、エラーとなる。参照というのは、明示的、暗黙的に関数を呼び出すことや、関数へのポインター、メンバーポインター、リファレンスを得ることなどである。また、たとえ未評価式の中であっても、参照した場合エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 削除された関数の定義</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、宣言はできる</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー、削除された関数の呼び出し</span>
    <span class="o">&amp;</span><span class="n">f</span> <span class="p">;</span> <span class="c1">// エラー、削除された関数のポインターを得ようとしている</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="p">;</span> <span class="c1">// エラー、削除された関数のリファレンスを得ようとしている</span>
    <span class="n">typdef</span> <span class="n">decltype</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="n">type</span> <span class="p">;</span> <span class="c1">// エラー、未評価式の中で、削除された関数を参照している</span>
<span class="p">}</span>
</pre></div>
</div>
<p>削除された関数の定義は、関数の最初の宣言でなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 削除された定義ではない</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span> <span class="c1">// エラー、最初の宣言でなければならない</span>

<span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span> <span class="c1">// OK、最初の宣言</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、再宣言</span>
</pre></div>
</div>
<p>ただし、関数テンプレートの特殊化の場合、最初の特殊化の宣言となる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// primary template</span>

<span class="c1">// 特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">f</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数がオーバーロードされている場合、オーバーロード解決によって、削除された関数定義が参照される場合のみ、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{}</span> <span class="c1">// 削除されていない関数</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span> <span class="c1">// 削除された関数定義</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、void f(int)は削除されていない</span>
    <span class="n">f</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、削除された関数の参照</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数のオーバーロード、関数テンプレート、削除された定義を組み合わせると、非常に面白い事ができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// 特殊化でdoubleでインスタンス化された場合の定義を削除</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">call_f</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// doubleでインスタンス化した場合、エラーになる</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">f</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">f</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>

<span class="c1">// あらゆるインスタンス化を削除</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>

<span class="c1">// 削除されていない定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">call_g</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// double以外でインスタンス化した場合、エラーになる</span>
    <span class="n">g</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">g</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">g</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>

<span class="c1">// 非テンプレートな関数</span>
<span class="kt">void</span> <span class="n">h</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// 関数テンプレートの定義を削除</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">h</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">call_h</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// intへの標準型変換を禁止</span>
    <span class="n">h</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、非テンプレートな関数を呼び出す</span>
    <span class="n">h</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、関数テンプレート</span>
    <span class="n">h</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、関数テンプレート</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">i</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>
<span class="kt">void</span> <span class="nf">i</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="nf">call_i</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// intからdoubleへの標準変換をエラーにする</span>
    <span class="n">i</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、</span>
    <span class="n">i</span><span class="p">(</span> <span class="nb">true</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">i</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、削除された定義を使うことで、意図しない標準型変換やインスタンス化を阻害できる。</p>
<p>削除された関数定義の具体的な使い方は、実に様々な例が考えられる。ここでは、その一部を挙げる。</p>
<p>クラスのコンストラクターを制御する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Boolen</span>
<span class="p">{</span>
    <span class="n">Boolen</span><span class="p">(</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>
    <span class="n">Boolen</span><span class="p">(</span> <span class="kt">bool</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="n">Boolen</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Boolen</span> <span class="n">a</span> <span class="o">=</span> <span class="nb">true</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">Boolen</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">123</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">Boolen</span> <span class="n">c</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Boolenクラスは、必ず、ひとつのbool型の引数で初期化しなければならない。このクラスの初期化の際に、bool以外の型を渡すと、テンプレートのインスタンス化とオーバーロード解決により、関数テンプレート版のコンストラクターが優先される。しかし、定義は削除されているため、エラーとなる。結果的に、暗黙の型変換を禁止しているのと同じ意味となる。そのため、意図しない数値やポインターでの初期化という、つまらないバグを防げる。</p>
<p>クラスのオブジェクトをnewで生成することを禁止する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Do_not_new</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Do_not_new</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">Do_not_new</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Do_not_new</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">Do_not_new</span> <span class="o">*</span> <span class="n">array_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Do_not_new</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>何らかの理由で、あるクラスのオブジェクトを、newで生成してほしくないとする。削除された定義を使えば、あるクラスに対して、newを禁止できる。</p>
<p>クラスのコピーを禁止する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">move_only</span>
<span class="p">{</span>
    <span class="n">move_only</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span> <span class="p">;</span>
    <span class="o">~</span><span class="n">move_only</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span> <span class="p">;</span>

    <span class="n">move_only</span><span class="p">(</span> <span class="k">const</span> <span class="n">move_only</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>
    <span class="n">move_only</span><span class="p">(</span> <span class="n">move_only</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span> <span class="p">;</span>
    <span class="n">move_only</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="k">const</span> <span class="n">move_only</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">delete</span> <span class="p">;</span>
    <span class="n">move_only</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">move_only</span> <span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">move_only</span> <span class="n">m</span> <span class="p">;</span>
    <span class="n">move_only</span> <span class="n">n</span> <span class="p">;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">m</span> <span class="p">;</span> <span class="c1">// エラー、コピーは禁止されている</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、ムーブはできる</span>
<span class="p">}</span>
</pre></div>
</div>
<p>クラスmove_onlyは、ムーブができるが、コピーはできないクラスになる。</p>
</div>
</div>
<div class="section" id="initializers">
<h2>初期化子（Initializers）<a class="headerlink" href="#initializers" title="Permalink to this headline">¶</a></h2>
<p>宣言子の宣言する変数に対して、初期値を指定することができる。この初期値を指定するための文法を、初期化子（Initializer）という。この初期化子の項目で解説している初期化は、宣言文以外にも、関数の仮引数を実引数で初期化することや、関数の戻り値の初期化、new式やクラスのメンバー初期化子などにも適用される。</p>
<p>初期化子の文法と意味について解説する前に、まず基本的な三つの初期化について解説しなければならない。ゼロ初期化、デフォルト初期化、値初期化である。</p>
<div class="section" id="zero-initialize">
<h3>ゼロ初期化（zero-initialize）<a class="headerlink" href="#zero-initialize" title="Permalink to this headline">¶</a></h3>
<p>ゼロ初期化（zero-initialize）とは、T型のオブジェクトやリファレンスに対して、</p>
<p>Tがスカラー型の場合、整数の定数、0を、T型に変換して初期化する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// 0で初期化される</span>
<span class="k">static</span> <span class="kt">float</span> <span class="n">f</span> <span class="p">;</span> <span class="c1">// 0がfloat型に変換されて初期化される</span>
<span class="k">static</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="p">;</span> <span class="c1">// 0がnullポインターに変換されて初期化される</span>
</pre></div>
</div>
<p>Tがunionではないクラス型の場合、非staticなデータメンバーと基本クラスのサブオブジェクトが、それぞれゼロ初期化される。また、アライメント調整などのための、オブジェクト内のパディングも、ゼロビットで初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 非staticなデータメンバー、基本クラスのサブオブジェクトが、それぞれゼロ初期化される</span>
<span class="k">static</span> <span class="n">Derived</span> <span class="n">d</span> <span class="p">;</span>
</pre></div>
</div>
<p>この例では、Derivedのデータメンバーであるyと、基本クラスであるBaseのオブジェクトがゼロ初期化される。Baseをゼロ初期化するということは、Baseのデータメンバーであるxもゼロ初期化される。</p>
<p>Tがunion型の場合、オブジェクトの最初の、非staticな名前のつけられているデータメンバーが、ゼロ初期化される。また、アライメント調整などのための、オブジェクト内のパディングも、ゼロビットで初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">union</span> <span class="n">U</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>このunionのオブジェクトをゼロ初期化した場合、U::xがゼロ初期化される。</p>
<p>Tが配列型の場合、各要素がそれぞれゼロ初期化される。</p>
<p>Tがリファレンス型の場合、初期化は行われない。</p>
</div>
<div class="section" id="default-initialize">
<h3>デフォルト初期化（default-initialize）<a class="headerlink" href="#default-initialize" title="Permalink to this headline">¶</a></h3>
<p>デフォルト初期化（default-initialize）とは、T型のオブジェクトに対して、</p>
<p>Tがクラス型の場合、Tのデフォルトコンストラクターが呼ばれる。デフォルトコンストラクターにアクセス出来ない場合は、エラーである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">class</span> <span class="nc">B</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// デフォルトコンストラクターが呼ばれる</span>
    <span class="n">B</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// エラー、デフォルトコンストラクターにアクセスできない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Tが配列型の場合、各要素がそれぞれデフォルト初期化される。</p>
<p>上記以外の場合、初期化は行われない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// 初期化は行われない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>const修飾された型をデフォルト初期化する場合、型はユーザー定義コンストラクターを持つクラス型でなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Y</span> <span class="p">{</span> <span class="n">Y</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// エラー、intはユーザー定義コンストラクターを持つクラス型ではない</span>
    <span class="n">X</span> <span class="k">const</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// エラー、Xはユーザー定義コンストラクターを持つクラス型ではない</span>

    <span class="n">Y</span> <span class="k">const</span> <span class="n">c</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>リファレンス型をデフォルト初期化しようとした場合、エラーになる。</p>
</div>
<div class="section" id="value-initialize">
<h3>値初期化（value-initialize）<a class="headerlink" href="#value-initialize" title="Permalink to this headline">¶</a></h3>
<p>値初期化（value-initialize）とは、T型のオブジェクトに対して、</p>
<p>Tがクラス型で、ユーザー提供のコンストラクターを持つ場合、Tのデフォルトコンストラクターが呼ばれる。デフォルトコンストラクターにアクセス出来ない場合は、エラーである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>クラスSのオブジェクトを値初期化した場合、Sのデフォルトコンストラクターが呼ばれる。xの値は不定である。</p>
<p>Tが、unionではないクラス型で、ユーザー提供のコンストラクターを持たない場合、オブジェクトはゼロ初期化される。もし、暗黙的に定義されたコンストラクターが、トリビアルではない場合、コンストラクターが呼ばれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{</span>  <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
<span class="c1">// ユーザー提供のコンストラクターがない</span>
<span class="c1">// 暗黙に定義されたコンストラクターはトリビアルではない</span>
    <span class="n">A</span> <span class="n">a</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>クラスBのオブジェクトを値初期化した場合、Aのデフォルトコンストラクターが呼ばれる。また、xはゼロ初期化される。</p>
<p>Tが配列型の場合、各要素がそれぞれ値初期化される。</p>
<p>上記以外の場合、オブジェクトはゼロ初期化される。</p>
<p>リファレンス型をゼロ初期化しようとした場合、エラーとなる。</p>
<p>staticストレージの期間を持つオブジェクトは、プログラムの開始時に、必ずゼロ初期化される。その後、必要であれば、初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">()</span> <span class="o">:</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">S</span> <span class="n">s</span> <span class="p">;</span><span class="c1">// staticストレージの期間を持つオブジェクト</span>
</pre></div>
</div>
<p>ここでは、Sのデフォルトコンストラクターが実行される前に、データメンバーのxはゼロ初期化されている。</p>
<p>初期化子が空の括弧、()、であるとき、オブジェクトは値初期化される。ただし、通常の宣言文では、初期化子として空の括弧を書く事はできない。なぜならば、空の括弧は、関数の宣言であるとみなされるからだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// int (void)型の関数xの宣言</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初期化子としての空の括弧は、&lt;a href=&#8221;#expr.new&#8221;&gt;new&lt;/a&gt;、&lt;a href=&#8221;#expr.type.conv&#8221;&gt;関数形式の明示的型変換&lt;/a&gt;、&lt;a href=&#8221;#class.base.init&#8221;&gt;基本クラスとデータメンバーの初期化子&lt;/a&gt;で使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">x</span><span class="p">()</span> <span class="c1">// メンバー初期化子</span>
    <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">new</span> <span class="kt">int</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// new、初期化子として空の括弧</span>
    <span class="kt">int</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 関数形式のキャスト</span>
<span class="p">}</span>
</pre></div>
</div>
<p>初期化子が指定されていない場合、オブジェクトはデフォルト初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span> <span class="p">;</span> <span class="c1">// デフォルト初期化される</span>
<span class="p">}</span>
</pre></div>
</div>
<p>デフォルト初期化では、すでに説明したように、クラス以外の型は、初期化が行われない。初期化が行われないオブジェクトの値は、不定である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="p">;</span> <span class="c1">// 値は不定</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="p">;</span> <span class="c1">// 値は不定</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、staticやthreadストレージの有効期間を持つオブジェクトは、ゼロ初期化されることが保証されている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// グローバル名前空間</span>
<span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// staticストレージ、ゼロ初期化される</span>
<span class="n">thread_local</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span> <span class="c1">// threadストレージ、ゼロ初期化される</span>
</pre></div>
</div>
<p>以下のような文法の初期化子を、コピー初期化（copy-initialization）という。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="p">;</span>
</pre></div>
</div>
<p>これに加えて、関数の実引数を渡す、関数のreturn文、例外のthrow文、例外を受ける、アグリゲートのメンバーの初期化も、コピー初期化という。この「コピー」という言葉は、コピーコンストラクターやコピー代入演算子とは関係がない。コピー初期化でも、コピーではなく、ムーブされることもある。</p>
<p>以下のような文法の初期化子を、直接初期化（direct-initialization）という。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">T</span> <span class="nf">x</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">;</span>
<span class="n">T</span> <span class="n">x</span><span class="p">{</span><span class="n">a</span><span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>これに加えて、&lt;a href=&#8221;#expr.new&#8221;&gt;new&lt;/a&gt;、&lt;a href=&#8221;#expr.static.cast&#8221;&gt;static_cast&lt;/a&gt;、&lt;a href=&#8221;#expr.type.conv&#8221;&gt;関数形式のキャスト&lt;/a&gt;、&lt;a href=&#8221;#class.base.init&#8221;&gt;基本クラスとデータメンバーの初期化子&lt;/a&gt;も、直接初期化という。</p>
<p>初期化子の意味は、以下のように決定される。オブジェクトの型を、目的の型（destination type）とし、初期化子の型を、元の型（source type）とする。元の型は、初期化子が、ひとつの初期化リストか、括弧で囲まれた式リストの場合は、存在しない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 目的の型はT</span>
<span class="c1">// 元の型はint</span>
<span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

<span class="c1">// 目的の型はT</span>
<span class="c1">// 元の型は存在しない（ひとつの初期化リスト）</span>
<span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="n">T</span> <span class="nf">x</span><span class="p">({</span> <span class="p">})</span> <span class="p">;</span>
<span class="n">T</span> <span class="n">x</span><span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 目的の型はT</span>
<span class="c1">// 元の型は存在しない（括弧で囲まれた式リスト）</span>
<span class="n">T</span> <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>初期化子が、ひとつの初期化リストの場合、&lt;a href=&#8221;#dcl.init.list&#8221;&gt;リスト初期化&lt;/a&gt;される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// リスト初期化される</span>
<span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="n">T</span> <span class="nf">x</span><span class="p">({</span> <span class="p">})</span> <span class="p">;</span>
<span class="n">T</span> <span class="n">x</span><span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>目的の型がリファレンスの場合、&lt;a href=&#8221;#dcl.init.ref&#8221;&gt;リファレンス&lt;/a&gt;を参照。</p>
<p>目的の型が、char、signed char、unsigned char、char16_t、char32_t、wchar_tの配列で、初期化子が文字列リテラルの場合、&lt;a href=&#8221;#dcl.init.string&#8221;&gt;文字配列&lt;/a&gt;を参照。</p>
<p>初期化子が空の()の場合、オブジェクトは値初期化される。</p>
<p>ただし、通常の変数の宣言では、空の()を書く事はできない。なぜならば、空の括弧は、関数の宣言とみなされるからだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int (void)型の関数xの宣言</span>
<span class="c1">// int x(void) ; と同じ</span>
<span class="kt">int</span> <span class="nf">x</span><span class="p">()</span> <span class="p">;</span>
</pre></div>
</div>
<p>空の()を書く事ができる初期化子には、&lt;a href=&#8221;#expr.type.conv&#8221;&gt;関数形式のキャスト&lt;/a&gt;、&lt;a href=&#8221;#expr.new&#8221;&gt;new&lt;/a&gt;、&lt;a href=&#8221;#class.base.init&#8221;&gt;メンバー初期化&lt;/a&gt;がある。</p>
<div class="highlight-c++"><div class="highlight"><pre> <span class="c1">// 関数形式のキャスト</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">int</span><span class="p">()</span> <span class="p">;</span>
<span class="c1">// new</span>
<span class="k">new</span> <span class="nf">int</span><span class="p">()</span> <span class="p">;</span>

<span class="c1">// メンバー初期化</span>
<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">member</span> <span class="p">;</span>
    <span class="n">C</span><span class="p">()</span> <span class="o">:</span> <span class="n">member</span><span class="p">()</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>{}や、空の初期化リストを含む({})は、文法上曖昧とならないので、宣言文でも書ける。詳しくは&lt;a href=&#8221;#dcl.init.list&#8221;&gt;リスト初期化&lt;/a&gt;で解説するが、この場合も、オブジェクトは値初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">{}</span> <span class="p">;</span> <span class="c1">// int型の変数xの宣言と定義と初期化子</span>
<span class="kt">int</span> <span class="nf">y</span><span class="p">({})</span> <span class="p">;</span> <span class="c1">// int型の変数yの宣言と定義と初期化子</span>
</pre></div>
</div>
<p>それ以外の場合で、目的の型が配列型の場合、エラーとなる。これは、初期化子がある場合で、上記のいずれにも該当しない場合を指す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// エラー、int [5]型は、int型で初期化できない</span>
</pre></div>
</div>
<p>目的の型がクラス型で、初期化子が直接初期化である場合、最も最適なコンストラクターが、オーバーロード解決によって選ばれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Elem</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">Elem</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s1</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// S::S(int)</span>
    <span class="n">S</span> <span class="n">s2</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// S::S(int)、標準型変換による</span>

    <span class="n">Elem</span> <span class="n">elem</span> <span class="p">;</span>
    <span class="n">S</span> <span class="n">s3</span><span class="p">(</span> <span class="n">elem</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// S::S(Elem)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>コンストラクターが適用できなかったり、曖昧である場合は、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">long</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">long</span> <span class="kt">long</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Elem</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s1</span> <span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、コンストラクターが曖昧</span>
    <span class="n">Elem</span> <span class="n">elem</span> <span class="p">;</span>
    <span class="n">S</span> <span class="n">s2</span><span class="p">(</span> <span class="n">elem</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、適切なコンストラクターが見つからない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>目的の型がクラス型で、初期化子がコピー初期化で、初期化子の型が目的の型か、その派生クラス型である場合、直接初期化と同じ方法で初期化される。初期化子の型が目的の型か、その派生クラス型でない場合は、後述。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Base</span> <span class="n">b1</span> <span class="o">=</span> <span class="n">Base</span><span class="p">()</span> <span class="p">;</span>
    <span class="n">Base</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">Derived</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>目的の型がクラス型で、初期化子がコピー初期化の場合（ただし上記を除く）、ユーザー定義の型変換が試みられ、最適な候補が、オーバーロード解決によって選ばれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Elem</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Integer</span>
<span class="p">{</span>
    <span class="k">operator</span> <span class="kt">int</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">Elem</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// コンストラクターによる変換、S::S(int)</span>
    <span class="n">S</span> <span class="n">s2</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="p">;</span> <span class="c1">// 標準型変換の結果、S::S(int)</span>
    <span class="n">S</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">Elem</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// コンストラクターによる変換、S::S(Elem)</span>
    <span class="n">S</span> <span class="n">s4</span> <span class="o">=</span> <span class="n">Integer</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// Integer::operator int()が呼ばれ、次にS::S(int)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>型変換できなかったり、型変換が曖昧である場合は、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">(</span> <span class="kt">long</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">C</span><span class="p">(</span> <span class="kt">long</span> <span class="kt">long</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span> <span class="p">;</span>
    <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// エラー、変換関数が見つからない</span>
    <span class="n">C</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// エラー、変換関数が曖昧</span>
<span class="p">}</span>
</pre></div>
</div>
<p>それ以外の場合、つまり、目的の型がクラス型ではない場合で、初期化子の型がクラスであった場合、目的の型に型変換が試みられ、最適な候補がオーバーロード解決によって選択される。型変換ができない場合や、曖昧な場合は、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="k">operator</span> <span class="kt">int</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">s</span> <span class="p">;</span> <span class="c1">// OK、S::operator int()が呼ばれる</span>
<span class="p">}</span>
</pre></div>
</div>
<p>それ以外の場合、つまり、目的の型も初期化子の型も、クラスではない場合、標準型変換が試みられる。ユーザー定義の変換関数は考慮されない。型変換ができない場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="c1">// OK、整数から浮動小数点数へ型変換される</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f</span> <span class="p">;</span> <span class="c1">// エラー、floatはint *に変換できない</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="aggregates">
<h3>アグリゲート（Aggregates）<a class="headerlink" href="#aggregates" title="Permalink to this headline">¶</a></h3>
<p>アグリゲート（aggregate）とは、配列か、いくつかの制約を満たしたクラスである。クラスの場合、ユーザー定義のコンストラクター、非staticデータメンバーの初期化子、privateおよびprotectedな非staticデータメンバー、基本クラス、virtual関数が存在しないものだけを、アグリゲートという。</p>
<p>以下は、アグリゲートの例である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Aggregate</span>
<span class="p">{</span>
<span class="c1">// 非staticデータメンバーはすべてpublic</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="p">;</span>

<span class="c1">// 非virtualなメンバー関数</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">// staticデータメンバーはpublicでなくてもよい</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">Aggregate</span><span class="o">::</span><span class="n">data</span> <span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
<span class="n">Aggregate</span> <span class="n">b</span> <span class="p">;</span>
<span class="n">Aggregate</span> <span class="n">c</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
</pre></div>
</div>
<p>以下はアグリゲートの条件を満たさないクラスの例である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">NonAggregate</span>
    <span class="o">:</span> <span class="n">Base</span> <span class="c1">// 基本クラス</span>
<span class="p">{</span>
<span class="c1">// ユーザー定義のコンストラクター</span>
    <span class="n">NonAggregate</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="c1">// 非staticデータメンバーの初期化子</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="c1">// privateおよびprotectedな非staticデータメンバー</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
<span class="k">protected</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">z</span> <span class="p">;</span>
<span class="c1">// virtual関数</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>配列は必ずアグリゲートである。たとえアグリゲートではないクラス型であっても、そのクラスの配列型は、アグリゲートとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// アグリゲートではないクラス</span>
<span class="k">struct</span> <span class="n">NonAggregate</span>
<span class="p">{</span>
    <span class="n">NonAggregate</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">NonAggregate</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">;</span> <span class="c1">// アグリゲート</span>
</pre></div>
</div>
<p>アグリゲートが初期化リストで初期化される場合、初期化リストの対応する順番の要素が、それぞれアグリゲートのメンバーの初期化に用いられる。メンバーはコピー初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 配列の例</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// 各要素の初期化、a[0] = 1, a[1] = 2, a[2] = 3</span>

<span class="c1">// クラスの例</span>
<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// 各メンバーの初期化は、s.x = 1, s.y = 2, s.d = 3.0</span>

<span class="c1">// クラスの配列の例</span>
<span class="n">S</span> <span class="n">sa</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">},</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">s</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// アグリゲートではないクラスの配列の例</span>
<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="p">;</span>
<span class="k">public</span> <span class="o">:</span>
    <span class="n">C</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="o">:</span> <span class="n">value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">C</span> <span class="nf">obj</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// クラスのオブジェクト</span>

<span class="c1">// 配列はアグリゲート</span>
<span class="n">C</span> <span class="n">ca</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">obj</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// コピー初期化を適用した結果、C::C(int)が呼び出される</span>
<span class="c1">// ca[0]は1、ca[1]は2、ca[2]はobjで、それぞれ初期化される</span>
</pre></div>
</div>
<p>初期化の際に、縮小変換が必要な場合、エラーである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">a</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">{</span> <span class="mf">0.0</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、縮小変換が必要</span>

<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>
<span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、縮小変換が必要</span>
</pre></div>
</div>
<p>初期化リストが、内部に初期化リストを含む場合、アグリゲートの対応するメンバーは、初期化リストによって初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Inner</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>  <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">Inner</span> <span class="n">obj</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">Outer</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// a.x = 1, a.obj = { 1, 2 }</span>
<span class="c1">// a.obj.x = 1, a.obj.y = 2</span>
</pre></div>
</div>
<p>要素数不定の配列のアグリゲートが、初期化リストで初期化される場合、配列の要素数は、初期化リストの要素数になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// int [1]</span>
<span class="kt">int</span> <span class="n">b</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// int [3]</span>
<span class="kt">int</span> <span class="n">c</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// int [5]</span>
</pre></div>
</div>
<p>staticデータメンバーと無名ビットフィールドは、アグリゲートのリスト初期化の際には、メンバーとして考慮されない。つまり、初期化リストの要素の順番などにも影響しない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">static_data_member</span> <span class="p">;</span><span class="c1">// staticデータメンバー</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">:</span> <span class="mi">8</span> <span class="p">;</span> <span class="c1">// 無名ビットフィールド</span>
    <span class="kt">int</span> <span class="n">z</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">S</span><span class="o">::</span><span class="n">static_data_member</span> <span class="p">;</span>

<span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// s.x = 1, s.y = 2, s.z = 3</span>
</pre></div>
</div>
<p>この例では、static_data_memberと、yとzとの間にある無名ビットフィールドは、リスト初期化の際には、メンバーとして考慮されない。</p>
<p>もし、アグリゲートのメンバーよりも、初期化リストの要素の方が多い場合は、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー</span>

<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">z</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー</span>
</pre></div>
</div>
<p>もし、アグリゲートのメンバーよりも、初期化リストの要素の方が少ない場合、明示的に初期化されていないアグリゲートのメンバーは、すべて値初期化される。値初期化では、アグリゲートの条件を満たす型はすべて、ゼロ初期化される。したがって、単にゼロで初期化されると考えても差し支えない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// a[0] = 1, a[1] = 2, a[2] = 3</span>
<span class="c1">// a[4]とa[5]は、値初期化される</span>

<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">S</span> <span class="n">s</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// s.x = 1</span>
<span class="c1">// s.yは値初期化される</span>
</pre></div>
</div>
<p>空の初期化リストでは、値初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// メンバーはすべて値初期化される</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span> <span class="kt">int</span> <span class="n">y</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>既存のコードでは、アグリゲートのすべてのメンバーをゼロ初期化するために、{0}という初期化リストが使われていることがある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="p">;</span> <span class="c1">// すべてゼロで初期化</span>
</pre></div>
</div>
<p>これは、C++ではなく、C言語に由来するコードである。C言語では、空の初期化リストを書く事ができない。そのため、Cプログラマは、{0}と書くのである。多くのC++プログラマは、C言語もよく知っているので、既存のコードでは、慣習的に{0}が使われている。しかし、C++では、{0}と書く必要はない。{}で十分である。</p>
<p>アグリゲートが、内部に別のアグリゲートを持っている場合、初期化リストは、その内部のアグリゲートを無視することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">SubAggregate</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Aggregate</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">m1</span> <span class="p">;</span>
    <span class="n">SubAggregate</span> <span class="n">s1</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">m2</span> <span class="p">;</span>
    <span class="n">SubAggregate</span> <span class="n">m2</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">m3</span> <span class="p">;</span>
    <span class="n">SubAggregate</span> <span class="n">m3</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="n">SubAggregate</span> <span class="n">s</span> <span class="p">;</span>

<span class="n">Aggregate</span> <span class="n">a</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="mi">1</span><span class="p">,</span>
    <span class="p">{</span> <span class="p">},</span><span class="c1">// 空の初期化リスト</span>
    <span class="mi">2</span><span class="p">,</span>
    <span class="n">s</span><span class="p">,</span><span class="c1">// オブジェクトの変数</span>
    <span class="mi">3</span><span class="p">,</span>
    <span class="n">SubAggregate</span><span class="p">()</span> <span class="c1">// 関数形式のキャスト</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>このように、内部のアグリゲートに続くメンバーを初期化したい場合は、たとえ空の初期化リストでも、必ず書かなければならない。もちろん、その内部のアグリゲートをコピー初期化できる型の値ならば、なんでも使える。</p>
<p>アグリゲート内のリファレンスのメンバーが、明示的に初期化されなかった場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">;</span> <span class="c1">// リファレンスのメンバー</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// OK、リファレンスを初期化している</span>
<span class="n">S</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、リファレンスが初期化されていない</span>
</pre></div>
</div>
<p>多次元配列は、初期化リストのネストによって初期化することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">},</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span>
<span class="p">{</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">},</span>
    <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="character-arrays">
<h3>文字配列（Character arrays）<a class="headerlink" href="#character-arrays" title="Permalink to this headline">¶</a></h3>
<p>char（signed charとunsigned charも含む）, wchar_t, char16_t, char32_tの配列は、それぞれ、対応する文字列リテラルで初期化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span> <span class="p">;</span>
<span class="kt">char</span> <span class="n">utf8_str</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">u8</span><span class="s">&quot;hello&quot;</span> <span class="p">;</span>
<span class="kt">wchar_t</span> <span class="n">wide_str</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">L&quot;hello&quot;</span> <span class="p">;</span>
<span class="kt">char16_t</span> <span class="n">utf16_str</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="s">&quot;hello&quot;</span> <span class="p">;</span>
<span class="kt">char32_t</span> <span class="n">utf32_str</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">U</span><span class="s">&quot;hello&quot;</span> <span class="p">;</span>
</pre></div>
</div>
<p>文字列リテラルは、null文字を含むということに注意しなければならない。文字列リテラル、&#8221;hello&#8221;の型は、char const [6]である。</p>
<p>文字配列の要素数が指定されていない場合、初期化子の文字列リテラルの要素数になる</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 要素数は6</span>
<span class="kt">char</span> <span class="n">str</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span> <span class="p">;</span>
</pre></div>
</div>
<p>配列の要素数より、文字列リテラルの要素数の方が多い場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span> <span class="p">;</span> <span class="c1">// エラー</span>
</pre></div>
</div>
<p>配列の要素数より、文字列リテラルの要素数の方が少ない場合、明示的に初期化されない要素は、ゼロ初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 以下の二行は同等</span>
<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span> <span class="p">;</span>
<span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">&#39;h&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h3>リファレンス（References）<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>&lt;p class=&#8221;editorial-note&#8221;&gt;
TODO: FDIS後に見直し。core issue 1058.If the initializer expression is a string literal (2.14.5 [lex.string]), the program is ill-formed.</p>
<p>T &amp;amp;を、「T型へのlvalueリファレンス」という。T &amp;amp;&amp;amp;を、「T型へのrvalueリファレンス」という。これらを二つまとめて、「T型へのリファレンス」という。lvalueリファレンスは、lvalueへのリファレンスであり、lvalueで初期化する。rvalueリファレンスは、rvalueへのリファレンスであり、rvalueで初期化する。そのため、このような名前になっている。</p>
<p>T型へのリファレンスは、T型のオブジェクトか関数、あるいは、T型に変換可能なオブジェクトで初期化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Integer</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="p">;</span>
    <span class="k">operator</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">object</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// オブジェクトによる初期化</span>
    <span class="kt">int</span> <span class="n">int_object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref_int</span> <span class="o">=</span> <span class="n">int_object</span> <span class="p">;</span>

<span class="c1">// 関数による初期化の例</span>
    <span class="kt">void</span> <span class="p">(</span> <span class="o">&amp;</span><span class="n">ref_function</span> <span class="p">)(</span><span class="kt">void</span><span class="p">)</span> <span class="o">=</span> <span class="n">f</span> <span class="p">;</span>

<span class="c1">// int型に変換可能なオブジェクトによる初期化</span>
    <span class="n">Integer</span> <span class="n">integer_object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref_integer</span> <span class="o">=</span> <span class="n">integer_object</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>リファレンスは、必ず初期化されなければならない。リファレンスの参照先を変更することはできない。リファレンスは、参照先のオブジェクトと同じように振舞う。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// x = 0 と同じ</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">y</span> <span class="p">;</span> <span class="c1">// x = y と同じ、参照先は変わらない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数の仮引数、関数の戻り値の型、クラス定義の中のクラスメンバー宣言、extern指定子が明示的に使われている宣言では、リファレンスの初期化子を省略できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 関数の仮引数</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// 関数の戻り値の型</span>
<span class="kt">int</span> <span class="o">&amp;</span> <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="k">auto</span> <span class="n">g</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="p">;</span>

<span class="c1">// クラス定義のクラスメンバーの宣言</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="p">;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// extern指定子（refは別の場所で定義されている）</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="p">;</span>
</pre></div>
</div>
<p>もちろん、これらのリファレンスも、使うときには、初期化されていなければならない。</p>
<p>リファレンスの具体的な初期化について説明する前に、リファレンス互換（reference-compatible）を説明しなければならない。ある型、T1とT2があるとする。もし、T1が、T2と同じ型か、T2の基本クラス型であり、T1のCV修飾子が、T2のCV修飾子と同等か、それ以上の場合、T1はT2に対してリファレンス互換である。</p>
<p>一般に、T1がT2に対してリファレンス互換である場合、T1へのリファレンスは、T2へのリファレンスで初期化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// AとBとは、お互いにリファレンス互換ではない</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">A</span> <span class="n">a</span> <span class="p">;</span>
<span class="n">B</span> <span class="o">&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// エラー、リファレンス互換ではない</span>

<span class="c1">// BaseはDerivedに対して、リファレンス互換である</span>
<span class="c1">// DerivedはBaseに対して、リファレンス互換ではない</span>
<span class="c1">// 基本クラスは派生クラスに対してリファレンス互換であるが、</span>
<span class="c1">// 派生クラスは基本クラスに対してリファレンス互換ではない</span>
<span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">Base</span> <span class="n">base</span> <span class="p">;</span>
<span class="n">Derived</span> <span class="n">derived</span> <span class="p">;</span>

<span class="n">Base</span> <span class="o">&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">derived</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">base</span> <span class="p">;</span> <span class="c1">// エラー</span>

<span class="c1">// Non_const_intはConst_intに対して、リファレンス互換ではない</span>
<span class="c1">// Const_intはNon_const_intに対して、リファレンス互換である</span>
<span class="c1">// CV修飾子が同じか、それ以上である場合、リファレンス互換である</span>
<span class="c1">// CV修飾子が少ない場合、リファレンス互換ではない</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">Non_const_int</span> <span class="p">;</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="k">const</span> <span class="n">Const_int</span> <span class="p">;</span>

<span class="n">Non_const_int</span> <span class="n">nci</span> <span class="p">;</span>
<span class="n">Const_int</span> <span class="n">ci</span> <span class="p">;</span>

<span class="n">Non_const_int</span> <span class="o">&amp;</span> <span class="n">r4</span> <span class="o">=</span> <span class="n">ci</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="n">Const_int</span> <span class="o">&amp;</span> <span class="n">r5</span> <span class="o">=</span> <span class="n">nci</span> <span class="p">;</span> <span class="c1">// OK</span>
</pre></div>
</div>
<p>T型へのlvalueリファレンスは、リファレンス互換なlvalueで初期化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">object</span> <span class="p">;</span>

    <span class="n">Base</span> <span class="n">base</span> <span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">base</span> <span class="p">;</span>
<span class="c1">// 派生クラスのlvalueでも初期化できる</span>
    <span class="n">Derived</span> <span class="n">derived</span> <span class="p">;</span>
    <span class="n">Base</span> <span class="o">&amp;</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">derived</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="k">const</span> <span class="n">const_object</span> <span class="p">;</span>
    <span class="c1">// OK</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">r5</span> <span class="o">=</span> <span class="n">const_object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="k">volatile</span> <span class="o">&amp;</span> <span class="n">r6</span> <span class="o">=</span> <span class="n">const_object</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>基本的に、lvalueリファレンスはlvalueでしか初期化できない。xvalueやprvalueで初期化することはできない。また、CV修飾子を取り除くことはできない。以下はエラーの例である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;utility&gt;</span>

<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// エラー、BはAに対してリファレンス互換ではない</span>
    <span class="n">A</span> <span class="n">a</span> <span class="p">;</span>
    <span class="n">B</span> <span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="p">;</span>

    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// エラー、prvalueでは初期化できない</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">x</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、xvalueでは初期化できない</span>

    <span class="n">Base</span> <span class="n">base</span> <span class="p">;</span>
    <span class="n">Derived</span> <span class="o">&amp;</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">base</span> <span class="p">;</span> <span class="c1">// エラー、派生クラスは基本クラスに対してリファレンス互換ではない</span>

    <span class="kt">int</span> <span class="k">const</span> <span class="n">ci</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">r4</span> <span class="o">=</span> <span class="n">ci</span> <span class="p">;</span> <span class="c1">// エラー、CV修飾子が少ないので、リファレンス互換ではない</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>T型へのlvalueリファレンスは、リファレンス互換な型のlvalueに暗黙的に変換できるクラス型のオブジェクトで初期化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int &amp;に暗黙的に変換できるクラス</span>
<span class="k">struct</span> <span class="n">Integer</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="p">;</span>
    <span class="k">operator</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">object</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Integer</span> <span class="n">object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">object</span> <span class="p">;</span> <span class="c1">// OK、暗黙的にリファレンス互換なlvalueに変換できる</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>volatileではない、const T型へのlvalueリファレンスは、rvalueでも初期化できる。rvalueとは、prvalueとxvalueである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;utility&gt;</span>

<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// OK、prvalueで初期化できる</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
    <span class="c1">// OK、xvalueで初期化できる</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">object</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// エラー、たとえconstでも、volatileであってはならない</span>
    <span class="kt">int</span> <span class="k">volatile</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>volatileではない、const T型へのlvalueリファレンスが、rvalueでも初期化できるというのは、非常に異質なルールである。これは、C++にまだrvalueリファレンスがなかった時代に、リファレンスでrvalueをも参照する必要があったために導入されたルールである。</p>
<p>T型へのrvalueリファレンスは、リファレンス互換なrvalueで初期化できる。rvalueとは、xvalueとprvalueのことである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;utility&gt;</span>

<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// OK、prvalueで初期化できる</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">prvalue_ref</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>

    <span class="c1">// OK、xvalueで初期化できる</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">xvalue_ref</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">object</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>rvalueリファレンスは、必ずrvalueで初期化しなければならない。lvalueでは初期化できない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">object</span> <span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">object</span> <span class="p">;</span> <span class="c1">// エラー、lvalueでは初期化できない</span>
</pre></div>
</div>
<p>rvalueリファレンス自体はlvalueであるということに、注意しなければならない。もし、rvalueリファレンスをrvalueリファレンスで初期化したいのならば、明示的にrvalueにしなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;utility&gt;</span>

<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">rvalue_ref</span> <span class="o">=</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">rvalue_ref</span> <span class="p">;</span> <span class="c1">// エラー、rvalue_ref自体はlvalueである。</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span> <span class="n">rvalue_ref</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、xvalueでの初期化</span>
<span class="p">}</span>
</pre></div>
</div>
<p>T型へのrvalueリファレンスは、リファレンス互換な型のrvalueに暗黙的に変換できるクラス型のオブジェクトで初期化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;utility&gt;</span>

<span class="c1">// int &amp;&amp;に暗黙的に変換できるクラス</span>
<span class="k">struct</span> <span class="n">Integer</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">object</span> <span class="p">;</span>
    <span class="k">operator</span> <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">object</span><span class="p">)</span> <span class="p">;</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Integer</span> <span class="n">object</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">object</span> <span class="p">;</span> <span class="c1">// OK、暗黙的にリファレンス互換なrvalueに変換できる</span>
<span class="p">}</span>
</pre></div>
</div>
<p>rvalueリファレンスの初期化子が、リテラルの場合、一時オブジェクトが生成され、参照される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// 一時オブジェクトが生成される</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="list-initialization">
<h3>リスト初期化（List-initialization）<a class="headerlink" href="#list-initialization" title="Permalink to this headline">¶</a></h3>
<p>リスト初期化（List-initialization）とは、ひとつの{}で囲まれた初期化子を使ってオブジェクトやリファレンスを初期化することである。このような初期化子を、初期化リスト（Initializer list）という。初期化リストの中の、コンマで区切られた式のことを、初期化リストの要素という。</p>
<p>リスト初期化は、直接初期化でも、コピー初期化でも使える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">T</span> <span class="nf">x</span><span class="p">(</span> <span class="p">{</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// 直接初期化</span>
<span class="n">T</span> <span class="n">x</span><span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// 直接初期化</span>
<span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// コピー初期化</span>
</pre></div>
</div>
<p>直接初期化のリスト初期化を、直接リスト初期化（direct-list-initialization）といい、コピー初期化のリスト初期化を、コピーリスト初期化（copy-list-initialization）という。</p>
<div class="section" id="id17">
<h4>初期化リストの使える場所<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h4>
<p>初期化リストは、以下の場所で使うことができる。</p>
<p>変数定義の初期化子</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">T</span> <span class="nf">x</span><span class="p">(</span> <span class="p">{</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
<span class="n">T</span> <span class="n">x</span><span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="n">T</span> <span class="n">x</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>new式の初期化子</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">new</span> <span class="n">T</span><span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>return文</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;initializer_list&gt;</span>

<span class="k">auto</span> <span class="n">f</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数の実引数</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;initializer_list&gt;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>&lt;a href=&#8221;#expr.sub&#8221;&gt;添字&lt;/a&gt;</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;initializer_list&gt;</span>

<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="p">[]</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span> <span class="p">;</span>
    <span class="n">s</span><span class="p">[</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">]</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>コンストラクター呼び出しの実引数</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;initializer_list&gt;</span>

<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s1</span><span class="p">(</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">S</span> <span class="n">s2</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">S</span><span class="p">({</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">})</span> <span class="p">;</span> <span class="c1">// 関数形式のキャスト</span>
    <span class="n">S</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// 関数形式のキャスト</span>
<span class="p">}</span>
</pre></div>
</div>
<p>非staticデータメンバーの初期化子</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">m1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">m2</span><span class="p">[</span><span class="mi">3</span><span class="p">](</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="n">m3</span><span class="p">[</span><span class="mi">3</span><span class="p">]{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバー初期化子</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">;</span>
    <span class="c1">// 以下二行は同じ意味</span>
    <span class="n">S</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">()</span> <span class="o">:</span> <span class="n">data</span><span class="p">(</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>代入演算子の右側</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;initializer_list&gt;</span>

<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="o">=</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span> <span class="p">;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h4>初期化リストによる初期化の詳細<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<p>初期化リストによる初期化の詳細について説明する前に、縮小変換と、初期化リストコンストラクターを説明する。</p>
<div class="section" id="narrowing-conversion">
<h5>縮小変換（narrowing conversion）<a class="headerlink" href="#narrowing-conversion" title="Permalink to this headline">¶</a></h5>
<p>縮小変換（narrowing conversion）とは、暗黙の型変換のうち、変換先の型では、変換元の値を表現できない可能性のある変換のことをいう。具体的には、四種類の変換がある。</p>
<p>浮動小数点数型から整数型への変換。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 変換の一例</span>
<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="kt">double</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 縮小変換、doubleからint</span>
</pre></div>
</div>
<p>浮動小数点数型の間の変換のうち、long doubleからdoubleかfloatへの変換、doubleからfloatへの変換。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 縮小変換の例</span>
<span class="kt">long</span> <span class="kt">double</span> <span class="n">ld</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">l</span> <span class="p">;</span>
<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="p">;</span> <span class="c1">// 縮小変換、long doubleからdouble</span>
<span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">ld</span> <span class="p">;</span> <span class="c1">// 縮小変換、long doubleからfloat</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">d</span> <span class="p">;</span> <span class="c1">// 縮小変換、doubleからfloat</span>
</pre></div>
</div>
<p>整数型、もしくはunscoped enum型か、浮動小数点数型への変換。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 縮小変換の例</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="c1">// 縮小変換、intからdouble</span>
<span class="k">enum</span> <span class="p">{</span> <span class="n">e</span> <span class="p">}</span> <span class="p">;</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">e</span> <span class="p">;</span> <span class="c1">// 縮小変換、unscoped enumからdouble</span>
</pre></div>
</div>
<p>ある整数型、もしくはunscoped enum型から、別の整数型かunscoped enum型への変換において、変換先の型が、変換元の型の値を、すべて表現できない場合。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// short型はint型の値をすべて表現できないとする</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="n">i</span> <span class="p">;</span> <span class="c1">// 縮小変換</span>
</pre></div>
</div>
<p>ただし、最初の浮動小数点数型から整数型の変換を除く、三つの変換（浮動小数点間の変換、整数から浮動小数点数への変換、整数型間の変換）には、ひとつ例外がある。もし、変換元が定数式で、その値が変換先の型で表現可能な場合、縮小変換とはみなされない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">double</span> <span class="n">cd</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="p">;</span> <span class="c1">// cdは定数式</span>
<span class="kt">float</span> <span class="n">f</span> <span class="o">=</span> <span class="n">cd</span> <span class="p">;</span> <span class="c1">// 縮小変換ではない</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">ci</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// ciは定数式</span>
<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ci</span> <span class="p">;</span> <span class="c1">// 縮小変換ではない</span>
<span class="kt">short</span> <span class="n">s</span> <span class="o">=</span> <span class="n">ci</span> <span class="p">;</span> <span class="c1">// 縮小変換ではない</span>
</pre></div>
</div>
<p>これは、ソースコード中に定数式を書いた場合の、煩わしいエラーを防ぐための、例外的なルールである。</p>
<p>この場合、浮動小数点数では、変換元の定数式の値が、変換元の型では、正確に表現できなくてもよい。これは、浮動小数点数の特性に基づくものである。</p>
<p>初期化リストでは、縮小変換は禁止されている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span>  <span class="mf">0.0</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、縮小変換</span>
    <span class="kt">int</span> <span class="n">c</span><span class="p">{</span> <span class="mf">0.0</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、縮小変換</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">(</span> <span class="p">{</span> <span class="mf">0.0</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、縮小変換</span>

    <span class="c1">// OK、明示的な型変換</span>
    <span class="kt">int</span> <span class="n">d</span><span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span> <span class="p">}</span>  <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="initializer-list-constructor">
<h5>初期化リストコンストラクター（initializer-list constructor）<a class="headerlink" href="#initializer-list-constructor" title="Permalink to this headline">¶</a></h5>
<p>ある型をTとして、ひとつのstd::initializer_list&amp;lt;T&amp;gt;を仮引数に取るコンストラクターか、あるいは、最初の仮引数がstd::initializer_list&amp;lt;T&amp;gt;であり、続く仮引数すべてに、デフォルト実引数が指定されている場合、そのコンストラクターを、初期化リストコンストラクター（initializer-list constructor）という。</p>
<p>初期化リストコンストラクターの仮引数の型は、ある型Tに対する、std::initializer_list&amp;lt;T&amp;gt;か、そのリファレンスでなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include&lt;initializer_list&gt;</span>

<span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="c1">// 初期化リストコンストラクター</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// リファレンスでもよい</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">list</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// CV修飾子付きの型に対するリファレンスでもよい</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">list</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// これも初期化リストコンストラクター</span>
    <span class="c1">// デフォルト実引数のため</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// これらは初期化リストコンストラクターではない</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">short</span> <span class="n">value</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">short</span> <span class="n">value</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>初期化リストコンストラクターは、リスト初期化の際に、他のコンストラクターより優先して考慮される。</p>
</div>
</div>
<div class="section" id="id19">
<h4>リスト初期化の方法<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<p>リスト初期化は、以下のような優先順位で初期化される。先に書いてある条件に一致した場合、その初期化が選ばれ、その条件に対する初期化が行われる。後の条件は、先の条件に一致しなかった場合にのみ、考慮される。最後の条件にも当てはまらない場合は、エラーとなる。</p>
<p>T型のオブジェクト、あるいはT型へのリファレンスに対して――</p>
<div class="section" id="t">
<h5>初期化リストに要素がなく、Tはデフォルトコンストラクターを持つクラス型の場合<a class="headerlink" href="#t" title="Permalink to this headline">¶</a></h5>
<p>オブジェクトは値初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// デフォルトコンストラクターを持つクラス</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// すべて、値初期化される</span>
    <span class="n">A</span> <span class="n">a1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">A</span> <span class="n">a2</span><span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">A</span> <span class="n">a3</span><span class="p">(</span> <span class="p">{</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id20">
<h5>Tがアグリゲートの場合<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h5>
<p>&lt;a href=&#8221;#dcl.init.aggr&#8221;&gt;アグリゲート&lt;/a&gt;として初期化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Aggregate</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="p">;</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
<span class="c1">// アグリゲートとして初期化</span>
<span class="n">Aggregate</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">123</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">,</span> <span class="s">&quot;hello&quot;</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>縮小変換が必要な場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー、縮小変換が必要。</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<div class="section" id="tstd-initializer-list-e">
<h6>Tがstd::initializer_list&lt;E&gt;の場合<a class="headerlink" href="#tstd-initializer-list-e" title="Permalink to this headline">¶</a></h6>
<p>initializer_listのオブジェクトが構築される。この時、initializer_listの各要素は、初期化リストの各要素によって、初期化される。縮小変換が必要な場合は、エラーになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 空のinitializer_list</span>
<span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// 要素数3のinitializer_list</span>
<span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// std::stringを要素に持つinitializer_list</span>
<span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="s">&quot;C++&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、縮小変換が必要</span>
<span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id21">
<h5>Tがクラス型の場合<a class="headerlink" href="#id21" title="Permalink to this headline">¶</a></h5>
<p>適切なコンストラクターが選ばれる。縮小変換が必要な場合は、エラーとなる。まず、初期化リストコンストラクターが優先して選ばれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// S::S( std::initializer_list&lt;int&gt; )</span>
    <span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">S</span> <span class="n">s2</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">S</span> <span class="n">s3</span><span class="p">(</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>

    <span class="c1">// S::S( std::initializer_list&lt;double&gt; )</span>
    <span class="n">S</span> <span class="n">s4</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">S</span> <span class="n">s5</span><span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">S</span> <span class="n">s6</span><span class="p">(</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Tが初期化リストコンストラクターを持たない場合、初期化リストの要素が、実引数リストとみなされ、通常のコンストラクターが、オーバーロード解決によって選ばれる。縮小変換が必要な場合はエラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// S::S( int, int )</span>
    <span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span> <span class="p">;</span>
    <span class="c1">// S::S( int, double )</span>
    <span class="n">S</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">}</span> <span class="p">;</span>

    <span class="c1">// エラー、S::S( int, double )が選ばれるが、縮小変換が必要</span>
    <span class="n">S</span> <span class="n">s3</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>リスト初期化の優先順位に注意すること。初期化リストが空の場合は、すでに挙げた一番最初のリスト初期化の条件が選ばれ、値初期化されるので、ここでの条件による初期化が行われることはない。初期化リストコンストラクターは、通常のコンストラクターより、常に優先される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">S</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
    <span class="n">S</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// OK、値初期化される</span>
    <span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
    <span class="c1">// エラー、S( std::initializer_list&lt;int&gt; )が選ばれる</span>
    <span class="c1">// しかし、縮小変換が必要</span>
    <span class="n">S</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">0.0</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、s1はリスト初期化の最初の条件である、空の初期化リストを満たすので、値初期化される。s2では、初期化リストコンストラクターが優先される。S::S( double )が考慮されることはない。しかし、この場合、縮小変換が必要なので、エラーとなる。</p>
</div>
<div class="section" id="id22">
<h5>Tがリファレンス型の場合<a class="headerlink" href="#id22" title="Permalink to this headline">¶</a></h5>
<p>正確には、Tがクラス型へのリファレンスか、リファレンス型で、初期化リストが空の場合。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 条件に一致する例</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">C</span> <span class="o">&amp;&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// OK、Tがクラス型へのリファレンス</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// OK、リファレンス型で初期化子が空</span>

<span class="c1">// これは条件に一致しない。後の条件を参照</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>リファレンスされている型に対するprvalueの一時オブジェクトが生成され、初期化リストでリスト初期化される。リファレンスは、その一時オブジェクトを参照する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="n">B</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">A</span> <span class="o">&amp;&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">;</span>
    <span class="n">B</span> <span class="o">&amp;&amp;</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
    <span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>prvalueの一時オブジェクトが生成されることに注意しなければならない。prvalueを参照できるリファレンスは、rvalueリファレンスか、constかつ非volatileなlvalueリファレンスだけである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 以下はOK</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">r1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// OK、rvalueリファレンス</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">r2</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// OK、constかつ非volatileなlvalueリファレンス</span>

<span class="c1">// 以下はエラー</span>
<span class="kt">int</span> <span class="o">&amp;</span> <span class="n">r3</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、非constなlvalueリファレンス</span>
<span class="kt">int</span> <span class="k">const</span> <span class="k">volatile</span> <span class="o">&amp;</span> <span class="n">r4</span> <span class="o">=</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// エラー、constではあるが、volatileでもある</span>
</pre></div>
</div>
</div>
<div class="section" id="id23">
<h5>初期化リストの要素がひとつの場合<a class="headerlink" href="#id23" title="Permalink to this headline">¶</a></h5>
<p>オブジェクトは、初期化リストの要素で初期化される。縮小変換が必要な場合はエラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">a</span><span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>
<span class="kt">int</span> <span class="nf">b</span><span class="p">(</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">)</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 通常のリファレンスの初期化と同じ</span>
<span class="c1">// リファレンスの初期化</span>
</pre></div>
</div>
<div class="section" id="id24">
<h6>初期化リストに要素がない場合<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h6>
<p>オブジェクトは値初期化される。この条件に当てはまるのは、ポインターがある。クラスは、すでに先の条件に一致しているので、この条件には当てはまらない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pは値初期化される。つまり、nullポインターとなる。</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span><span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="std-initializer-list">
<h5>std::initializer_listの実装<a class="headerlink" href="#std-initializer-list" title="Permalink to this headline">¶</a></h5>
<p>std::initializer_listがどのように実装されるかは、規格では具体的に規定されていない。ただし、いくつかの保証はある。</p>
<p>std::initializer_list&amp;lt;E&amp;gt;型のオブジェクトは、{}で囲まれた初期化リストによって生成される。このとき、Eの配列が生成され、初期化リストによって初期化される。たとえば、以下のようなコードがあるとき、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>以下のように、ユーザー側からは見えない配列が生成される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">__array</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// 実装依存のstd::initializer_list&lt;int&gt;の初期化の実装例</span>
<span class="c1">// 配列の先頭要素へのポインターと、最後からひとつ後ろのポインターを格納する</span>
<span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">list</span><span class="p">(</span> <span class="n">array</span><span class="p">,</span> <span class="n">array</span> <span class="o">+</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>実際には、std::initializer_listには、このようなコンストラクターはない。あくまで参考のための、実装の一例である。</p>
<p>初期化リストにより生成される配列の寿命は、std::initializer_listのオブジェクトの寿命と同じである。</p>
<p>配列は、staticストレージか自動ストレージ上に構築される。動的ストレージの確保が起こることはない。というのも、動的にストレージを確保しなければならない技術的な理由はないからだ。</p>
</div>
</div>
</div>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="class.html" title="クラス（Classes）"
             >next</a> |</li>
        <li class="right" >
          <a href="dcl.dcl.html" title="宣言（Declarations）"
             >previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ezoe Ryou.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>