
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>テンプレート(Templates) &mdash; C++11: Syntax and Feature</title>
    
    <link rel="stylesheet" href="_static/cpp-book.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="C++11: Syntax and Feature" href="index.html" />
    <link rel="next" title="例外(Exception handling)" href="except.html" />
    <link rel="prev" title="オーバーロード(Overloading)" href="over.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="except.html" title="例外(Exception handling)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="over.html" title="オーバーロード(Overloading)"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="templates">
<h1>テンプレート(Templates)<a class="headerlink" href="#templates" title="Permalink to this headline">¶</a></h1>
<div class="section" id="template-parameters-arguments">
<h2>テンプレート仮引数/実引数(Template parameters/arguments)<a class="headerlink" href="#template-parameters-arguments" title="Permalink to this headline">¶</a></h2>
<p>テンプレート仮引数(template parameters)は、テンプレート側で記述する引数である。テンプレート実引数は、テンプレートに与える引数である。本来、テンプレート仮引数とテンプレート実引数は明確に別の機能であるが、本書では分かりやすさを重視して、同時に説明する。</p>
<p>テンプレート仮引数と実引数には、型、非型、テンプレートがある。ここでは、テンプレート仮引数の宣言方法とテンプレート実引数の渡し方を説明する。</p>
<div class="section" id="id1">
<h3>型テンプレート仮引数/実引数<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<p>型を引数に取るテンプレート仮引数は、classまたはtypenameというキーワードに続いて、テンプレート仮引数名を記述する。classとtypenameには、意味上の違いはない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Y</span> <span class="p">;</span>

<span class="c1">// 複数の引数を取る場合は、,で区切る</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
<span class="n">classs</span> <span class="n">X</span> <span class="p">;</span>
</pre></div>
</div>
<p>テンプレート実引数は、テンプレート名に続いて、&amp;lt; &amp;gt;で実引数を囲んで渡す。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// テンプレート実引数 int</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span>
    <span class="c1">// テンプレート実引数 int</span>
    <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>テンプレート仮引数は、テンプレートコードの中で、あたかも型や値であるかのように使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="c1">// T型のデータメンバーmemberの宣言</span>
    <span class="n">T</span> <span class="n">member</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>Tの具体的な型は、テンプレート実引数が与えられたときに、すなわち、テンプレートが実体化したときに決定される。</p>
</div>
<div class="section" id="id2">
<h3>非型テンプレート仮引数/実引数<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>非型テンプレート仮引数(non-type template parameters)は、型以外、つまり値を引数に取る。非型テンプレート仮引数は、class/typenameと記述する代わりに、型を記述する。非型テンプレート仮引数に使える型は以下の通り。</p>
<ul class="simple">
<li></li>
</ul>
<p>整数型とenum型</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 整数型の一例</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">UI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">ULLI</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// enum型の例</span>
<span class="k">enum</span> <span class="k">struct</span> <span class="n">E</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="n">E</span> <span class="n">value</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 非型テンプレート実引数</span>
    <span class="n">A</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0u</span><span class="p">,</span> <span class="mi">0ull</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="p">;</span>
    <span class="n">B</span><span class="o">&lt;</span> <span class="n">E</span><span class="o">::</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>オブジェクトへのポインターと、関数へのポインター</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// オブジェクトへのポインター</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">P</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 関数へのポインター</span>
<span class="k">using</span> <span class="n">func_ptr_type</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)()</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="n">func_ptr_type</span> <span class="n">FUN</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 非型テンプレート実引数</span>
    <span class="n">A</span><span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">global</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="p">;</span>
    <span class="n">B</span><span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">f</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>オブジェクトへのlvalueリファレンスと関数へのlvalueリファレンス</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// オブジェクトへのlvalueリファレンス</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">P</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 関数型のtypedef名</span>
<span class="k">using</span> <span class="n">func_type</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">()</span> <span class="p">;</span>
<span class="c1">// 関数へのlvalueリファレンス</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="n">func_type</span> <span class="o">&amp;</span> <span class="n">FUN</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">global</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 非型テンプレート実引数</span>
    <span class="n">A</span><span class="o">&lt;</span> <span class="n">global</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="p">;</span>
    <span class="n">B</span><span class="o">&lt;</span> <span class="n">f</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>メンバーへのポインター</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">member</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// メンバーへのポインター</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">X</span><span class="o">::*</span> <span class="n">P</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Y</span><span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">X</span><span class="o">::</span><span class="n">member</span> <span class="o">&gt;</span> <span class="n">y</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>std::nullptr_t</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">nullptr_t</span> <span class="n">N</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="n">X</span><span class="o">&lt;</span> <span class="n">nullptr</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>非型かつ非リファレンスのテンプレート仮引数はprvalueであり、いかなる方法を持っても代入などの値の変更をすることはできない。アドレスを取得することはできない。リファレンスに束縛される場合には、一時オブジェクトが使われる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 値の変更はできない</span>
    <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="o">++</span><span class="n">I</span> <span class="p">;</span> <span class="c1">// エラー</span>

<span class="c1">// アドレスの取得はできない</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">I</span> <span class="p">;</span> <span class="c1">// エラー</span>

<span class="c1">// リファレンスの束縛には一時オブジェクトがつかわれる</span>
    <span class="kt">int</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">I</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>非型テンプレート仮引数は、浮動小数点数型、クラス型、void型として宣言することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">double</span> <span class="n">d</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S1</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="n">x</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S2</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">void</span> <span class="n">v</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S3</span> <span class="p">;</span>
</pre></div>
</div>
<p>非型テンプレート仮引数の型が、「T型への配列」や、「T型を返す関数」である場合、それぞれ、「T型へのポインター」、「T型を返す関数へのポインター」と、型が変換される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// int * a</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S1</span> <span class="p">;</span>

<span class="c1">// int (*func)()</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">func</span><span class="p">()</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S2</span> <span class="p">;</span>
</pre></div>
</div>
<p>非型テンプレート実引数は、厳しい制約を受ける。</p>
<p>整数型とenum型の非型テンプレート仮引数に対するテンプレート実引数は、以下のとおりである。</p>
<ul>
<li><p class="first">テンプレート仮引数の型に変換できる定数式</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="n">s1</span> <span class="p">;</span>
    <span class="n">S</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">s2</span> <span class="p">;</span>

    <span class="n">constexpr</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
    <span class="n">S</span><span class="o">&lt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">s3</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li></li>
</ul>
<p>非型テンプレート仮引数の名前</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="n">A</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span> <span class="n">a</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>定数式の、静的ストレージ上のオブジェクトへのアドレスと関数で、リンケージを持つもの。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">ptr</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span> <span class="p">;</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)()</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">A</span><span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">B</span><span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">f</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">static</span> <span class="kt">int</span> <span class="n">no_linkage</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="c1">// リンケージを持たない</span>
    <span class="n">A</span><span class="o">&lt;</span> <span class="n">no_linkage</span> <span class="o">&gt;</span> <span class="n">a2</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>これは、実際にはもっと複雑な条件だが、本書では省略する。</p>
<ul class="simple">
<li>nullポインター、nullメンバーポインターの値であると評価される定数式</li>
<li>メンバーへのポインター</li>
</ul>
<p>文字列リテラルをテンプレート実引数として渡すことはできない。配列の要素へのアドレスを渡すこともできない。</p>
</div>
<div class="section" id="id3">
<h3>テンプレートテンプレート仮引数/実引数<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>テンプレート仮引数は、テンプレートを実引数に取ることができる。これをテンプレートテンプレート仮引数、テンプレートテンプレート実引数と呼ぶ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="c1">// ここはclassキーワードを使わなければならない</span>
    <span class="k">class</span> <span class="nc">U</span>
<span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">B</span>
<span class="p">{</span>
    <span class="c1">// Uはテンプレートとして使える</span>
    <span class="n">U</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">u</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">B</span><span class="o">&lt;</span> <span class="n">A</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span>

    <span class="n">B</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">e1</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">B</span><span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="n">e2</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>テンプレートテンプレート仮引数は、テンプレートを受け取る。テンプレートを受け取るテンプレートなので、「テンプレートテンプレート仮引数」となる。この宣言は、テンプレート仮引数自体が、さらにtemplateキーワードを使う文法になる。テンプレート仮引数の名前には、文法上の制約により、classキーワードを使わなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>テンプレートテンプレート仮引数に対するテンプレートテンプレート実引数は、クラステンプレートか、エイリアステンプレートでなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// クラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エイリアステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">B</span> <span class="o">=</span> <span class="n">T</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">U</span>  <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">C</span>
<span class="p">{</span>
    <span class="n">U</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">u</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">C</span><span class="o">&lt;</span> <span class="n">A</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// クラステンプレート</span>
    <span class="n">C</span><span class="o">&lt;</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// エイリアステンプレート</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>デフォルトテンプレート実引数<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>テンプレート仮引数には、デフォルトテンプレート実引数を指定することができる。デフォルトテンプレート実引数は、=に続けて実引数を記述する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

    <span class="n">X</span><span class="o">&lt;&gt;</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// X&lt; int, 0 &gt;</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// X&lt; double, 0 &gt;</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">short</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">c</span> <span class="p">;</span> <span class="c1">// X&lt; short, 1 &gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>デフォルトテンプレート実引数は、可変引数テンプレートを除く、すべての種類のテンプレート仮引数（型、非型、テンプレート）に指定できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 型テンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 非型テンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">123</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// テンプレートテンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">TEMP</span> <span class="o">=</span> <span class="n">X</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Z</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、可変引数テンプレートには指定できない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Error</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>デフォルトテンプレート実引数は、クラステンプレートのメンバーのクラス外部での定義に指定することはできない。これは説明が難しい。この場合のテンプレート仮引数には、クラスのテンプレートと、クラスのメンバーのテンプレートがあるが、このどちらにも、デフォルトテンプレート実引数を指定することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// クラステンプレートの定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
 <span class="c1">// メンバー関数テンプレートの宣言</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// クラス外部での定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="c1">// エラー（クラスXのテンプレート）</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="c1">// エラー（クラスXのメンバーfのテンプレート）</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span>
<span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>この場合、デフォルトテンプレート実引数を指定したい場合は、それぞれ、クラステンプレートの定義や、メンバーの宣言に指定しなければならない。</p>
<p>デフォルトテンプレート実引数は、friendクラステンプレートのメンバー宣言に指定することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="c1">// エラー</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">X</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>デフォルトテンプレート実引数が、friend関数テンプレート宣言に指定された場合、そのfriend関数テンプレート宣言は、定義でなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="c1">// エラー、宣言</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>

    <span class="c1">// OK、定義</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>これは、friend関数の宣言は、定義となることができるためである。詳しくは、&lt;a href=&#8221;#class.friend&#8221;&gt;friend&lt;/a&gt;を参照。</p>
<p>デフォルトテンプレート実引数が指定されているテンプレート仮引数に続くテンプレート仮引数には、デフォルトテンプレート実引数が指定されていなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー、後続のテンプレート仮引数にテンプレート実引数が指定されていない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span>
</pre></div>
</div>
<p>あるいは、後続のテンプレート仮引数は、可変引数テンプレート仮引数でなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>同じ宣言のテンプレート仮引数には、二度以上デフォルトテンプレート実引数を指定してはならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">B</span> <span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">C</span> <span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">C</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>デフォルトテンプレート実引数に与える式に含まれる&amp;gt;には注意が必要である。ネストされていない&amp;gt;は、テンプレート宣言の終了とみなされる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 文法エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">&gt;</span>
<span class="n">sturct</span> <span class="n">Y</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>テンプレートテンプレート仮引数内のテンプレート仮引数にも、デフォルトテンプレート実引数を指定することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">TT</span> <span class="o">=</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="n">T</span><span class="o">&lt;&gt;</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// T&lt; int &gt;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>可変テンプレート仮引数<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>識別子の前に...を記述したテンプレート仮引数は、仮引数パックの宣言となる。これは、可変引数テンプレート(Variadic Templates)のための仮引数の宣言である。詳しくは、&lt;a href=&#8221;#temp.variadic&#8221;&gt;可変引数テンプレート&lt;/a&gt;を参照。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="names-of-template-specializations">
<h2>テンプレート特殊化の名前(Names of template specializations )<a class="headerlink" href="#names-of-template-specializations" title="Permalink to this headline">¶</a></h2>
<p>特殊化されたテンプレートは、テンプレートID(template-id)によって参照できる。これは普通の名前とは違い、特殊化したテンプレート実引数を指定する。テンプレートidとは、テンプレート名に続いて、&amp;lt;を記述してテンプレート実引数を記述し、&amp;gt;で閉じることによって記述できる。</p>
<div class="highlight-c++"><pre>template &lt; typename T &gt;
struct X { } ;

X テンプレート名
X&lt;int&gt; テンプレートXをintに特殊化したテンプレートID</pre>
</div>
</div>
<div class="section" id="type-equivalence">
<h2>型の同一性(Type equivalence)<a class="headerlink" href="#type-equivalence" title="Permalink to this headline">¶</a></h2>
<p>二つのテンプレートidが同じクラスや関数であるためには、以下の条件を満たさなければならない。</p>
<ul class="simple">
<li></li>
</ul>
<p>テンプレート名、演算子関数ID（オーバーロード演算子のテンプレートの場合）、リテラル演算子ID（オーバーロードリテラル演算子のテンプレートの場合）が同じ</p>
<ul class="simple">
<li></li>
</ul>
<p>対応するテンプレート実引数の型が等しい。</p>
<ul class="simple">
<li></li>
</ul>
<p>対応する非型テンプレート実引数の値が同じ。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;type_traits&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>対応する非型テンプレート実引数が、ポインター、メンバーへのポインター、リファレンスの場合、同じ外部オブジェクトを指し示していなければならない。ポインターとメンバーへのポインターの場合、nullポインターでもよい。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;type_traits&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">P</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="n">a</span> <span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;&amp;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;&amp;</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;&amp;</span><span class="n">a</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;&amp;</span><span class="n">b</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">nullptr</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">nullptr</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// true</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>対応するテンプレートテンプレート実引数が同じ。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;type_traits&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Y</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Z</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">Y</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">Z</span><span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="template-declarations">
<h2>テンプレート宣言(Template declarations)<a class="headerlink" href="#template-declarations" title="Permalink to this headline">¶</a></h2>
<div class="section" id="class-templates">
<h3>クラステンプレート(Class templates)<a class="headerlink" href="#class-templates" title="Permalink to this headline">¶</a></h3>
<p>クラステンプレートはテンプレート仮引数に続けてクラス宣言を書くことで宣言できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">SIZE</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="n">T</span> <span class="n">buf</span><span class="p">[</span><span class="n">SIZE</span><span class="p">]</span> <span class="p">;</span>
<span class="k">public</span> <span class="o">:</span>

    <span class="n">Array</span><span class="p">()</span> <span class="o">:</span> <span class="n">buf</span><span class="p">{}</span>
    <span class="p">{</span> <span class="p">}</span>

    <span class="n">T</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">)</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span> <span class="p">}</span>

    <span class="n">T</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="k">operator</span> <span class="p">[](</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="p">)</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">;</span> <span class="p">}</span>

<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Array</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="p">;</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>テンプレート仮引数は、型や値やテンプレートとして使うことができ、テンプレートが実体化されたときにテンプレート実引数によって置き換えられる。</p>
<p>クラステンプレートのメンバー関数、メンバークラス、メンバーenum、staticデータメンバー、メンバーテンプレートを、メンバーが属するクラステンプレート定義の外部で定義する場合は、メンバー定義には、メンバーが属するひとつ外側のクラステンプレートのテンプレート仮引数を記述し、さらにメンバーが属するひとつ外側のクラステンプレートのテンプレート名に続けてテンプレート実引数リストを、同じ順番で記述しなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Outer</span>
<span class="p">{</span>
    <span class="c1">// クラス定義内部のでのメンバーの宣言</span>
    <span class="kt">void</span> <span class="n">member_function</span><span class="p">()</span> <span class="p">;</span>
    <span class="k">class</span> <span class="nc">member_class</span> <span class="p">;</span>
    <span class="k">enum</span> <span class="k">struct</span> <span class="n">member_enum</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">;</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">static_data_member</span> <span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">member_template</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// クラス定義外部でのメンバーの定義</span>

<span class="c1">// メンバー関数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">member_function</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// メンバークラス</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Outer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">member_class</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// メンバーenum</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">enum</span> <span class="k">struct</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">member_enum</span> <span class="o">:</span> <span class="kt">int</span>
<span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// staticデータメンバー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">static_data_member</span> <span class="p">;</span>

<span class="c1">// メンバーテンプレート</span>
<span class="c1">// クラス以外のテンプレートも同じ方法で記述する</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="c1">// Outerのテンプレート仮引数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span> <span class="c1">// member_templateのテンプレート仮引数</span>
<span class="k">class</span> <span class="nc">Outer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">member_template</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>これは、一見すると、恐ろしいほど難しそうに見えるが、クラスのメンバーをクラス定義の外部で宣言する文法に、テンプレート仮引数が加わっただけだ。ただし、メンバーテンプレートの定義方法だけは、少し分かりにくい。クラステンプレートのメンバーテンプレートには、メンバーテンプレートのテンプレート仮引数と、メンバーテンプレートが属するクラステンプレートのテンプレート仮引数の、両方が必要だからだ。</p>
<p>もちろん、メンバーはいくらでもネストできるので、宣言はもっと複雑になることもある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Outer</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Inner</span>
    <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">V</span> <span class="o">&gt;</span>
        <span class="k">class</span> <span class="nc">Deep</span> <span class="p">;</span>
    <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="c1">// Outerのテンプレート仮引数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span> <span class="c1">// Innerのテンプレート仮引数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">V</span> <span class="o">&gt;</span> <span class="c1">// Deepのテンプレート仮引数</span>
<span class="k">class</span> <span class="nc">Outer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Inner</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;::</span><span class="n">Deep</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="member-templates">
<h3>メンバーテンプレート(Member Templates)<a class="headerlink" href="#member-templates" title="Permalink to this headline">¶</a></h3>
<p>テンプレートは、クラス定義の内部で宣言することができる。そのようなテンプレートを、メンバーテンプレート(Member Templates)と呼ぶ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Outer</span>
<span class="p">{</span>
    <span class="c1">// メンバーテンプレート</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Inner</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバーテンプレートは、クラス定義の内部でも外部でも定義できる。メンバーをクラス定義の外で定義する方法については、&lt;a href=&#8221;#temp.class&#8221;&gt;クラステンプレート(Class templates)&lt;/a&gt;を参照。</p>
<p>メンバーテンプレートには、いくつかの制限や例外的なルールが存在する。</p>
<p>ローカルクラスはメンバーテンプレートを持つことができない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// エラー、</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>デストラクターはメンバーテンプレートとして宣言できない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="c1">// エラー</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバー関数テンプレートはvirtual関数にはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="c1">// エラー</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>また、メンバー関数テンプレートの特殊化は基本クラスのvirtual関数をオーバーライドすることはない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// Base::fをオーバーライドしない</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="variadic-templates">
<h3>可変引数テンプレート(Variadic Templates)<a class="headerlink" href="#variadic-templates" title="Permalink to this headline">¶</a></h3>
<p>可変引数テンプレート(Variadic templates)は、0個以上のテンプレート実引数や関数実引数を取るテンプレートのことである。</p>
<p>テンプレート仮引数の宣言で、識別子の前に...が記述されているとき、これをテンプレート仮引数パック(Template parameter pack)と呼ぶ。</p>
<div class="highlight-c++"><pre>// 型テンプレート仮引数パック
template &lt; typename ... Type_pack &gt;
class X { } ;

// 非型テンプレート仮引数パック
template &lt; int ... Int_pack &gt;
class Y { } ;

// テンプレートテンプレート仮引数パック
template &lt; template &lt; typename &gt; class ... Template_pack &gt;
class Z { } ;

// テンプレート実引数として与えるためのテンプレート
template &lt; typename T &gt;
class Arg { } ;

int main( )
{
    X&lt; &gt; x1 ;
    X&lt; int &gt; x2 ;
    X&lt; int, int, double, float &gt; x3 ;

    Y&lt; &gt; y1 ;
    Y&lt; 0 &gt; y2 ;
    Y&lt; 1, 2, 3, 4, 5 &gt; y3 ;

    Z&lt; &gt; z1 ;
    Z&lt; Arg &gt; z2 ;
    Z&lt; Arg, Arg, Arg &gt; z3 ;
}</pre>
</div>
<p>上記の例のように、テンプレート仮引数パックは、0個以上の任意の数のテンプレート実引数を取る。</p>
<p>非型テンプレート仮引数として、オブジェクトや関数へのポインターやリファレンスなども可変引数テンプレートにできる。ただし、記述方法が少し分かりにくい。そのため、直接書くよりもtypedef名を使う方が読みやすくなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// やや読みにくい宣言</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">void</span> <span class="p">(</span> <span class="o">*</span> <span class="p">...</span> <span class="n">func_pack</span> <span class="p">)</span> <span class="p">()</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)()</span> <span class="p">;</span>
<span class="c1">// 読みやすい宣言</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="n">type</span> <span class="p">...</span> <span class="n">func_pack</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Y</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>可変引数テンプレートをテンプレート実引数に取るテンプレートテンプレート仮引数は、以下のように書く。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 可変引数テンプレートを取る可変引数テンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Type</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Template</span>
<span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// テンプレート実引数に渡すテンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Type_pack</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Arg</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="n">Arg</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もちろん、このクラステンプレートXを、さらに可変引数テンプレートにすることもできる。</p>
<div class="highlight-c++"><pre>// 可変引数テンプレートを取る可変引数テンプレート
template &lt;
    template &lt; typename ... Type_pack &gt; class ... Template_pack
&gt;
class X { } ;

// テンプレート実引数に渡すテンプレート
template &lt; typename ... Type_pack &gt;
class Arg { } ;

int main( )
{
    X&lt; Arg, Arg, Arg &gt; x ;
}</pre>
</div>
<p>関数仮引数パック(function parameter pack)は、テンプレート仮引数パックを使って、0個以上の関数の実引数を得る関数仮引数である。宣言方法は、関数の仮引数の識別子の前の...を記述する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 任意の型の0個以上の実引数をとる関数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">template_parameter_pack</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">template_parameter_pack</span> <span class="p">...</span> <span class="n">function_parameter_pack</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>テンプレート仮引数パックと関数仮引数パックをあわせて、仮引数パック(Parameter pack)という。</p>
<p>仮引数パックは、そのままでは使えない。仮引数パックを使うには、展開しなければならない。これをパック展開(Pack expansion)という。パック展開は、パターンと...を組み合わせて記述する。テンプレートの実体化の際に、0個以上の実引数が、パターンに合わせて展開される。パターンの範囲は文脈により異なるが、見た目上は、仮引数パックを含む文字列を繰り返しているように見えるよう設計されている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list_impl</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">type_list_impl</span><span class="o">&lt;</span>
        <span class="n">pack</span> <span class="c1">// パターン</span>
        <span class="p">...</span>
    <span class="o">&gt;</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// type_list_impl&lt;&gt;</span>
    <span class="n">type_list</span><span class="o">&lt;&gt;::</span><span class="n">type</span> <span class="n">t1</span> <span class="p">;</span>
    <span class="c1">// type_list_impl&lt;int, int&gt;</span>
    <span class="n">type_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">type</span> <span class="n">t2</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、type_listの仮引数パックであるpackをパック展開して、type_list_implのテンプレート実引数に渡している。&#8221;pack...&#8221;というのが、パック展開である。packがパターンだ。この場合は、そのまま展開している。</p>
<p>関数仮引数パックの場合も同様である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f_impl</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f_impl</span><span class="p">(</span> <span class="n">pack</span><span class="p">...</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// f_impl( )を呼ぶ</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
    <span class="c1">// f_impl( 1, 2, 3 )を呼ぶ</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここでも、&#8221;pack...&#8221;がパック展開で、packがパターンになっている。</p>
<p>パターンの記述は、パック展開の文脈に依存する。パック展開中の仮引数パックに対するパターンには、その文脈で許される記述をすることができ、そのパターンによって展開される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">wrap</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list_impl</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">pointers</span> <span class="o">=</span> <span class="n">type_list_impl</span><span class="o">&lt;</span>
        <span class="n">pack</span> <span class="o">*</span><span class="p">...</span>
    <span class="o">&gt;</span> <span class="p">;</span>

    <span class="k">using</span> <span class="n">references</span> <span class="o">=</span> <span class="n">type_list_impl</span><span class="o">&lt;</span>
        <span class="n">pack</span> <span class="o">&amp;</span><span class="p">...</span>
    <span class="o">&gt;</span> <span class="p">;</span>

    <span class="k">using</span> <span class="n">wraps</span> <span class="o">=</span> <span class="n">type_list_impl</span><span class="o">&lt;</span>
        <span class="n">wrap</span><span class="o">&lt;</span><span class="n">pack</span><span class="o">&gt;</span><span class="p">...</span>
    <span class="o">&gt;</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// type_list_impl&lt; char *, short *, int * &gt;</span>
    <span class="n">type_list</span><span class="o">&lt;</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;::</span><span class="n">pointers</span> <span class="n">t1</span> <span class="p">;</span>

    <span class="c1">// type_list_impl&lt; char &amp;, short &amp;, int &amp; &gt;</span>
    <span class="n">type_list</span><span class="o">&lt;</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;::</span><span class="n">references</span> <span class="n">t2</span> <span class="p">;</span>

    <span class="c1">// type_list_impl&lt; wrap&lt;char&gt;, wrap&lt;short&gt;, wrap&lt;int&gt; &gt;</span>
    <span class="n">type_list</span><span class="o">&lt;</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;::</span><span class="n">wraps</span> <span class="n">t3</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>packがテンプレート仮引数パックであるならば、pack * ...はそれぞれの実引数に*を加えたパターンとして展開される。wrap&amp;lt;pack&amp;gt;は、それぞれの実引数をクラステンプレートwrapの実引数に渡すパターンとして展開される。</p>
<p>関数仮引数パックの場合も同様。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">param_pack</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">param_pack</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 仮引数名の省略</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="n">T</span> <span class="n">identity</span><span class="p">(</span> <span class="n">T</span> <span class="n">value</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">value</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">param_pack</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="n">param_pack</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">pack</span> <span class="p">...</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// そのまま関数fに渡す</span>
    <span class="n">f</span><span class="p">(</span> <span class="p">(</span><span class="n">pack</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)...</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// +1して関数fに渡す</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">identity</span><span class="p">(</span><span class="n">pack</span><span class="p">)...</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// identity()の評価の結果を関数fに渡す</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">g</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">g</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">g</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span> <span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>パック展開できる文脈は限られているが、一般に、型や式をコンマで区切って記述する文脈に書くことができる。</p>
<p>まず、特別なパック展開が三種類ある。ただし、規格上は区別されてない。この特別なパック展開は、パック展開でありながら、仮引数パックでもあるという特徴を持つ。</p>
<ul class="simple">
<li></li>
</ul>
<p>関数仮引数パックの宣言</p>
<p>関数仮引数パックの宣言は、...以外がそのままパック展開のパターンにもなる。そのため、これは仮引数パックかつパック展開となる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">param_pack</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">param_pack</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>この例では、&#8221;param const &amp;amp;&#8221;がパターンとなる。</p>
<p>関数仮引数パックは、宣言自体がパターンとなっているので、実引数の型がパターンに一致しない場合、実引数推定が失敗する。これを利用して、型を部分的に限定することができる。</p>
<blockquote>
<div><div class="highlight-c++"><pre>// ポインター型しか実引数に指定できない関数
template &lt; typename ... Types &gt;
void f( Types * ... pack  )
{　}

int main( )
{
    int * p = nullptr ;
    f( p ) ; // OK
    f( 123 ) ; // エラー
}</pre>
</div>
</div></blockquote>
<p>同様に、メンバーへのポインターや、関数へのポインターに限定することもできる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 実引数を取らず、任意の型を戻り値に返す関数へのポインターを実引数に取る関数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">ReturnType</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">ReturnType</span> <span class="p">(</span><span class="o">*</span> <span class="p">...</span> <span class="n">pack</span><span class="p">)</span> <span class="p">(</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">h</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="kt">double</span> <span class="n">i</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>パターンは...を除いた部分なので、この場合のパターンは、&#8221;ReturnType (*)()&#8221;となる。つまり関数へのポインター型になっている。</p>
<p>もっと複雑な条件で型を限定したい場合は、テンプレートメタプログラミングの技法を使うことができる。その詳細は本書の範疇を超えるので、ここには書かない。</p>
<ul class="simple">
<li></li>
</ul>
<p>テンプレート仮引数パックがパック展開となる場合</p>
<p>これには二種類ある。ひとつは、非型テンプレート仮引数パックの仮引数宣言に、先に宣言されたテンプレート仮引数が使われる場合。パターンは、...を除いた部分となる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="cm">/* パターンここから */</span> <span class="n">T</span> <span class="o">*</span> <span class="cm">/* パターンここまで */</span><span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nullptr</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>この例では、&#8221;T <a href="#id6"><span class="problematic" id="id7">*</span></a>&#8220;がパターンとなっている。関数仮引数パックと同じように、実引数の型を制限できる。</p>
<p>もうひとつは、テンプレートテンプレート仮引数パックの中で、先に宣言されたテンプレート仮引数パックが使われる場合。パターンは...を除いた部分となる</p>
<blockquote>
<div><div class="highlight-c++"><pre>template&lt; typename ... Types &gt;
struct Outer
{
    template&lt; template&lt; Types &gt; class ... pack &gt;
    struct Inner ;
} ;</pre>
</div>
</div></blockquote>
<p>これは少し分かりにくい。仮引数パックTypesのパック展開が、クラステンプレートInnerのテンプレート仮引数で行われている。パターンは、&#8221;template&amp;lt; Types &amp;gt; class&#8221;だ。</p>
<p>今、Outer&amp;lt; char, short, int &amp;gt;のようにテンプレート実引数が渡されたとすると、Innerのパック展開の結果を擬似的に記述すると、以下のようになる。。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">char</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span>
        <span class="k">template</span> <span class="o">&lt;</span> <span class="kt">char</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">pack_1</span><span class="p">,</span>
        <span class="k">template</span> <span class="o">&lt;</span> <span class="kt">short</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">pack_2</span><span class="p">,</span>
        <span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">pack_3</span>
    <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Inner</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>つまり、テンプレートInnerのテンプレート仮引数は、テンプレートテンプレート仮引数がパターンで、仮引数パックであるTypesに対してパターンを適用してパック展開されることになる。</p>
<p>これはあくまで解説のための擬似的なコードである。可変引数テンプレートは、パックとパック展開という形で使うので、手で書いたようなテンプレートに展開されるわけではない。</p>
<p>その他のパック展開だけの文脈は以下の通り。</p>
<ul class="simple">
<li></li>
</ul>
<p>初期化リストの中</p>
<p>関数呼び出し式の中の式リストも、初期化リストである。パターンは初期化子の式となる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
    <span class="n">X</span><span class="p">(</span> <span class="n">pack</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span> <span class="n">x</span><span class="p">(</span> <span class="n">pack</span> <span class="p">...</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">pack</span><span class="p">...</span> <span class="p">)</span> <span class="p">;</span>

    <span class="n">f</span><span class="p">(</span> <span class="p">(</span><span class="n">pack</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)...</span> <span class="p">)</span> <span class="p">;</span><span class="c1">// パターンはpack+1</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>基本クラス指定リストの中</p>
<p>これにより、仮引数パックに対するすべての実引数の型を基本クラスに指定することができる。パターンは基本クラス指定子。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="o">:</span> <span class="n">pack</span> <span class="p">...</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">A</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span> <span class="c1">// 基本クラスなし</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="n">A</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span> <span class="c1">// 基本クラスA</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="n">x3</span> <span class="p">;</span> <span class="c1">// 基本クラスB</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="o">&gt;</span> <span class="n">x4</span> <span class="p">;</span> <span class="c1">// 基本クラスAとB</span>

    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x5</span> <span class="p">;</span> <span class="c1">// エラー、intは基本クラスにできない</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>複雑なパターンの例。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">wrap</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="o">:</span> <span class="n">wrap</span><span class="o">&lt;</span> <span class="n">pack</span> <span class="o">&gt;</span> <span class="p">...</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Xの基本クラスはwrap&lt;int&gt;とwrap&lt;double&gt;</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>この例では、テンプレート実引数はwrap&amp;lt;T&amp;gt;に包まれて基本クラスに指定される。そのため、直接intから派生するのではなく、テンプレートwrapの特殊化から派生することになる。</p>
<ul class="simple">
<li></li>
</ul>
<p>メンバー初期化リスト</p>
<p>これは、初期化リストとほぼおなじだ。パターンはメンバー初期化子の式になる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
    <span class="n">X</span><span class="p">(</span> <span class="n">pack</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Y</span>
<span class="p">{</span>
    <span class="n">X</span> <span class="n">x</span> <span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
    <span class="n">Y</span><span class="p">(</span> <span class="n">pack</span> <span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
        <span class="o">:</span> <span class="n">x</span><span class="p">(</span> <span class="n">args</span><span class="p">...</span> <span class="p">)</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">Y</span> <span class="n">y</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>テンプレート実引数リスト</p>
<p>パターンはテンプレート実引数。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">wrap</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span>
<span class="p">{</span>
    <span class="c1">// パターンはpack</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="n">pack</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span>
    <span class="c1">// パターンはwrap&lt;pack&gt;</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="n">wrap</span><span class="o">&lt;</span><span class="n">pack</span><span class="o">&gt;</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>アトリビュートリスト</p>
<p>パターンはアトリビュート</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="p">[[</span> <span class="n">pack</span> <span class="p">...</span> <span class="p">]]</span> <span class="p">;</span>

<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>アライメント指定子</p>
<p>パターンは...を除いたアライメント指定子</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="n">alignas</span><span class="p">(</span> <span class="n">pack</span> <span class="p">...</span> <span class="p">)</span> <span class="kt">int</span> <span class="n">data_member</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>たとえば、X&amp;lt;int, short, double&amp;gt;と実引数を与えると、この特殊化されたクラスXのデータメンバーdata_memberのアライメント指定は、alignas( int, short, double )と記述したものと等しくなる。</p>
<ul class="simple">
<li></li>
</ul>
<p>キャプチャーリスト</p>
<p>パターンはキャプチャー</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f_impl</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// キャプチャーのパターンは&amp;pack</span>
    <span class="p">[</span> <span class="o">&amp;</span><span class="n">pack</span> <span class="p">...</span> <span class="p">]{</span> <span class="n">f_impl</span><span class="p">(</span> <span class="n">pack</span><span class="p">...</span> <span class="p">)</span> <span class="p">;</span> <span class="p">}()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>この例では、関数仮引数パックをパック展開して、ラムダ式でリファレンスキャプチャーしている。</p>
<ul class="simple">
<li></li>
</ul>
<p>sizeof...式</p>
<p>sizeof...式も、パック展開の一種である。ただし、パターンは識別子なので、特に特別なことはできない。ただ、仮引数パックの数を返すだけだ。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">f</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 評価はテンプレート仮引数パックの数</span>
    <span class="k">sizeof</span><span class="p">...(</span><span class="n">args</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// 評価は関数仮引数パックの数</span>

    <span class="k">return</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">Types</span><span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 評価は0</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// 評価は3</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<div class="section" id="id8">
<h4>可変引数テンプレートの使い方<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>本書はコア言語の文法と機能を解説するものであって、使い方を紹介するものではない。ただし、可変引数テンプレートでは、最低限の使い方を解説する。</p>
<p>仮引数テンプレートは、仮引数パックによって、0個以上の実引数を取ることができる。ただし、仮引数パックはそのままでは使えない。仮引数パックは、仮引数ではないからだ。仮引数パックを使うには、パック展開しなければならない。では、一体どうやって、任意個の実引数に対応した汎用的なコードを書くのか。それには、二つ方法がある。固定長の仮引数を取るものに渡すか再帰だ。</p>
<p>固定長の仮引数を取るものに渡すというのは、単にパック展開して渡せばよい。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;iostream&gt;</span>

<span class="c1">// 実引数ゼロ個の時は何もしない</span>
<span class="kt">void</span> <span class="nf">print_impl</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print_impl</span><span class="p">(</span> <span class="n">T1</span> <span class="n">a1</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print_impl</span><span class="p">(</span> <span class="n">T1</span> <span class="n">a1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">a2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">pack</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">print_impl</span><span class="p">(</span> <span class="n">pack</span> <span class="p">...</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">print</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">print</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">print</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">print</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>問題は、コード例をみても分かるように、このコードは汎用的ではないという事だ。固定長の仮引数を持つ関数に渡しているために、固定長しか扱えない。これではせっかくの可変引数の意味がない。</p>
<p>固定長の仮引数を取るものに渡すというのは、特定の条件で、特別な処理をしたい場合に使えるが、汎用的に使うことはできない。</p>
<p>任意の個数の実引数に対応した汎用的なコードを書くためには、再帰を使う。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 再帰の終了条件</span>
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span>  <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">print</span><span class="p">(</span> <span class="n">T</span> <span class="n">head</span><span class="p">,</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">tail</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">head</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="p">;</span>
    <span class="n">print</span><span class="p">(</span> <span class="n">tail</span> <span class="p">...</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// 再帰的実体化</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">print</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">print</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">print</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">print</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>再帰と言っても、同じ関数を再帰的に呼び出すわけではない。仮引数パックで受ける実引数の数をひとつづつ減らしていき、新たなテンプレートを実体化させて呼び出している。たとえば、print(1, 2, 3, 4, 5)を呼び出した場合、以下のように実体化されて呼び出される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span>
<span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span>
<span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span>
<span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">)</span>
<span class="n">print</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">5</span> <span class="p">)</span>
<span class="n">print</span><span class="p">()</span>
</pre></div>
</div>
<p>トリックは、実引数をすべて仮引数パックで受けるのではなく、一つを除いた残りを受ける形にすることだ。これにより、実引数をひとつづつ減らしながら再帰的にテンプレートを実体化して呼び出すことができる。ただし、仮引数パックは0個の実引数を受けることができるので、そのままではコンパイル時に無限ループしてしまう。コンパイル時無限ループを防ぎ、コンパイル時再帰を正しく終了させるために、仮引数を取らない非テンプレートな関数を用意している。オーバーロード解決により、非テンプレートな関数は、関数テンプレートの実体化より優先される。</p>
<p>また、仮引数パックを使わない関数テンプレートの実体化は、仮引数パックを使う関数テンプレートの実体化より、オーバーロード解決で優先される。たとえば、二つ以上の任意個の実引数を取り、最小の値を返す関数テンプレートminは、以下のように実装できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 終了条件</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="n">T</span> <span class="n">min</span> <span class="p">(</span> <span class="n">T</span> <span class="n">a1</span><span class="p">,</span> <span class="n">T</span> <span class="n">a2</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a1</span> <span class="o">&lt;</span> <span class="n">a2</span> <span class="o">?</span> <span class="n">a1</span> <span class="o">:</span> <span class="n">a2</span> <span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="n">T</span> <span class="n">min</span><span class="p">(</span> <span class="n">T</span> <span class="n">head</span><span class="p">,</span> <span class="n">Types</span> <span class="p">...</span> <span class="n">tail</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">min</span><span class="p">(</span> <span class="n">head</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span> <span class="n">tail</span> <span class="p">...</span> <span class="p">)</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>クラステンプレートのテンプレート仮引数パックの場合も、同様に、固定長へのパック展開か、再帰的な汎用コードが使える。</p>
<p>固定長へのパック展開の例は、以下の通り。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list_impl</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list</span>
    <span class="o">:</span> <span class="n">type_list_impl</span><span class="o">&lt;</span> <span class="n">pack</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>明らかに、このコードは汎用的ではない。それに、クラステンプレートには、部分的特殊化があるので、このようなことはしなくても固定長への特殊化はできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Primary Class Template</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list</span><span class="o">&lt;</span> <span class="n">T1</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">type_list</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>ただし、固定長の別の関数にパック展開する関数仮引数パックと同じように、固定長の部分的特殊化は、汎用的ではない。特定の条件に対する特殊な別の実装のためには適切であっても、汎用的なコードは書けない。</p>
<p>テンプレート仮引数パックを使うクラステンプレートを汎用的に書くには、再帰を使えばよい。再帰の方法として、再帰的に基本クラスから派生する方法と、再帰的にデータメンバーとして持つ方法がある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 再帰的に基本クラスから派生する方法</span>
<span class="c1">// primary class template</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">base_class_trick</span> <span class="p">;</span>

<span class="c1">// 部分的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Tail</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">base_class_trick</span><span class="o">&lt;</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
    <span class="o">:</span> <span class="n">base_class_trick</span><span class="o">&lt;</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 終了条件</span>
<span class="k">template</span> <span class="o">&lt;</span>  <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">base_class_trick</span><span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 再帰的にデータメンバーとして持つ方法</span>
<span class="c1">// primary template</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">data_member_trick</span> <span class="p">;</span>

<span class="c1">// 部分的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Tail</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">data_member_trick</span><span class="o">&lt;</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">data_member_trick</span><span class="o">&lt;</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="n">tail</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 終了条件</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">data_member_trick</span><span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>自分自身から派生したり、自分自身をデータメンバーに持っているわけではない。再帰のたびに、別の実体化を発動させるので、派生したりデータメンバーに持っているのは、別のクラスである。再帰の終了には、部分的特殊化か、明示的特殊化を使う。</p>
<p>これを応用して、任意のテンプレート実引数の型と数をコンストラクターで受け取り、クラスのデータメンバーとして格納するクラスが書ける。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Tail</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
    <span class="o">:</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="p">{</span>
        <span class="n">Head</span> <span class="n">data</span> <span class="p">;</span>
        <span class="n">tuple</span><span class="p">(</span> <span class="n">Head</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="n">head</span><span class="p">,</span> <span class="n">Tail</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">...</span> <span class="n">tail</span> <span class="p">)</span>
            <span class="o">:</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span><span class="p">(</span> <span class="n">tail</span> <span class="p">...</span> <span class="p">),</span>
              <span class="n">data</span><span class="p">(</span> <span class="n">head</span> <span class="p">)</span>
        <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 終了条件</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">tuple</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">,</span> <span class="mf">7.8f</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>クラステンプレートtupleは、別の実体化から再帰的に派生する。実体化されたtupleは、それぞれ先頭のテンプレート実引数の型をデータメンバーとして持つ。コンストラクターは先頭の型の値と、仮引数パックからなる実引数を取り、先頭の値をデータメンバーに格納して、残りを基本クラスに投げる。これが再帰的に行われるため、すべての実引数を格納することができる。</p>
<p>ただし、tupleから値を取り出すのは、少し面倒だ。なぜならば、対応するクラスの型にキャストしなければならないからだ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">tuple</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&gt;</span> <span class="n">t</span><span class="p">(</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mf">5.6</span><span class="p">,</span> <span class="mf">7.8f</span> <span class="p">)</span> <span class="p">;</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">float</span><span class="o">&gt;</span> <span class="o">&amp;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">data</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これも可変引数テンプレートを使って解決できる。何番目の値が欲しいか実引数として与えれば、その値を返してくれる関数テンプレートを書けばいい。インデックスは0から始まるとする。この関数テンプレートは、以下のような形になる。</p>
<div class="highlight-c++"><pre>template &lt; std::size_t I,  typename ... Types &gt;
戻り値の型 get( tuple&lt; Types ... &gt; &amp; t )
{
    return static_cast&lt; 対応する値が格納されているクラス型 &gt;(t).data ;
}

int main( )
{
    tuple&lt; int, short, double, float &gt; t( 12, 34, 5.6, 7.8f ) ;
    auto value = get&lt;2&gt;( t ) ; // 5.6
}</pre>
</div>
<p>さて、戻り値の型はどうやって指定すればいいのか。それには、インデックスを指定すれば、その型を返してくれるメタ関数を書けばよい。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span>  <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple_element</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple_element</span><span class="o">&lt;</span> <span class="n">I</span><span class="p">,</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Types</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="o">:</span> <span class="n">tuple_element</span><span class="o">&lt;</span> <span class="n">I</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tuple</span> <span class="o">&lt;</span> <span class="n">Types</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">static_assert</span><span class="p">(</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">...(</span> <span class="n">Types</span> <span class="p">),</span> <span class="s">&quot;index exceeds the tuple length.&quot;</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple_element</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Types</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">Head</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&gt;</span> <span class="p">;</span>
    <span class="n">tuple_element</span><span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">type</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="n">d</span> <span class="p">;</span> <span class="c1">// double</span>
<span class="p">}</span>
</pre></div>
</div>
<p>tuple_elementは、0から始まるインデックスを数値として指定すると、対応する型を、ネストされた型名typeとして返すメタ関数だ。</p>
<p>次に、キャストすべき型を返してくれるメタ関数をつくる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple_get_type</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">I</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Tail</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple_get_type</span><span class="o">&lt;</span> <span class="n">I</span><span class="p">,</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
    <span class="o">:</span> <span class="n">tuple_get_type</span><span class="o">&lt;</span> <span class="n">I</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Head</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Tail</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">tuple_get_type</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Head</span><span class="p">,</span> <span class="n">Tail</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// typeはtuple&lt; double, float &gt;</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">tuple_get_type</span><span class="o">&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">float</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この二つのメタ関数を合わせると、関数テンプレートgetは、以下のように書ける。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">I</span><span class="p">,</span>  <span class="k">typename</span> <span class="p">...</span> <span class="n">Types</span> <span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">tuple_element</span><span class="o">&lt;</span> <span class="n">I</span><span class="p">,</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Types</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="o">&amp;</span>
<span class="n">get</span><span class="p">(</span> <span class="n">tuple</span><span class="o">&lt;</span> <span class="n">Types</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="o">&amp;</span> <span class="n">t</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="n">tuple_get_type</span><span class="o">&lt;</span><span class="n">I</span><span class="p">,</span> <span class="n">Types</span> <span class="p">...</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="o">&amp;</span> <span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">).</span><span class="n">data</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>まだまだ、面白い技法はたくさんあるのだが、本書はテンプレートメタプログラミングの解説書ではないので、ここで筆を止める。さらに深く調べたい者は、標準ライブラリのtupleやfunctionやbindから始めるといいだろう。もし十分な需要があれば、C++11によるテンプレートメタプログラミングの本も執筆するかもしれない。</p>
</div>
</div>
<div class="section" id="friend">
<h3>friend<a class="headerlink" href="#friend" title="Permalink to this headline">¶</a></h3>
<p>friend宣言はテンプレートとして宣言できる。また、friend宣言はテンプレートの特殊化を指定できる。</p>
<p>非テンプレートなfriend宣言で、クラステンプレートや指定するには、特殊化を指し示していなければならない。関数テンプレートは、特殊化か、あるいは実引数推定されるものを指し示さなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Y</span>
<span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">X</span> <span class="p">;</span> <span class="c1">// エラー</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>

    <span class="k">friend</span> <span class="k">class</span> <span class="nc">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>

<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>friendで指定されたテンプレートの特殊化のみのがクラス、あるいはクラステンプレートのfriendとなる。その他の特殊化はfriendとはならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>

    <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Y</span> <span class="n">y</span> <span class="p">;</span>
    <span class="n">y</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、f&lt;int&gt;はXのfriend</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー、f&lt;double&gt;はXのfriendではない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>friendテンプレートは、クラステンプレートと関数テンプレートの全ての実体化に対して働く。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>

    <span class="c1">// 関数テンプレートfに対するfriendテンプレート</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
    <span class="c1">// クラステンプレートYに対するfriendテンプレート</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Y</span> <span class="p">;</span>

<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X</span> <span class="n">x</span> <span class="p">;</span>
    <span class="n">x</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>クラステンプレートのすべての特殊化のメンバー関数をfriendにする場合は、friendテンプレートを使う。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">class</span> <span class="nc">Y</span>
<span class="p">{</span>
<span class="k">private</span> <span class="o">:</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>
    <span class="c1">// クラステンプレートXのすべての特殊化のメンバー関数fに対するfriendテンプレート</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Y</span> <span class="n">y</span> <span class="p">;</span>
    <span class="n">y</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">X</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>friendテンプレートは、ローカルクラスでは宣言できない。</p>
<p>friendテンプレートは、部分的特殊化できない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">struct</span> <span class="n">Y</span>
<span class="p">{</span>
    <span class="c1">// エラー、部分的特殊化はできない</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="class-template-partial-specializations">
<h3>クラステンプレートの部分的特殊化(Class template partial specializations)<a class="headerlink" href="#class-template-partial-specializations" title="Permalink to this headline">¶</a></h3>
<p>クラステンプレートの部分的特殊化(Class template partial specializations)は、特殊化(specialization)という名前がついているが、テンプレートの実体化の結果生成される特殊化や、明示的特殊化とは異なる。これは部分的な特殊化であって、テンプレートである。</p>
<p>テンプレート宣言の際のテンプレート名が、識別子だけの基本となるクラステンプレートを、プライマリークラステンプレート(Primary class template)と呼ぶ。俗に、プライマリーテンプレートとも呼ばれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// プライマリークラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Identifier</span> <span class="p">;</span>
</pre></div>
</div>
<p>クラステンプレートの部分的特殊化は、この基準となるプライマリークラステンプレートの一部を特殊化するものである。その宣言方法は、先に宣言したテンプレートと同名で、テンプレート実引数を加えた形のテンプレートIDで宣言する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// プライマリークラステンプレートX</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// Xの部分的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>プライマリークラステンプレートは、部分的特殊化よりも先に宣言されていなければならない。</p>
<p>部分的特殊化は、直接参照することはできない。部分的特殊化のあるテンプレートを使う際に、最もテンプレート実引数に対して特殊化されたテンプレートが選ばれて実体化される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// #1</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// #2</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="c1">// #3</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&amp;</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span> <span class="c1">// #1</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span> <span class="c1">// #2</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="o">&gt;</span> <span class="n">x3</span> <span class="p">;</span> <span class="c1">// #3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、テンプレート実引数int <a href="#id9"><span class="problematic" id="id10">*</span></a>は、T <a href="#id11"><span class="problematic" id="id12">*</span></a>が最も特殊化されているので、#2が選ばれる。</p>
<p>部分的特殊化は、名前通り部分的に特殊化していればいい。一部に具体的な型や値やテンプレートを与えることもできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// #1</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// #2</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// #3</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span> <span class="c1">// #2</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span> <span class="c1">// #3</span>

    <span class="c1">// エラー、曖昧</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">double</span><span class="p">,</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="n">x3</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>プライマリークラステンプレートを使うつもりがないのであれば、プライマリークラステンプレートは宣言するだけで、定義しなくてもよい。以下の例は、テンプレート実引数としてポインター型だけを受け取るテンプレートである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// プライマリークラステンプレートの宣言</span>
<span class="c1">// 定義はしない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">RequirePointerType</span> <span class="p">;</span>

<span class="c1">// 部分的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">RequirePointerType</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">RequirePointerType</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">RequirePointerType</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span> <span class="c1">// エラー、定義がない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このテンプレートに、ポインター以外の型をテンプレート実引数として渡しても、定義がないために、エラーとなる。</p>
<p>部分的特殊化のテンプレート仮引数の数は、プライマリークラステンプレートには左右されない。ただ、部分的特殊化として、テンプレートIDに指定する仮引数の数が一致していればよい。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// #1</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// #2</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Temp</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">Temp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、X&amp;lt;int&amp;gt;には#1のテンプレートが使われ、X&amp;lt; X&amp;lt;int&amp;gt; &amp;gt;には、#2のテンプレートが使われる。</p>
<p>テンプレートIDに与えるテンプレート実引数の数が、プライマリークラステンプレートに一致していなければ、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// #1</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>また、プライマリークラステンプレートのテンプレート仮引数の種類、すなわち、型テンプレート、非型テンプレート、テンプレートテンプレートに一致していなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 型、非型(int型)、テンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">I</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Temp</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>  <span class="p">;</span>

<span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Temp</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Temp</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、テンプレート仮引数の種類が一致していない。</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>テンプレートテンプレート仮引数の場合は、テンプレートテンプレート仮引数のテンプレート仮引数の数や種類にも対応していなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// プライマリークラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Temp</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、テンプレートテンプレート仮引数のテンプレート仮引数の数が一致していない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span><span class="p">,</span> <span class="k">typename</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Temp</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">Temp</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="c1">// エラー、テンプレートテンプレート仮引数のテンプレート仮引数の種類が一致していない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="k">class</span> <span class="nc">Temp</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">Temp</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>可変引数テンプレートの場合は、0個以上の任意の数に特殊化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// プライマリークラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Rest</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">Rest</span> <span class="p">...</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>部分的特殊化は、プライマリークラステンプレートが宣言された名前空間スコープやクラススコープの外側で宣言できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">NS</span>
<span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Inner</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="p">}</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">NS</span><span class="o">::</span><span class="n">Outer</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">&gt;::</span><span class="n">Inner</span><span class="o">&lt;</span> <span class="n">U</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>部分的特殊化の宣言中のテンプレートIDの実引数には、いくつかの制限が存在する。</p>
<p>非型実引数の式は、部分的特殊化のテンプレート仮引数の識別子のみである時以外は、テンプレート仮引数とか関わってはならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span><span class="p">,</span> <span class="kt">int</span> <span class="n">J</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span>

<span class="c1">// OK、識別子のみ</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">I</span><span class="p">,</span> <span class="n">I</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="c1">// エラー、部分的特殊化のテンプレート仮引数が関わる式</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">I</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="o">+</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>非型実引数の型は、部分的特殊化のテンプレート仮引数に依存してはならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="mi">0</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span><span class="p">,</span> <span class="kt">int</span> <span class="p">(</span> <span class="o">*</span> <span class="n">Array_ptr</span><span class="p">)[</span><span class="n">I</span><span class="p">]</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span> <span class="p">;</span>

<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span><span class="o">&lt;</span> <span class="n">I</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">array</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>部分的特殊化の実引数リストは、プライマリークラステンプレートに暗黙的に生成される実引数リストと同一であってはならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>部分的特殊化のテンプレート仮引数には、デフォルトテンプレート実引数は使えない。</p>
<p>部分的特殊化のテンプレート実引数には展開されていない仮引数パックがあってはならない。テンプレート実引数がパック展開ならば、最後に記述されなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span>

<span class="c1">// エラー、展開されていない仮引数パック</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">Pack</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="c1">// エラー、仮引数パックは最後に記述されなければならない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Pack</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">Pack</span> <span class="p">...,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">wrap</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// OK</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="p">...</span> <span class="n">Pack</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">wrap</span><span class="o">&lt;</span><span class="n">Pack</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<div class="section" id="matching-of-class-template-partial-specializations">
<h4>クラステンプレートの部分的特殊化の一致度の比較(Matching of class template partial specializations)<a class="headerlink" href="#matching-of-class-template-partial-specializations" title="Permalink to this headline">¶</a></h4>
<p>クラステンプレートの部分的特殊化は、直接参照することはできない。クラステンプレートを使った時、プライマリークラステンプレートや部分的特殊化が比較され、最もテンプレート実引数に対して特殊化されたテンプレートが選ばれる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #1</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #2</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="k">const</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #3</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span> <span class="c1">// #1</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span> <span class="c1">// #2</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">x3</span> <span class="p">;</span> <span class="c1">// #3</span>
<span class="p">}</span>
</pre></div>
</div>
<p>最適なテンプレートは、テンプレート実引数が、部分的特殊化のテンプレート実引数に、いかに一致しているかを比較することにより選択される。</p>
<p>この比較は以下のように行われる。</p>
<ul class="simple">
<li></li>
</ul>
<p>一致する部分的特殊化が、ただひとつだけ発見された場合、その部分的特殊化が選ばれる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// プライマリークラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 部分的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T1</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// 部分的特殊化が実体化される</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>これは極端な例だが、この例では、部分的特殊化はプライマリーテンプレートと同一ではない。X&amp;lt; int, int &amp;gt;には、プライマリークラステンプレートと部分的特殊化の両方が一致するが、ただひとつの部分的特殊化が一致するために、部分的特殊化が選ばれる。</p>
<p>一致する部分的特殊化が一つでもある場合、プライマリークラステンプレートが使われることはない。</p>
<ul class="simple">
<li></li>
</ul>
<p>二つ以上の一致する部分的特殊化が発見された場合、&lt;a href=&#8221;#temp.class.order&#8221;&gt;半順序&lt;/a&gt;の規則により、最も特殊化されている部分的特殊化が選ばれる。もし、他のすべての部分的特殊化よりもさらに特殊化されている部分的特殊化が見つからない場合、結果は曖昧となり、エラーとなる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #1</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="k">const</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #2</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="k">const</span> <span class="k">volatile</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #3</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span> <span class="c1">// #2</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="k">const</span> <span class="k">volatile</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span> <span class="c1">// #3</span>

    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x3</span> <span class="p">;</span> <span class="c1">// #1</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>以下のような場合は、曖昧でエラーとなる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// エラー、曖昧</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>この例では、プライマリークラステンプレートと、二つの部分的特殊化の、どのテンプレートを使っても実体化できる。ただし、二つ以上の一致する部分的特殊化があるために、プライマリークラステンプレートは使われない。二つの部分的特殊化は、どちらがより特殊化されているとも決定できないので、曖昧となる。</p>
<ul class="simple">
<li></li>
</ul>
<p>一致する部分的特殊化が発見されなかった場合、プライマリークラステンプレートが使われる。</p>
<p>部分的特殊化が一致するかどうかは、テンプレート実引数から、部分的特殊化のテンプレート実引数を導けるかどうかで判断される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #1</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// #2</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T1</span> <span class="o">*</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&gt;</span> <span class="p">{}</span> <span class="p">;</span> <span class="c1">// #3</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span> <span class="c1">// #1, #2に一致</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">short</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span> <span class="c1">// #2に一致</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">x3</span> <span class="p">;</span> <span class="c1">// #1, #3に一致</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">x4</span> <span class="p">;</span> <span class="c1">// #1, #3に一致</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x5</span> <span class="p">;</span> <span class="c1">// #3に一致</span>

    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">short</span> <span class="o">&gt;</span> <span class="n">x6</span> <span class="p">;</span> <span class="c1">// 一致する部分的特殊化なし</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="partial-ordering-of-class-template-specializations">
<h4>クラステンプレートの部分的特殊化の半順序(Partial ordering of class template specializations)<a class="headerlink" href="#partial-ordering-of-class-template-specializations" title="Permalink to this headline">¶</a></h4>
<p>二つのクラステンプレートの部分的特殊化の間で、どちらがより特殊化されているかということを、半順序(partial ordering)という。クラステンプレートの部分的特殊化の半順序は、比較のために部分的特殊化を関数テンプレートに書き換えた上で、関数テンプレートの半順序に従って決定される。</p>
<p>&lt;p class=&#8221;todo&#8221;&gt;
関数テンプレートの半順序へのリンク</p>
<p>部分的特殊化の比較のための関数テンプレートへの書き換えは、以下のように行われる。</p>
<p>書き換えた関数テンプレートは、元の部分的特殊化と同じテンプレート仮引数を持つ。この関数テンプレートはひとつの仮引数をとる。仮引数の型は、元の部分的特殊化のクラステンプレート名に、テンプレート実引数として、部分的特殊化と同じ記述をしたものである。</p>
<p>たとえば、以下のような部分的特殊化の場合は、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>比較用の関数テンプレートへの書き換えは、以下のようになる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>以下の二つの部分的特殊化を比較する場合、</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// #1</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// #2</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>以下のように、関数テンプレートに書き換えられて、関数テンプレートの半順序により判断される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// #1</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// #2</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>この例では、#2の方がより特殊化されている。</p>
</div>
<div class="section" id="id13">
<h4>クラステンプレートの特殊化のメンバー<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h4>
<p>プライマリークラステンプレートと部分的特殊化の間は別物である。それぞれ異なるメンバーの宣言と定義を持つ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="p">;</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
    <span class="n">x1</span><span class="p">.</span><span class="n">bar</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー</span>

    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="n">x2</span> <span class="p">;</span>
    <span class="n">x2</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー</span>
    <span class="n">x2</span><span class="p">.</span><span class="n">bar</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>部分的特殊化のメンバーをクラススコープの外で定義する場合、部分的特殊化と同じテンプレート仮引数とテンプレート実引数を使わなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// メンバーの宣言</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// メンバーの定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">T</span> <span class="o">*</span> <span class="o">&gt;::</span><span class="n">bar</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>メンバーテンプレートも部分的特殊化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">class_template</span>
<span class="p">{</span>
    <span class="c1">// プライマリーメンバークラステンプレート</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">member_template</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

    <span class="c1">// 部分的特殊化</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">member_template</span><span class="o">&lt;</span> <span class="n">U</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="function-templates">
<h3>関数テンプレート(Function templates)<a class="headerlink" href="#function-templates" title="Permalink to this headline">¶</a></h3>
<p>関数テンプレートは、特定の型にとらわれない関数のテンプレートを記述できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="n">param</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>関数テンプレートは、クラステンプレートと同じように、テンプレート実引数を指定して実体化させ、呼び出すことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="n">param</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span>
    <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>関数テンプレートは、テンプレート実引数を指定せずに呼び出すことができる。この場合、関数の実引数から、テンプレート実引数が導かれる。これを、実引数推定(Argument Deduction)という。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="n">param</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// f&lt;int&gt;</span>
    <span class="n">f</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// f&lt;double&gt;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>実引数推定できない場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="o">*</span> <span class="n">param</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、実引数推定できない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>より詳しくは、&lt;a href=&#8221;#temp.deduct&#8221;&gt;テンプレートの実引数推定&lt;/a&gt;を参照。</p>
</div>
<div class="section" id="function-template-overloading">
<h3>関数テンプレートのオーバーロード(Function Template Overloading)<a class="headerlink" href="#function-template-overloading" title="Permalink to this headline">¶</a></h3>
<p>関数テンプレートはオーバーロードできる。オーバーロードは、関数テンプレートと通常の関数の区別なく記述できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="o">*</span> <span class="p">)</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>異なる複数の関数テンプレートが同じテンプレート実引数に対して実体化できる場合、それぞれ異なる実態を持つので、ODR違反とはならない。</p>
<p>たとえば、ある一つのプログラムを構成する二つのソースファイルがあり、それぞれ以下のように記述されていたとする。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ソースファイル1</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ソースファイル2</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="o">*</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">void</span> <span class="n">h</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この場合、それぞれのテンプレートから、それぞれ実体化が行われ、異なる特殊化が使われる。ODR違反とはならない。</p>
<p>関数テンプレートのオーバーロードは、実体化された特殊化が、全く同じシグネチャであっても構わない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>テンプレート仮引数が、関数テンプレートの仮引数リストや戻り値の型における式の中で参照された場合、その式は関数テンプレートのシグネチャの一部になる。これにより、式の違いによる異なる関数テンプレートを記述できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span><span class="p">,</span> <span class="kt">int</span> <span class="n">J</span> <span class="o">&gt;</span>
<span class="n">X</span><span class="o">&lt;</span> <span class="n">I</span> <span class="o">+</span> <span class="n">J</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">J</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// #1の宣言</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int</span> <span class="n">L</span> <span class="o">&gt;</span>
<span class="n">X</span><span class="o">&lt;</span> <span class="n">K</span> <span class="o">+</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">L</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// #1の再宣言</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span><span class="p">,</span> <span class="kt">int</span> <span class="n">J</span> <span class="o">&gt;</span>
<span class="n">X</span><span class="o">&lt;</span> <span class="n">I</span> <span class="o">-</span> <span class="n">J</span> <span class="o">&gt;</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">I</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">J</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// #2、これは#1とは異なる宣言</span>
</pre></div>
</div>
<p>最初の二つの関数テンプレートは、同一の関数テンプレートである。しかし、#2は式が違うため、異なる関数テンプレートである。</p>
<p>この時、シグネチャの式を評価した結果が同じものを、「機能的に同一」という。シグネチャの式が同じものを「同一」という。機能的に同一だが、同一ではない二つの宣言がある場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">I</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="kt">int</span> <span class="n">I</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span> <span class="n">I</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、機能的に同一だが、シグネチャの式が同一ではない</span>
</pre></div>
</div>
<p>ただし、規格上、実装はこの誤りを検出して報告する必要はない。したがって、このエラーはコンパイルで見つけることは期待できない。よく注意しなければならない。</p>
</div>
<div class="section" id="partial-ordering-of-function-templates">
<h3>関数テンプレートの部分的特殊化(Partial ordering of function templates)<a class="headerlink" href="#partial-ordering-of-function-templates" title="Permalink to this headline">¶</a></h3>
<p>関数テンプレートがオーバーロードされている場合、どの関数テンプレートの特殊化を使うべきなのか曖昧になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// #1</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="o">*</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// #2</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">nullptr</span> <span class="p">;</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">p</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// #2の特殊化が呼ばれる</span>

    <span class="kt">void</span> <span class="p">(</span> <span class="o">*</span><span class="n">fp</span> <span class="p">)</span> <span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span> <span class="p">;</span> <span class="c1">// #2の特殊化のアドレスを得る</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以下の文脈の場合、半順序(partial ordering)によって、最も特殊化されているテンプレートを決定する。</p>
<ul class="simple">
<li>関数テンプレートの特殊化を呼び出す際のオーバーロード解決</li>
<li>関数テンプレートの特殊化のアドレスを取得するとき</li>
<li>プレイスメントoperator newに一致するプレイスメントoperator deleteを選択するとき</li>
<li></li>
</ul>
<p>friend関数宣言、明示的実体化、明示的特殊化が、ある関数テンプレートの特殊化を参照しているとき</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// #1</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="o">*</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// #2</span>

<span class="k">class</span> <span class="nc">X</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">friend</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// #1をfriendに指定</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// #2の明示的実体化</span>
<span class="k">template</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="o">*</span> <span class="p">)</span> <span class="p">;</span>


<span class="c1">// #1の明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>半順序は、二つのテンプレートを、後述する方法によって変換して関数型とし、テンプレート実引数推定をして、どちらがより特殊であるかを選ぶ。</p>
<p>&lt;p class=&#8221;todo&#8221;&gt;
完全に理解してから書く。</p>
</div>
<div class="section" id="alias-templates">
<h3>エイリアステンプレート(Alias templates)<a class="headerlink" href="#alias-templates" title="Permalink to this headline">¶</a></h3>
<p>宣言部分がエイリアス宣言のテンプレート宣言を、エイリアステンプレートと呼ぶ。エイリアステンプレートは、複数の型名をテンプレート化することができる。いわば、typedefのテンプレート版とも言える。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">wrap</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">Alias</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">;</span>

<span class="n">Alias</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t1</span> <span class="p">;</span> <span class="c1">// wrap&lt;int&gt;</span>
<span class="n">Alias</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">t2</span> <span class="p">;</span> <span class="c1">// wrap&lt;double&gt;</span>
</pre></div>
</div>
<p>エイリアステンプレートによって宣言されたテンプレートIDは、エイリアスされた型の別名として使うことができる。エイリアステンプレートのテンプレートIDは、typedef名と同じく、型の別名であり、別の型ではない。Alias&amp;lt;int&amp;gt;は、wrap&amp;lt;int&amp;gt;と同一の型である。</p>
<p>エイリアステンプレートの利用例を挙げる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">wrap</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="n">type</span> <span class="o">=</span> <span class="n">T</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="p">;</span>
<span class="k">using</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">a1</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// wrap&lt; int, int &gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">wrap</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="p">;</span>
<span class="k">using</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">a2</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// wrap&lt; int, int &gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">a3</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">wrap</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="kt">void</span> <span class="o">&gt;::</span><span class="n">type</span> <span class="p">;</span>
<span class="k">using</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">a3</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">;</span> <span class="c1">// wrap&lt; int, void&gt;::type、すなわちint</span>
</pre></div>
</div>
<p>エイリアステンプレートは、その利用方法はさておき、以下のような記述もできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">T</span> <span class="p">;</span> <span class="c1">// a1&lt;T&gt;はTの別名</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">a2</span> <span class="o">=</span> <span class="kt">int</span> <span class="p">;</span> <span class="c1">// a2&lt;T&gt;はintの別名</span>
</pre></div>
</div>
<p>エイリアステンプレートは、テンプレート実引数の一部のみ指定し、残りをテンプレート化することができる。その利用方法は、例えば、カスタムアロケーターを指定したコンテナーテンプレートの別名を宣言できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MyAlloc</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">using</span> <span class="n">MyVec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span> <span class="n">T</span><span class="p">,</span> <span class="n">MyAlloc</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>従来のtypedef宣言では、これができない。</p>
<p>エイリアステンプレートは、名前通りテンプレートであるので、名前空間スコープかクラススコープの内側でしか宣言できない。たとえば、関数のブロックスコープの内側では宣言できない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span><span class="c1">// 関数のブロックスコープ</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">using</span> <span class="n">A</span> <span class="o">=</span> <span class="n">T</span> <span class="o">:</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>エイリアステンプレート宣言内のテンプレートIDは、宣言中のエイリアステンプレートを参照してはならない。つまり、宣言中に自分自身の特殊化を使ってはならないという事である。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">A</span> <span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">using</span> <span class="n">B</span> <span class="o">=</span> <span class="k">typename</span> <span class="n">A</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">U</span><span class="p">;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">A</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">B</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">U</span><span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、B&lt;int&gt;の実体化の際に、A&lt;int&gt;::Uとして、自分自身を使ってしまう。</span>
<span class="n">B</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="name-resolution">
<h2>名前解決(Name Resolution)<a class="headerlink" href="#name-resolution" title="Permalink to this headline">¶</a></h2>
<p>テンプレート定義内での名前解決は非常に複雑である。これは、テンプレートはある場所で宣言され、別の場所で特殊な形に実体化されるからである。</p>
<p>テンプレート定義内では、三種類の名前がある。</p>
<ul class="simple">
<li>テンプレート自身の名前、テンプレートで宣言された名前</li>
<li>テンプレート仮引数に依存する名前</li>
<li>テンプレート定義のあるスコープから見える名前</li>
</ul>
<p>「テンプレート自身の名前、テンプレートで宣言された名前」というのは、テンプレート名と、テンプレート仮引数名である。</p>
<p>「テンプレート仮引数に依存する名前」は、依存名(Dependent Name)と呼ばれている。</p>
<p>「テンプレート定義のあるスコープから見える名前」とは、テンプレート定義のあるスコープやその外側のスコープで、すでに宣言された名前のことだ。</p>
<p>テンプレート仮引数に依存する名前は、暗黙に型を意味しないものと解釈される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">T</span><span class="o">::</span><span class="n">value</span> <span class="p">;</span> <span class="c1">// T::valueは型ではない</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この場合、Tに与えられるテンプレート実引数には、例えば以下のようなものが想定されている。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">constexpr</span> <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>テンプレート宣言や定義で、テンプレート仮引数に依存する名前を型として使おうとしてもエラーとなる。なぜならば、すでに述べたように、暗黙に型を意味しないものと解釈されるからだ。</p>
<p>template &amp;lt; typename T &amp;gt;
void f()
{</p>
<blockquote>
<div>typedef T::type type ; // エラー、T::typeは型ではない</div></blockquote>
<p>}</p>
<p>依存名を型であると解釈させるには、明示的に、名前の直前に、typenameキーワードを記述して修飾しなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span> <span class="n">type</span> <span class="p">;</span> <span class="c1">// OK、T::typeは型</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、メンバー初期化子と基本クラス指定子には、文法上型しか記述できないので、typenameで修飾する必要はない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span> <span class="c1">// OK</span>
<span class="p">{</span>
    <span class="n">X</span><span class="p">()</span> <span class="o">:</span> <span class="n">T</span><span class="o">::</span><span class="n">type</span> <span class="c1">// OK</span>
    <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>また、メンバーテンプレートは、文脈により、テンプレートかどうかが曖昧になる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Tに渡す型の例</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">t</span> <span class="p">;</span>
    <span class="n">t</span><span class="p">.</span><span class="n">func</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このコードの意味は、t.funcとintに、比較演算子である&amp;lt;を適用し、さらに比較演算子&amp;gt;とかっこに囲まれた0を適用するものである。メンバー関数テンプレートの特殊化を呼び出すものではない。
t.funcとintを&amp;lt;演算子で比較するのは、文法上認められていないので、このコードはエラーになる。</p>
<p>依存名に.や-&amp;gt;、あるいは::を用い、メンバーテンプレートの特殊化を記述する場合は、メンバーテンプレートは、templateキーワードで修飾しなければならない。これは、メンバー名がテンプレートであると明示的に解釈させるためである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Tに渡す型の例</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">MemberClass</span> <span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">MemberFunction</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="k">typename</span> <span class="n">T</span><span class="o">::</span> <span class="k">template</span> <span class="n">MemberClass</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">obj</span> <span class="p">;</span>

    <span class="n">T</span> <span class="n">t</span> <span class="p">;</span>
    <span class="n">t</span><span class="p">.</span> <span class="k">template</span> <span class="n">MemberFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span>

    <span class="n">T</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">t</span> <span class="p">;</span>
    <span class="n">p</span><span class="o">-&gt;</span> <span class="k">template</span> <span class="n">MemberFunction</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これはメンバーテンプレートの特殊化を使う場合であって、メンバー関数テンプレートを実引数推定させて使う場合には、templateキーワードを記述する必要はない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Tに渡す型の例</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">MemberFunction</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">t</span> <span class="p">;</span>
    <span class="n">t</span><span class="p">.</span><span class="n">MemberFunction</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK</span>
<span class="p">}</span>
</pre></div>
</div>
<p>templateキーワードの指定は、実際には文法の曖昧性の問題であって、名前解決の問題ではないのだが、typenameキーワードの指定と似ているために、便宜上、本書では同時に説明することにした</p>
<div class="section" id="dependent">
<h3>依存(Dependent)<a class="headerlink" href="#dependent" title="Permalink to this headline">¶</a></h3>
<p>依存(Dependent)とは、テンプレート仮引数に依存することである。テンプレート仮引数に依存するものは、名前と式とテンプレート実引数である。式とテンプレート実引数には、型依存式と値依存式が存在する。</p>
<p>なぜテンプレート仮引数に依存しているかどうかが問題になるのか。テンプレート仮引数というのは、具体的な内容が確定していない存在だからだ。テンプレートは、実体化されて初めて、その具体的な内容が確定する。</p>
<p>依存の詳細は煩雑になるので省略するが、簡略化していえば、テンプレート仮引数が関わる名前や式は、すべて依存している。</p>
<div class="highlight-c++"><pre>void f( int ) ;

template &lt; typename T &gt;
struct identity
{
    using type = T ;
} ;

template &lt; typename T &gt;
struct X
{
    int data ;

    void member()
    {
        T t1 ; // Tは依存名
        T::value ; // 依存している。値と解釈される
        typename T::type t2 ; // 依存している。型と解釈される

        f( 0 ) ; // 依存していない

        &amp;X::data ; // 依存している
        this-&gt;data ; / 依存している

        typename identity&lt;T&gt;::type t ; // 依存している
    }
} ;</pre>
</div>
<p>クラステンプレートの場合、クラス名やthisを介した式も、テンプレート仮引数に依存している。なぜならば、クラステンプレートの場合、クラス名自体がテンプレート仮引数に依存しているからだ。</p>
<p>依存していない名前や式を、非依存(Non-dependent)という。</p>
</div>
<div class="section" id="id14">
<h3>非依存名の名前解決<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h3>
<p>非依存名は、テンプレートが定義されている場所で名前解決される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// f(int)</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">g</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>このコードの解釈は驚くにあたらない。ただし、状況によっては、意図しないことが起こる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Derivedのテンプレート仮引数Baseが想定している型</span>
<span class="k">struct</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">member</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Base</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">member</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// エラー、memberが見つからない</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>この、テンプレートクラス、Derivedは、テンプレート仮引数を基本クラスに指定している。そして、基本クラスはmemberという名前のメンバー関数を持っていることを期待している。Derived::f内で使われている、memberという名前は、非依存名であり、しかも非修飾名なので、メンバー関数であるとは解釈されない。そのため、外側のスコープのmemberという名前を探すが、見つからないためエラーになる。</p>
<p>このようなコードで、memberをメンバーとして扱いたい場合、memberを修飾して依存名にする必要がある。それには、三種類の方法がある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">Base</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Derived</span> <span class="o">:</span> <span class="n">Base</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Derived</span><span class="o">::</span><span class="n">member</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、クラス名は依存名</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">member</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、thisは依存式</span>
        <span class="n">Base</span><span class="o">::</span><span class="n">member</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// OK、テンプレート仮引数は依存名</span>
    <span class="p">}</span>

<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h3>依存名の名前解決<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>依存名の名前解決は、実体化場所(Point of Instantiation)が重要になる。</p>
<p>実体化場所とは、テンプレートが実体化された場所のことである。</p>
<p>template &amp;lt; typename T &amp;gt;
void f( T ) { } // テンプレートの定義</p>
<p>struct Foo { } ;</p>
<p>int main()
{</p>
<blockquote>
<div>Foo foo ;
f( foo ) ; // 実体化場所</div></blockquote>
<p>}</p>
<p>依存名の名前解決は、テンプレートの定義ではなく、実体化場所で行われるので、テンプレートの定義の時点では見えていない、Fooという名前も使うことができる。また、テンプレートの定義中で、テンプレート仮引数のメンバー名やネストされた型名を参照しても、実体化の結果が一致しているならば、名前解決できる。</p>
<p>テンプレートの名前解決の理解を難しくしているのは、オーバーロード解決における、候補関数の見え方である。</p>
<p>非修飾名前解決と修飾名前解決を使った候補関数は、テンプレートの定義場所から見える名前のみに制限される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// テンプレートの定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">call</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// 候補関数はf(int)のみ</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">call</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 実体化場所</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、候補関数の非修飾名前解決と修飾名前解決は、実体化場所で行われるものの、発見される名前は、テンプレートの定義場所から見える名前のみに限定されているため、。上記の例では、もし、f(double)が候補関数に含まれていたならば、そちらが最適関数だが、候補関数として発見されないために、最適関数になることもない。</p>
<p>同様に、以下の例はエラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// テンプレートの定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">call</span><span class="p">(</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、名前fが見つからない</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">call</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 実体化場所</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ただし、ADLの場合は、例外的に異なる。ADLが発動した場合は、テンプレートの実体化場所から見える候補関数が発見される。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// グローバル名前空間</span>

<span class="c1">// クラスFooの関連名前空間はグローバル名前空間</span>
<span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// テンプレートの定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">call_f</span><span class="p">(</span> <span class="n">T</span> <span class="n">t</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="c1">// グローバル名前空間内の名前</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Foo</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span> <span class="p">;</span>
    <span class="n">call_f</span><span class="p">(</span> <span class="n">foo</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、ADLが発動</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この場合、関数call_f内で呼び出している非修飾名fは、非修飾名前解決では見つからないため、ADLが発動する。</p>
<p>これはADLが発動する場合のみの例外的なルールである。ADLが発動しない場合は、このような例外的な挙動にはならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Foo</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span> <span class="n">Foo</span> <span class="k">const</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// #1</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">call_f</span><span class="p">(</span> <span class="n">T</span> <span class="n">t</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="n">t</span> <span class="p">)</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">Foo</span> <span class="o">&amp;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// #2</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span> <span class="p">;</span>
    <span class="n">call_f</span><span class="p">(</span> <span class="n">foo</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// ADLは発動しない。#1が呼ばれる</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この場合では、非修飾名前解決により、#1が、名前fとして見つかるため、ADLは発動しない。ADLが発動しないので、#2が候補関数に選ばれることもない。もし、#2が候補関数に選ばれていたならば、オーバーロード解決により、#2は#1より最適な関数となるが、ADLが発動しない以上、#2は発見されず、したがって候補関数にもならない。</p>
<p>また、基本型には、関連名前空間が存在しないため、ADLは発動しない。</p>
<p>このように、テンプレート内の名前は、テンプレートの定義場所と、実体化場所で、二段階に分けて名前解決されるので、二段階名前解決(Two Phase Lookup)と呼ばれている。</p>
</div>
</div>
<div class="section" id="template-instantiation-and-specialization">
<h2>テンプレートの実体化と特殊化(Template instantiation and specialization)<a class="headerlink" href="#template-instantiation-and-specialization" title="Permalink to this headline">¶</a></h2>
<p>テンプレートは、テンプレート実引数を与えられて実体化して始めて利用可能になる。これをテンプレート実体化(template instantiation)という。実体化には、暗黙の実体化と明示的な実体化がある。実体化したテンプレートのことを、特殊化(specialization)という。特殊化は、明示的に行うこともできる。テンプレートの部分的特殊化は、名前が似ているが、いまだにテンプレートであって、実体化された特殊化ではない。</p>
<div class="section" id="implicit-instantiation">
<h3>暗黙の実体化(Implicit instantiation)<a class="headerlink" href="#implicit-instantiation" title="Permalink to this headline">¶</a></h3>
<p>明示的に実体化されず、明示的に特殊化されていないテンプレートは、オブジェクトの完全な型が必要な場合や、クラス型が完全であることがプログラムの意味に影響を与える文脈で参照された場合に、暗黙に実体化される。</p>
<p>クラステンプレートが暗黙に実体化されても、クラステンプレートのメンバーまで暗黙に実体化されるわけではない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
    <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">typedef</span> <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="n">type</span> <span class="p">;</span> <span class="c1">//  X&lt;int&gt;の実体化は必要ない</span>
    <span class="n">type</span> <span class="n">a</span> <span class="p">;</span> <span class="c1">// X&lt;int&gt;の実体化が必要</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">char</span> <span class="o">&gt;</span> <span class="o">*</span> <span class="n">b</span> <span class="p">;</span> <span class="c1">// X&lt;char&gt;の実体化は必要ない</span>
    <span class="n">X</span><span class="o">&lt;</span> <span class="kt">double</span> <span class="o">&gt;</span> <span class="o">*</span> <span class="n">p</span> <span class="p">;</span> <span class="c1">// X&lt;double&gt;の実体化は必要ない</span>

    <span class="n">a</span><span class="p">.</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// X&lt;int&gt;::f()の実体化が必要</span>
    <span class="n">b</span><span class="o">-&gt;</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// X&lt;char&gt;::f()の実体化が必要</span>
<span class="p">}</span>
</pre></div>
</div>
<p>typedef名やポインター型の宣言は、クラスの完全な型が必要な文脈ではないので、テンプレートの暗黙の実体化は起こらない。</p>
<p>X&amp;lt;char&amp;gt;や X&amp;lt;double&amp;gt;の実体化が必要ないのは、クラスへのポインターを参照しているだけなので、クラスの完全な型が必要な文脈ではないからである。また、X&amp;lt;int&amp;gt;::g()やX&amp;lt;double&amp;gt;::g()も、参照されていないので実体化はされない。</p>
<p>関数テンプレートも、定義が必要な文脈で参照されなければ、暗黙に実体化されることはない。</p>
<p>実体化の必要のないクラステンプレートのメンバーが暗黙的に実体化されないという挙動は、規格上保証されている。</p>
<p>テンプレートが暗黙に実体化される場合、暗黙的な実体化が必要ない場合、また例外的に暗黙的に実体化されるかどうかが未規定の場合の詳細な解説は、煩雑になるので省略する。</p>
</div>
<div class="section" id="explicit-instantiation">
<h3>明示的実体化(Explicit instantiation)<a class="headerlink" href="#explicit-instantiation" title="Permalink to this headline">¶</a></h3>
<p>クラス、関数、メンバーテンプレートの特殊化は、テンプレートから明示的に実体化できる。メンバー関数、メンバークラス、クラステンプレートのstaticデータメンバーは、クラステンプレートのメンバーの定義として、明示的に実体化できる。これを明示的実体化(Explicit instantiation)という。</p>
<p>明示的実体化を宣言する文法は、以下の通りである。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">exte</span>
</pre></div>
</div>
<p>externキーワードは省略できる。externキーワードの有無に意味上の違いはない。C++03までの規格では、externキーワードを使った文法は、明示的実体化の宣言ではなく、内部リンケージの宣言になり、プログラムの意味が変わってしまうので、注意が必要である。本書はC++11の規格のみを取り扱う。</p>
<p>クラス、もしくはメンバークラスに対する明示的実体化の場合、宣言中のクラス名はテンプレート実引数を指定した形で指定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// X&lt;int&gt;の明示的実体化</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>externキーワードは省略できるので、上記の明示的実体化は、以下のように書くこともできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>関数、もしくはメンバー関数に対する明示的実体化の場合、宣言中の関数名は、テンプレート実引数を指定しているか、引数リストからテンプレート実引数が推定できる形で指定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// f&lt;int&gt;の明示的実体化</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// g&lt;int&gt;の明示的実体化</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">g</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="c1">// 以下と同等</span>
<span class="c1">// extern template void g&lt; int &gt;( int ) ;</span>
</pre></div>
</div>
<p>クラスのメンバーに対する明示的実体化の場合は、メンバーの属するクラス名はテンプレート実引数を指定した形で指定する。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span>
</pre></div>
</div>
<p>同じテンプレートとテンプレート実引数に対する明示的実体化は、プログラム中に一度しか現れてはならない。つまり、複数のソースファイルからなるプログラム全体でも、一度しか現れてはならない。規格上、実装はこの違反を検出できるよう規定されてはいないので、実装の出力するコンパイル時、実行時のエラーや警告のメッセージに頼ることは出来ない。</p>
<p>関数テンプレート、メンバー関数、クラステンプレートのstaticデータメンバーは、明示的実体化の前に宣言されていなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー、前方に宣言がない</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
</pre></div>
</div>
<p>クラステンプレート、クラステンプレートのメンバークラス、メンバークラステンプレートは、明示的実体化の前に定義されていなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">;</span> <span class="c1">// 宣言</span>

<span class="c1">// エラー、クラステンプレートXは前方で定義されていない</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span> <span class="c1">// 定義</span>
</pre></div>
</div>
<p>明示的実体化で、暗黙に宣言された特別なメンバー関数を指定した場合、エラーとなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー、暗黙に宣言されたコンストラクター</span>
<span class="k">extern</span> <span class="k">template</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">X</span><span class="p">()</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span>
<span class="p">{</span>
    <span class="n">Y</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 明示的な宣言</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// OK</span>
<span class="k">extern</span> <span class="k">template</span> <span class="n">Y</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Y</span><span class="p">()</span> <span class="p">;</span>
</pre></div>
</div>
<p>同じテンプレート実引数の明示的特殊化の宣言の後に明示的実体化の宣言が現れた場合、明示的実体化は無効となる。これはエラーではない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// X&lt;int&gt;に対する明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// X&lt;int&gt;に対する明示的実体化。</span>
<span class="c1">// 無効、エラーではない</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">;</span>
</pre></div>
</div>
<p>同じテンプレート実引数に対する明示的特殊化の前に明示的実体化が現れた場合はエラーである。</p>
<p>明示的実体化を使えば、プログラム中のテンプレートを必要とするソースファイルすべてにトークン列が一致するテンプレートの完全な定義を持ち込む必要がなくなる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// func.h</span>
<span class="c1">// 関数テンプレートfuncの宣言</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// func.cpp</span>
<span class="c1">// 関数テンプレートfuncの定義</span>
<span class="cp">#include &lt;func.h&gt;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// プログラム中で使われる実体化を明示的に宣言</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="n">func</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>
<span class="k">extern</span> <span class="k">template</span> <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span> <span class="kt">double</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// main.cpp</span>

<span class="c1">// このソースファイルmain.cppには、</span>
<span class="c1">// 関数テンプレートfuncの宣言のみ導入</span>
<span class="cp">#include &lt;func.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">func</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、プログラム中で明示的実体化されている</span>
    <span class="n">func</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// OK、プログラム中で明示的実体化されている</span>

    <span class="n">func</span> <span class="p">(</span> <span class="sc">&#39;a&#39;</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// エラー、定義がないため、実体化できない。</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C++におけるテンプレートは、トークン列が一致するコード片を、テンプレートの特殊化を必要とするプログラム中のソースファイルすべてに持ち込むことで、ODRを例外的に回避している。明示的実体化を使えば、テンプレートの宣言と定義を分離し、すべてのソースファイルに定義を持ち込む必要がなくなる。ただし、明示的に実体化したテンプレートとそのテンプレート実引数に限定される。</p>
</div>
<div class="section" id="explicit-specialization">
<h3>明示的特殊化(Explicit specialization)<a class="headerlink" href="#explicit-specialization" title="Permalink to this headline">¶</a></h3>
<p>テンプレートはあるテンプレート実引数について、元となるテンプレートとは別に、明示的に特殊化することができる。これを明示的特殊化(Explicit specialization)という。明示的特殊化を使うと、ある与えられたテンプレート実引数に対しては、汎用のテンプレートから実体化される特殊化は異なる特殊化を与えることができる。明示的特殊化と、部分的特殊化は、名前は似ているは全くの別物である。</p>
<p>明示的特殊化の文法は以下の通り。</p>
<div class="highlight-c++"><pre>template &lt; &gt; 宣言</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span> <span class="p">;</span> <span class="p">}</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span> <span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// true</span>
    <span class="n">f</span><span class="p">(</span> <span class="mf">0.0</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
    <span class="n">f</span><span class="p">(</span> <span class="sc">&#39;a&#39;</span> <span class="p">)</span> <span class="p">;</span> <span class="c1">// false</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、関数テンプレートfにテンプレート実引数intを与えた場合だけ、元のテンプレート定義とは別の、明示的特殊化による定義を使用する。そのため、f&amp;lt;int&amp;gt;はtrueを返す。</p>
<p>明示的特殊化は、元のテンプレートの定義の影響を受けない。たとえば、関数テンプレートの場合は戻り値の型を異なるものにできるし、クラステンプレートの場合、クラスのメンバーを全く違ったものにすることもできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例では、元のテンプレートの定義であるメンバー関数X::fがなく、全く別名のメンバー関数gを定義している。</p>
<p>明示的特殊化できるテンプレートは、以下の通り。</p>
<ul>
<li><p class="first">関数テンプレート</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span> <span class="p">;</span> <span class="p">}</span>

<span class="c1">// 明示的なテンプレート実引数の指定によるもの</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span><span class="p">(</span> <span class="kt">short</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
</li>
<li></li>
</ul>
<p>クラステンプレート</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>クラステンプレートのメンバー関数</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// ひとつのメンバー関数のみを明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span> <span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>クラステンプレートのメンバー関数を個別に明示的特殊化することができる。この場合、クラステンプレートXにテンプレート実引数intを与えて実体化させた特殊化は、X::fのみ明示的特殊化の定義を使い、残りのメンバーはテンプレートから実体化された特殊化を使う。</p>
<ul class="simple">
<li></li>
</ul>
<p>クラステンプレートのstaticデータメンバー</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span> <span class="c1">// 宣言</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data</span> <span class="p">;</span> <span class="c1">// 定義</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">data</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>クラステンプレートのstaticデータメンバーの明示的特殊化は、宣言の型を変えることはできない。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">d1</span> <span class="p">;</span>
    <span class="k">static</span> <span class="n">T</span> <span class="n">d2</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 汎用的な定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>


<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">double</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">d1</span> <span class="p">;</span> <span class="c1">// エラー、型が宣言と一致しない</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">double</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">d2</span> <span class="p">;</span> <span class="c1">// エラー、型が宣言と一致しない</span>
</pre></div>
</div>
</div></blockquote>
<p>ただし、初期化式を変えることはできる。</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">data</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">data</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">data</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>クラステンプレートのメンバークラス</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Inner</span> <span class="p">{</span> <span class="cm">/* 定義 */</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Inner</span>
<span class="p">{</span>
<span class="c1">// 定義</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>クラステンプレートのメンバーenum</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="k">struct</span> <span class="n">E</span> <span class="p">{</span> <span class="n">foo</span><span class="p">,</span> <span class="n">bar</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">enum</span> <span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">E</span>
<span class="p">{</span>
    <span class="n">hoge</span><span class="p">,</span> <span class="n">moke</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<ul class="simple">
<li></li>
</ul>
<p>クラス、あるいはクラステンプレートのメンバークラステンプレート</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// クラス</span>
<span class="k">struct</span> <span class="n">Outer_class</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Inner_class_template</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer_class</span><span class="o">::</span><span class="n">Inner_class_template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="c1">// 定義</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// クラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer_class_template</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Inner_class_template</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="c1">// Outer_class_templateの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="c1">// Inner_class_templateの明示的特殊化</span>
<span class="k">struct</span> <span class="n">Outer_class_template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Inner_class_template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="c1">// 定義</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
<p>クラス、クラステンプレートを問わず、メンバークラステンプレートの明示的特殊化ができる。</p>
<ul class="simple">
<li></li>
</ul>
<p>クラス、あるいはクラステンプレートのメンバー関数テンプレート</p>
<blockquote>
<div><div class="highlight-c++"><div class="highlight"><pre><span class="c1">// クラス</span>
<span class="k">struct</span> <span class="n">Outer_class</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">member_function_template</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span><span class="c1">// クラス</span>
<span class="k">struct</span> <span class="n">Outer_class</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">member_function_template</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// メンバー関数テンプレートの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Outer_class</span><span class="o">::</span><span class="n">member_function_template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 定義</span>
<span class="p">}</span>


<span class="c1">// クラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer_class_template</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="kt">void</span> <span class="n">member_function_template</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// メンバー関数テンプレートの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="c1">// Outer_class_templateの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="c1">// member_function_templateの明示的特殊化</span>
<span class="kt">void</span> <span class="n">Outer_class_template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">member_function_template</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">// 定義</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>テンプレートの明示的特殊化は、修飾名の場合、テンプレートの宣言されている名前空間の外側で宣言することもできる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="n">ns</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// ns::fの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">ns</span><span class="o">::</span><span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>関数テンプレートとクラステンプレートの場合、明示的特殊化の元となるテンプレートの宣言は、明示的特殊化の宣言より先行していなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー、テンプレートの宣言が先行していない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// テンプレートの宣言</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// OK、テンプレートの宣言が先行している</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">short</span> <span class="p">)</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバーテンプレートに対する明示的特殊化の定義には、メンバーの属するクラスもしくはクラステンプレートの定義が先行していなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// クラスの宣言</span>
<span class="k">struct</span> <span class="n">Outer</span> <span class="p">;</span>

<span class="c1">// エラー、クラスの定義が先行していない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span><span class="o">::</span><span class="n">Inner</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// クラスの定義</span>
<span class="k">struct</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="c1">// メンバーテンプレート</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Inner</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// OK、クラスの定義が先行している</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">OUter</span><span class="o">::</span><span class="n">Inner</span><span class="o">&lt;</span><span class="kt">short</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>メンバー関数、メンバー関数テンプレート、メンバークラス、メンバーenum、メンバークラステンプレート、クラステンプレートのstaticデータメンバーは、暗黙に実体化されるクラスの特殊化に対しても、明示的に特殊化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// X&lt;int&gt;::fの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>


<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// X&lt;int&gt;を暗黙的に実体化</span>
    <span class="n">x</span><span class="p">.</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 明示的特殊化を使う</span>
    <span class="n">x</span><span class="p">.</span><span class="n">g</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 暗黙に実体化された特殊化を使う</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このように、一部のメンバーだけを明示的に特殊化できる。明示的に特殊化されなかったメンバーが使われた場合は、クラステンプレートから暗黙の実体化による特殊化が使われる。</p>
<p>メンバーの明示的特殊化より、クラステンプレートの定義が先行していなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// エラー</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>暗黙に宣言される特別なメンバー関数を明示的特殊化することはできない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
<span class="c1">// デフォルトコンストラクタ―は暗黙に宣言される</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// エラー</span>
<span class="c1">// 暗黙に宣言される特別なメンバー関数の明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Y</span>
<span class="p">{</span>
    <span class="n">Y</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span> <span class="c1">// 特別なメンバー関数の明示的な宣言</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// OK</span>
<span class="c1">// 暗黙に宣言されていない特別なメンバー関数の明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="n">Y</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Y</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>このように、特別なメンバー関数を明示的特殊化する場合には、クラステンプレートの定義内で、明示的に宣言する必要がある。</p>
<p>明示的特殊化されたクラステンプレートのメンバーは、元のクラステンプレートとは独立して存在する。そのため、元のクラステンプレートとは全く違うメンバーの宣言にすることができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span> <span class="c1">// 元のクラステンプレートとは違うメンバー</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>明示的特殊化されたクラステンプレートの定義内のメンバー宣言は、通常のクラス定義のように記述する。つまり、template &amp;lt; &amp;gt;をつける必要はない。メンバーの定義をクラス定義の外に記述する場合も同じ。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化されたクラステンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 宣言</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化されたクラステンプレート定義のメンバーの定義</span>
<span class="c1">// template &lt; &gt;は必要ない</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>ただし、明示的に特殊化されたメンバークラステンプレートのメンバーを定義するときには、template &amp;lt; &amp;gt;が必要である。メンバークラスではなく、メンバークラステンプレートであることに注意。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="c1">// メンバークラス</span>
    <span class="k">struct</span> <span class="n">Inner</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

    <span class="c1">// メンバークラステンプレート</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Inner_temp</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 特殊化Outer&lt;int&gt;のメンバークラスの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Inner</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// メンバークラスのメンバーの定義</span>
<span class="c1">// template &lt; &gt;は必要ない</span>
<span class="kt">void</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Inner</span><span class="o">::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// 特殊化Outer&lt;int&gt;のメンバークラステンプレートの明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Inner_temp</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// メンバークラステンプレートのメンバーの定義</span>
<span class="c1">// template &lt; &gt;が必要</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">U</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Inner_temp</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>テンプレート、メンバーテンプレート、クラステンプレートのメンバーが明示的に特殊化されている場合、暗黙の実体化が起こる前に、明示的特殊化が宣言されていなければならない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// テンプレートの特殊化X&lt;int&gt;の使用</span>
<span class="c1">// X&lt;int&gt;に対する暗黙の実体化が起こる。</span>
<span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span> <span class="p">;</span>

<span class="c1">// エラー、明示的特殊化の宣言より前に、特殊化の暗黙の実体化が起こっている。</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>テンプレートの明示的特殊化の名前空間スコープは、テンプレートの名前空間スコープと同じ。</p>
<p>宣言されているが定義されていない明示的特殊化を指すテンプレート名は、不完全定義されたクラスと同様に使うことができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化の宣言</span>
<span class="c1">// X&lt;int&gt;はまだ定義されていない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">;</span>

<span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">p</span> <span class="p">;</span> <span class="c1">// OK、不完全型へのポインター</span>
<span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">obj</span> <span class="p">;</span> <span class="c1">// エラー、不完全型のオブジェクト</span>
</pre></div>
</div>
<p>関数テンプレートの明示的特殊化の際のテンプレート名のテンプレート引数は、テンプレート実引数の型が、関数の実引数の型から推定できる場合は、省略することができる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span> <span class="k">struct</span> <span class="n">X</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">;</span>

<span class="c1">// 関数テンプレートf&lt;int&gt;の明示的特殊化</span>
<span class="c1">// テンプレートの特殊化の型は実引数の型から推定可能</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>ある関数テンプレートと同じ名前で、関数テンプレートの特殊化と同じ型の関数であっても、その関数は、関数テンプレートの明示的特殊化ではない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// 関数テンプレートf</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// 関数テンプレートfの明示的特殊化f&lt;int&gt;</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// 関数f</span>
<span class="c1">// 関数テンプレートfの明示的特殊化ではない</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>関数テンプレートの明示的特殊化は、宣言にinline指定子があるか、deleted定義されている場合のみ、inlineとなる。元の関数テンプレートのinline指定子の有無には影響されない。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// inline指定子のある関数テンプレート</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="n">T</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// 非inline関数</span>
<span class="c1">// 元のテンプレートのinline指定子には影響されない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// inline関数</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span> <span class="kt">short</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
<p>テンプレートのstaticデータメンバーの明示的特殊化の宣言は、初期化子を含む場合、定義となる。初期化子を含まない場合は宣言となる。デフォルト初期化が必要なstaticデータメンバーを定義する場合は、文法上の制約から、初期化リストを使う必要がある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">data</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化の宣言、定義ではない</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">data</span> <span class="p">;</span>

<span class="c1">// エラー、メンバー関数int ()の宣言</span>
<span class="c1">// 文法上の制約による</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">data</span> <span class="p">()</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化の定義</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">int</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">data</span> <span class="p">{</span> <span class="p">}</span> <span class="p">;</span>
</pre></div>
</div>
<p>クラステンプレートのメンバーとメンバーテンプレートは、クラステンプレートで定義されていて、クラステンプレートが暗黙に実体化されていても、明示的特殊化できる。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">X</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span> <span class="p">;</span>

<span class="c1">// 明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">X</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">x</span> <span class="p">;</span> <span class="c1">// X&lt;int&gt;の暗黙の実体化</span>
    <span class="n">x</span><span class="p">.</span><span class="n">f</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 明示的特殊化が使われる</span>
    <span class="n">x</span><span class="p">.</span><span class="n">g</span><span class="p">()</span> <span class="p">;</span> <span class="c1">// 暗黙の実体化により生成された特殊化が使われる</span>
<span class="p">}</span>
</pre></div>
</div>
<p>これにより、メンバーやメンバーテンプレートの一部だけを明示的に特殊化することができる。</p>
<p>ネストしたクラステンプレートのメンバーやメンバーテンプレートを明示的特殊化する場合、ネストした数だけtemplate&amp;lt;&amp;gt;を記述する必要がある。</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T1</span> <span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">Outer</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T2</span> <span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">Inner</span>
    <span class="p">{</span>
        <span class="k">template</span> <span class="o">&lt;</span> <span class="k">typename</span> <span class="n">T3</span> <span class="o">&gt;</span>
        <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="p">}</span> <span class="p">;</span>
<span class="p">}</span> <span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="c1">// Outer&lt;int&gt;の明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="c1">// Outer&lt;int&gt;::Inner&lt;int&gt;の明示的特殊化</span>
<span class="k">template</span> <span class="o">&lt;</span> <span class="o">&gt;</span> <span class="c1">// Outer&lt;int&gt;::Inner&lt;int&gt;::f&lt;int&gt;の明示的特殊化</span>
<span class="kt">void</span> <span class="n">Outer</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">Inner</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">f</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="function-template-specializations">
<h2>関数テンプレートの特殊化(Function template specializations)<a class="headerlink" href="#function-template-specializations" title="Permalink to this headline">¶</a></h2>
<p>&lt;p class=&#8221;todo&#8221;&gt;
partial orderingの解説。</p>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="except.html" title="例外(Exception handling)"
             >next</a> |</li>
        <li class="right" >
          <a href="over.html" title="オーバーロード(Overloading)"
             >previous</a> |</li>
        <li><a href="index.html">CPP Book</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Ezoe Ryou.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>